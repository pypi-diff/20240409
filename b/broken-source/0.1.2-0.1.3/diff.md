# Comparing `tmp/broken_source-0.1.2-py3-none-any.whl.zip` & `tmp/broken_source-0.1.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,27 @@
-Zip file size: 642221 bytes, number of entries: 108
--rw-r--r--  2.0 unx    61393 b- defN 20-Feb-02 00:00 Broken/Base.py
+Zip file size: 642647 bytes, number of entries: 108
+-rw-r--r--  2.0 unx    61304 b- defN 20-Feb-02 00:00 Broken/Base.py
 -rw-r--r--  2.0 unx     8139 b- defN 20-Feb-02 00:00 Broken/Dotmap.py
 -rw-r--r--  2.0 unx     6363 b- defN 20-Feb-02 00:00 Broken/Logging.py
--rw-r--r--  2.0 unx    14924 b- defN 20-Feb-02 00:00 Broken/Project.py
+-rw-r--r--  2.0 unx    14839 b- defN 20-Feb-02 00:00 Broken/Project.py
 -rw-r--r--  2.0 unx     2221 b- defN 20-Feb-02 00:00 Broken/Spinner.py
 -rw-r--r--  2.0 unx     1395 b- defN 20-Feb-02 00:00 Broken/Types.py
--rw-r--r--  2.0 unx     3666 b- defN 20-Feb-02 00:00 Broken/__init__.py
--rw-r--r--  2.0 unx    29382 b- defN 20-Feb-02 00:00 Broken/__main__.py
+-rw-r--r--  2.0 unx     3983 b- defN 20-Feb-02 00:00 Broken/__init__.py
+-rw-r--r--  2.0 unx    29393 b- defN 20-Feb-02 00:00 Broken/__main__.py
 -rw-r--r--  2.0 unx     1983 b- defN 20-Feb-02 00:00 Broken/BrokenEnum/Readme.md
 -rw-r--r--  2.0 unx     9815 b- defN 20-Feb-02 00:00 Broken/BrokenEnum/__init__.py
 -rw-r--r--  2.0 unx     3815 b- defN 20-Feb-02 00:00 Broken/BrokenEnum/__test__.py
 -rw-r--r--  2.0 unx      276 b- defN 20-Feb-02 00:00 Broken/Externals/__init__.py
 -rw-r--r--  2.0 unx     1480 b- defN 20-Feb-02 00:00 Broken/Externals/FFmpeg/Readme.md
 -rw-r--r--  2.0 unx    45735 b- defN 20-Feb-02 00:00 Broken/Externals/FFmpeg/__init__.py
 -rw-r--r--  2.0 unx     4964 b- defN 20-Feb-02 00:00 Broken/Externals/Upscaler/__init__.py
 -rw-r--r--  2.0 unx     5221 b- defN 20-Feb-02 00:00 Broken/Externals/Upscaler/ncnn.py
--rw-r--r--  2.0 unx      618 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderBytes.py
--rw-r--r--  2.0 unx     1601 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderPIL.py
--rw-r--r--  2.0 unx      648 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderString.py
+-rw-r--r--  2.0 unx      811 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderBytes.py
+-rw-r--r--  2.0 unx     1910 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderPIL.py
+-rw-r--r--  2.0 unx      852 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderString.py
 -rw-r--r--  2.0 unx      344 b- defN 20-Feb-02 00:00 Broken/Loaders/__init__.py
 -rw-r--r--  2.0 unx     4765 b- defN 20-Feb-02 00:00 Broken/Resources/Fonts/DejaVu License.txt
 -rw-r--r--  2.0 unx   757076 b- defN 20-Feb-02 00:00 Broken/Resources/Fonts/DejaVuSans.ttf
 -rw-r--r--  2.0 unx     8764 b- defN 20-Feb-02 00:00 Broken/Resources/Images/Broken.ico
 -rw-r--r--  2.0 unx    15418 b- defN 20-Feb-02 00:00 Broken/Resources/Images/Broken.png
 -rw-r--r--  2.0 unx     1444 b- defN 20-Feb-02 00:00 Broken/Resources/Images/Broken.svg
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 Broken/Staging/__init__.py
@@ -30,51 +30,51 @@
 -rw-r--r--  2.0 unx    12082 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/BrokenDotmap.py
 -rw-r--r--  2.0 unx      368 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/Readme.md
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/__init__.py
 -rw-r--r--  2.0 unx     3568 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/__test__.py
 -rw-r--r--  2.0 unx     1467 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/Loaders/LoaderPIL.py
 -rw-r--r--  2.0 unx     1263 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/Loaders/LoaderTOML.py
 -rw-r--r--  2.0 unx       68 b- defN 20-Feb-02 00:00 Broken/Staging/Dotmap/Loaders/__init__.py
--rw-r--r--  2.0 unx     7207 b- defN 20-Feb-02 00:00 DepthFlow/DepthFlow.py
+-rw-r--r--  2.0 unx     9545 b- defN 20-Feb-02 00:00 DepthFlow/DepthFlow.py
 -rw-r--r--  2.0 unx      356 b- defN 20-Feb-02 00:00 DepthFlow/__init__.py
 -rw-r--r--  2.0 unx      350 b- defN 20-Feb-02 00:00 DepthFlow/__main__.py
 -rw-r--r--  2.0 unx    14623 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Images/DepthFlow.png
 -rw-r--r--  2.0 unx     1445 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Images/DepthFlow.svg
--rw-r--r--  2.0 unx     2295 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlow.frag
+-rw-r--r--  2.0 unx     2499 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlow.frag
 -rw-r--r--  2.0 unx     2499 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlow2D.frag
 -rw-r--r--  2.0 unx     1688 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlowMarch.frag
 -rw-r--r--  2.0 unx     3031 b- defN 20-Feb-02 00:00 Pianola/Pianola.py
 -rw-r--r--  2.0 unx      280 b- defN 20-Feb-02 00:00 Pianola/__init__.py
 -rw-r--r--  2.0 unx      302 b- defN 20-Feb-02 00:00 Pianola/__main__.py
 -rw-r--r--  2.0 unx    12579 b- defN 20-Feb-02 00:00 Pianola/Resources/Images/Pianola.png
 -rw-r--r--  2.0 unx     3038 b- defN 20-Feb-02 00:00 Pianola/Resources/Images/Pianola.svg
 -rw-r--r--  2.0 unx    27430 b- defN 20-Feb-02 00:00 Pianola/Resources/Midis/Hopeless Sparkle.mid
--rw-r--r--  2.0 unx     8165 b- defN 20-Feb-02 00:00 Pianola/Resources/Shaders/Pianola.frag
+-rw-r--r--  2.0 unx     8171 b- defN 20-Feb-02 00:00 Pianola/Resources/Shaders/Pianola.frag
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Imgui.py
 -rw-r--r--  2.0 unx     2574 b- defN 20-Feb-02 00:00 ShaderFlow/Message.py
 -rw-r--r--  2.0 unx     3321 b- defN 20-Feb-02 00:00 ShaderFlow/Module.py
 -rw-r--r--  2.0 unx     3878 b- defN 20-Feb-02 00:00 ShaderFlow/Notes.py
--rw-r--r--  2.0 unx    37584 b- defN 20-Feb-02 00:00 ShaderFlow/Scene.py
--rw-r--r--  2.0 unx    11684 b- defN 20-Feb-02 00:00 ShaderFlow/Shader.py
+-rw-r--r--  2.0 unx    36552 b- defN 20-Feb-02 00:00 ShaderFlow/Scene.py
+-rw-r--r--  2.0 unx    11798 b- defN 20-Feb-02 00:00 ShaderFlow/Shader.py
 -rw-r--r--  2.0 unx    12979 b- defN 20-Feb-02 00:00 ShaderFlow/Texture.py
 -rw-r--r--  2.0 unx     4219 b- defN 20-Feb-02 00:00 ShaderFlow/Variable.py
--rw-r--r--  2.0 unx      437 b- defN 20-Feb-02 00:00 ShaderFlow/__init__.py
--rw-r--r--  2.0 unx     3699 b- defN 20-Feb-02 00:00 ShaderFlow/__main__.py
--rw-r--r--  2.0 unx    12133 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Audio.py
--rw-r--r--  2.0 unx     2806 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Bouncing.py
+-rw-r--r--  2.0 unx      380 b- defN 20-Feb-02 00:00 ShaderFlow/__init__.py
+-rw-r--r--  2.0 unx     3562 b- defN 20-Feb-02 00:00 ShaderFlow/__main__.py
+-rw-r--r--  2.0 unx    12171 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Audio.py
+-rw-r--r--  2.0 unx     3175 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Bouncing.py
 -rw-r--r--  2.0 unx    17629 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Camera.py
 -rw-r--r--  2.0 unx     9042 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Dynamics.py
 -rw-r--r--  2.0 unx     2332 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Frametimer.py
 -rw-r--r--  2.0 unx     1494 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Keyboard.py
 -rw-r--r--  2.0 unx     2475 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Noise.py
--rw-r--r--  2.0 unx    16180 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Piano.py
+-rw-r--r--  2.0 unx    14001 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Piano.py
 -rw-r--r--  2.0 unx    10943 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Spectrogram.py
--rw-r--r--  2.0 unx     7197 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Video.py
+-rw-r--r--  2.0 unx     7218 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Video.py
 -rw-r--r--  2.0 unx     3137 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Waveform.py
--rw-r--r--  2.0 unx      300 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/__init__.py
 -rw-r--r--  2.0 unx     3961 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/Monocular.py
 -rw-r--r--  2.0 unx        2 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/OpticalFlow.py
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/__init__.py
 -rw-r--r--  2.0 unx    20132 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Images/ShaderFlow.png
 -rw-r--r--  2.0 unx     1448 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Images/ShaderFlow.svg
 -rw-r--r--  2.0 unx    10158 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/Demo.py
@@ -99,12 +99,12 @@
 -rw-r--r--  2.0 unx      538 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Vertex/Default.glsl
 -rw-r--r--  2.0 unx     1965 b- defN 20-Feb-02 00:00 SpectroNote/SpectroNote.py
 -rw-r--r--  2.0 unx      290 b- defN 20-Feb-02 00:00 SpectroNote/__init__.py
 -rw-r--r--  2.0 unx      342 b- defN 20-Feb-02 00:00 SpectroNote/__main__.py
 -rw-r--r--  2.0 unx    20132 b- defN 20-Feb-02 00:00 SpectroNote/Resources/Images/SpectroNote.png
 -rw-r--r--  2.0 unx     1448 b- defN 20-Feb-02 00:00 SpectroNote/Resources/Images/SpectroNote.svg
 -rw-r--r--  2.0 unx     3088 b- defN 20-Feb-02 00:00 SpectroNote/Resources/Shaders/SpectroNote.frag
-?rw-r--r--  2.0 unx     2934 b- defN 20-Feb-02 00:00 broken_source-0.1.2.dist-info/METADATA
-?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 broken_source-0.1.2.dist-info/WHEEL
-?rw-r--r--  2.0 unx      194 b- defN 20-Feb-02 00:00 broken_source-0.1.2.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     9764 b- defN 20-Feb-02 00:00 broken_source-0.1.2.dist-info/RECORD
-108 files, 1388567 bytes uncompressed, 626615 bytes compressed:  54.9%
+?rw-r--r--  2.0 unx     3026 b- defN 20-Feb-02 00:00 broken_source-0.1.3.dist-info/METADATA
+?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 broken_source-0.1.3.dist-info/WHEEL
+?rw-r--r--  2.0 unx      194 b- defN 20-Feb-02 00:00 broken_source-0.1.3.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     9762 b- defN 20-Feb-02 00:00 broken_source-0.1.3.dist-info/RECORD
+108 files, 1388902 bytes uncompressed, 627041 bytes compressed:  54.9%
```

## zipnote {}

```diff
@@ -306,20 +306,20 @@
 
 Filename: SpectroNote/Resources/Images/SpectroNote.svg
 Comment: 
 
 Filename: SpectroNote/Resources/Shaders/SpectroNote.frag
 Comment: 
 
-Filename: broken_source-0.1.2.dist-info/METADATA
+Filename: broken_source-0.1.3.dist-info/METADATA
 Comment: 
 
-Filename: broken_source-0.1.2.dist-info/WHEEL
+Filename: broken_source-0.1.3.dist-info/WHEEL
 Comment: 
 
-Filename: broken_source-0.1.2.dist-info/entry_points.txt
+Filename: broken_source-0.1.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: broken_source-0.1.2.dist-info/RECORD
+Filename: broken_source-0.1.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Broken/Base.py

```diff
@@ -99,18 +99,16 @@
         return result
     return wrapper
 
 def apply(callback: Callable, iterable: Iterable[Any]) -> List[Any]:
     """map(f, x) is lazy, this consumes the generator returning a list"""
     return list(map(callback, iterable))
 
-@easy_multiple
-def denum(*items: Any) -> Any:
-    """De-enumerates enum iterables to their value"""
-    return apply(lambda item: item.value if isinstance(item, Enum) else item, items)
+def denum(item: Any) -> Any:
+    return (item.value if isinstance(item, Enum) else item)
 
 @staticmethod
 def dunder(name: str) -> bool:
     return name.startswith("__") and name.endswith("__")
 
 class Ignore:
     """A class that does nothing. No-operation faster Mock"""
@@ -648,15 +646,15 @@
             return
 
         # Send the GET request, we might be offline!
         try:
             response = requests.get(url, stream=True)
         except requests.exceptions.RequestException as error:
             log.error(f"Failed to download file ({url}) → ({output}): {error}", echo=echo)
-            return
+            return output
 
         size = int(response.headers.get('content-length', 0))
 
         # The file might already be (partially) downloaded
         if output.exists():
             A, B = (output.stat().st_size, size)
             if (A == B):
```

## Broken/Project.py

```diff
@@ -433,17 +433,16 @@
         ascii = pyfiglet.figlet_format(self.APP_NAME, font="dos_rebel", width=1000)
         ascii = '\n'.join((x for x in ascii.split('\n') if x.strip()))
 
         # Print panel center-justified lines
         rprint(Panel(
             Align.center(ascii),
             subtitle=' '.join((
-                f"Made with ❤️ by {self.APP_AUTHOR}.",
-                ("Release version." if Broken.RELEASE else "Development version"),
-                f"(Python {sys.version.split()[0]})"
+                f"Made with ❤️ by {self.APP_AUTHOR},",
+                f"Python {sys.version.split()[0]}"
             )),
             padding=1,
             title_align="center",
             subtitle_align="center",
         ))
         print()
```

## Broken/__init__.py

```diff
@@ -87,14 +87,19 @@
 
 # -------------------------------------------------------------------------------------------------|
 # Small fixes
 
 # https://github.com/numpy/numpy/issues/18669#issuecomment-820510379
 os.environ["OMP_NUM_THREADS"] = "1"
 
+# https://forums.developer.nvidia.com/t/glxswapbuffers-gobbling-up-a-full-cpu-core-when-vsync-is-off/156635
+# https://forums.developer.nvidia.com/t/gl-yield-and-performance-issues/27736
+# High CPU usage on glfw.swap_buffers when vsync is off and the GPU is wayy behind own vblank
+os.environ["__GL_YIELD"] = "USLEEP"
+
 # Patch torch.jit requiring inspect.getsource
 # https://github.com/pytorch/vision/issues/1899#issuecomment-598200938
 if PYINSTALLER:
     try:
         import torch.jit
         def patch(object, **kwargs):
             return object
```

## Broken/__main__.py

```diff
@@ -470,15 +470,15 @@
         if all or build:    BrokenPath.remove(Broken.BROKEN.DIRECTORIES.BROKEN_BUILD)
         if all or releases: BrokenPath.remove(Broken.BROKEN.DIRECTORIES.BROKEN_RELEASES)
 
     def docs(self, deploy: Annotated[bool, Option("--deploy", "-d", help="Deploy Documentation to GitHub Pages")]=False) -> None:
         """📚 Generate or Deploy Documentation for all Projects"""
         GITHUB_PAGE = "git@github.com:BrokenSource/brokensource.github.io.git"
         if deploy:
-            shell("mkdocs", "gh-deploy", "--remote-name", GITHUB_PAGE)
+            shell("mkdocs", "gh-deploy", "--force", "--remote-name", GITHUB_PAGE)
         else:
             shell("mkdocs", "serve")
 
     def pypi(self,
         publish: Annotated[bool, Option("--publish", "-p", help="Publish the wheel to PyPI")]=False,
         test:    Annotated[bool, Option("--test",    "-t", help="Upload to TestPyPI")]=False,
     ) -> None:
```

## Broken/Loaders/LoaderBytes.py

```diff
@@ -1,9 +1,10 @@
 from pathlib import Path
 from typing import Any, Optional, Union
+from Broken.Logging import log
 
 from attr import define
 
 from Broken.Base import BrokenPath
 
 from . import BrokenLoader
 
@@ -13,18 +14,21 @@
 
     @staticmethod
     def load(value: Any=None, **kwargs) -> Optional[bytes]:
         if not value:
             return b""
 
         elif isinstance(value, bytes):
+            log.debug(f"Loading Bytes from Bytes")
             return value
 
         elif isinstance(value, str):
+            log.debug(f"Loading Bytes from String")
             return value.encode()
 
         elif (path := BrokenPath(value, valid=True)):
+            log.debug(f"Loading Bytes from Path ({path})")
             return path.read_bytes()
 
         return None
 
 LoadableBytes = Union[bytes, str, Path, None]
```

## Broken/Loaders/LoaderPIL.py

```diff
@@ -1,9 +1,10 @@
 import io
 from pathlib import Path
+from Broken.Logging import log
 from typing import Any, Optional, Union
 
 import numpy
 import PIL
 import validators
 from attr import define
 from PIL.Image import Image
@@ -33,29 +34,35 @@
         return LoaderImage._cache
 
     @staticmethod
     def load(value: Any=None, **kwargs) -> Optional[Image]:
         if value is None:
             return None
 
-        elif isinstance(value, numpy.ndarray):
-            return PIL.Image.fromarray(value, **kwargs)
-
         elif isinstance(value, Image):
+            log.debug(f"Loading Image from Image")
             return value
 
+        elif isinstance(value, numpy.ndarray):
+            log.debug(f"Loading Image from Numpy Array")
+            return PIL.Image.fromarray(value, **kwargs)
+
         elif (path := BrokenPath(value, valid=True)):
+            log.debug(f"Loading Image from Path ({path})")
             return PIL.Image.open(path, **kwargs)
 
         elif validators.url(value):
+            log.debug(f"Loading Image from URL ({value})")
+
             if LoaderImage.cache():
                 return PIL.Image.open(io.BytesIO(LoaderImage.cache().get(value).content), **kwargs)
 
             import requests
             return PIL.Image.open(io.BytesIO(requests.get(value).content), **kwargs)
 
         elif isinstance(value, bytes):
+            log.debug(f"Loading Image from Bytes")
             return PIL.Image.open(io.BytesIO(value), **kwargs)
 
         return None
 
 LoadableImage = Union[Image, Path, URL, numpy.ndarray, bytes, None]
```

## Broken/Loaders/LoaderString.py

```diff
@@ -1,11 +1,12 @@
 from pathlib import Path
 from typing import Any, Optional, Union
 
 from attr import define
+from Broken.Logging import log
 
 from Broken.Base import BrokenPath
 
 from . import BrokenLoader
 
 
 @define
@@ -13,18 +14,21 @@
 
     @staticmethod
     def load(value: Any=None, **kwargs) -> Optional[str]:
         if not value:
             return ""
 
         elif isinstance(value, str):
+            log.debug(f"Loading String from String {value}")
             return value
 
         elif isinstance(value, bytes):
+            log.debug(f"Loading String from Bytes")
             return value.decode(encoding="utf-8")
 
         elif (path := BrokenPath(value, valid=True)):
+            log.debug(f"Loading String from Path ({path})")
             return path.read_text(encoding="utf-8")
 
         return None
 
 LoadableString = Union[str, bytes, Path, None]
```

## DepthFlow/DepthFlow.py

```diff
@@ -1,10 +1,10 @@
 import math
 from threading import Thread
-from typing import Annotated, Iterable
+from typing import Annotated, Iterable, Tuple
 
 import imgui
 from attr import define, field
 from PIL import Image
 from ShaderFlow import SHADERFLOW
 from ShaderFlow.Message import Message
 from ShaderFlow.Optional.Monocular import Monocular
@@ -77,19 +77,35 @@
         self._loading = BrokenThread.new(load)
 
         # Wait until loading finish
         if block: self._loading.join()
 
     # ------------------------------------------|
 
-    def _ui_(self) -> None:
-        if (state := imgui.checkbox("Fixed", self.parallax_fixed))[0]:
-            self.parallax_fixed = state[1]
-        if (state := imgui.input_float("Height", self.parallax_height, 0.01, 0.01, "%.2f"))[0]:
+    def ui(self) -> None:
+        if (state := imgui.slider_float("Height", self.parallax_height, 0, 1, "%.2f"))[0]:
             self.parallax_height = max(0, state[1])
+        if (state := imgui.slider_float("Focus", self.parallax_focus, 0, 1, "%.2f"))[0]:
+            self.parallax_focus = max(0, state[1])
+        if (state := imgui.slider_float("Invert", self.parallax_invert, 0, 1, "%.2f"))[0]:
+            self.parallax_invert = max(0, state[1])
+        if (state := imgui.slider_float("Zoom", self.parallax_zoom, 0, 2, "%.2f"))[0]:
+            self.parallax_zoom = max(0, state[1])
+        if (state := imgui.slider_float("Isometric", self.parallax_isometric, 0, 1, "%.2f"))[0]:
+            self.parallax_isometric = max(0, state[1])
+        if (state := imgui.slider_float("Dolly", self.parallax_dolly, 0, 5, "%.2f"))[0]:
+            self.parallax_dolly = max(0, state[1])
+        if (state := imgui.slider_float("Offset X", self.parallax_offset[0], -2, 2, "%.2f"))[0]:
+            self.parallax_offset[0] = state[1]
+        if (state := imgui.slider_float("Offset Y", self.parallax_offset[1], -2, 2, "%.2f"))[0]:
+            self.parallax_offset[1] = state[1]
+        if (state := imgui.slider_float("Center X", self.parallax_center[0], -2, 2, "%.2f"))[0]:
+            self.parallax_center[0] = state[1]
+        if (state := imgui.slider_float("Center Y", self.parallax_center[1], -2, 2, "%.2f"))[0]:
+            self.parallax_center[1] = state[1]
 
     def _load_new_or_default(self):
 
         # Set default image if none provided
         if self.image.is_empty():
             self.input(image=DepthFlowScene.DEFAULT_IMAGE)
 
@@ -104,23 +120,40 @@
             self.shader.fragment = self.DEPTH_SHADER
             self.shader.load_shaders()
             self._loading = None
             self.time = 0
 
     # ------------------------------------------|
 
-    # Parallax parameters
-    parallax_fixed     = field(default=True)
-    parallax_height    = field(default=0.2)
-    parallax_focus     = field(default=1.0)
-    parallax_zoom      = field(default=1.0)
-    parallax_isometric = field(default=0.0)
-    parallax_dolly     = field(default=0.0)
-    parallax_x         = field(default=0.0)
-    parallax_y         = field(default=0.0)
+    parallax_height: float = field(default=0.3)
+    """Peak value of the Depth Map, in the range [0, 1]. The camera is 1 distance away from depth=0
+    at the z=1 plane, so this also controls the intensity of the effect"""
+
+    parallax_focus: float = field(default=0.0)
+    """Focal depth of the effect, in the range [0, 1]. A value of 0 makes the background (depth=0)
+    stationary, while a value of 1 makes the foreground (depth=1) stationary on displacements"""
+
+    parallax_invert: float = field(default=0.0)
+    """Interpolate between (0=max, 1=min)=0 or (0=min, 1=max)=1 Depth Map's value interpretation"""
+
+    parallax_zoom: float = field(default=1.0)
+    """Camera zoom factor, in the range [0, inf]. 2 means a quarter of the image is visible"""
+
+    parallax_isometric: float = field(default=0.0)
+    """Isometric factor of the camera projection. Zero is fully perspective, 1 is orthographic"""
+
+    parallax_dolly: float = field(default=0.0)
+    """Same effect as isometric, but with "natural units" of AFAIK `isometric = atan(dolly)*(2/pi)`.
+    Keeps the ray target constant and move back ray origins by this amount"""
+
+    parallax_offset: Tuple[float, float] = field(factory=lambda: [0, 0])
+    """The effect displacement offset, change this over time for the 3D parallax effect"""
+
+    parallax_center: Tuple[float, float] = field(factory=lambda: [0, 0])
+    """Focal point of the offsets, use this to center off-screen objects"""
 
     def commands(self):
         self.broken_typer.command(self.input)
 
     def setup(self):
         self._load_new_or_default()
 
@@ -132,41 +165,44 @@
     def update(self):
         self._load_new_or_default()
 
         # In and out dolly zoom
         self.parallax_dolly = 0.5*(1 + math.cos(self.time))
 
         # Infinite 8 loop shift
-        self.parallax_x = 0.1 * math.sin(  self.time)
-        self.parallax_y = 0.1 * math.sin(2*self.time)
+        self.parallax_offset = [
+            0.1 * math.sin(self.time),
+            0.1 * math.sin(2*self.time)
+        ]
 
-        # Oscillating rotation
+        # # Oscillating rotation
         self.camera.rotate(
             direction=self.camera.base_z,
             angle=math.cos(self.time)*self.dt*0.4
         )
 
-        # Zoom out on the start
-        # self.parallax_zoom = 0.6 + 0.4*(2/math.pi)*math.atan(3*self.time)
+        # Zoom in on the start
+        # self.parallax_zoom = 1.2 - 0.2*(2/math.pi)*math.atan(self.time)
 
     def handle(self, message: Message):
         ShaderScene.handle(self, message)
         if isinstance(message, Message.Window.FileDrop):
             files = iter(message.files)
             self.input(image=next(files), depth=next(files, None))
 
     def pipeline(self) -> Iterable[ShaderVariable]:
         yield from ShaderScene.pipeline(self)
-        yield ShaderVariable("uniform", "bool",  "iParallaxFixed",     self.parallax_fixed)
         yield ShaderVariable("uniform", "float", "iParallaxHeight",    self.parallax_height)
         yield ShaderVariable("uniform", "float", "iParallaxFocus",     self.parallax_focus)
+        yield ShaderVariable("uniform", "float", "iParallaxInvert",    self.parallax_invert)
         yield ShaderVariable("uniform", "float", "iParallaxZoom",      self.parallax_zoom)
         yield ShaderVariable("uniform", "float", "iParallaxIsometric", self.parallax_isometric)
         yield ShaderVariable("uniform", "float", "iParallaxDolly",     self.parallax_dolly)
-        yield ShaderVariable("uniform", "vec2",  "iParallaxPosition",  (self.parallax_x, self.parallax_y))
+        yield ShaderVariable("uniform", "vec2",  "iParallaxOffset",    self.parallax_offset)
+        yield ShaderVariable("uniform", "vec2",  "iParallaxCenter",    self.parallax_center)
 
 # -------------------------------------------------------------------------------------------------|
 
 class YourFlow(DepthFlowScene):
     """Example of defining your own class based on DepthFlowScene"""
 
     def update(self):
```

## DepthFlow/Resources/Shaders/DepthFlow.frag

```diff
@@ -2,76 +2,74 @@
 // (c) 2023-2024 CC BY-SA 4.0, Tremeschin
 */
 
 void main() {
     Camera iCamera = iInitCamera(gluv);
 
     // Add parallax options
-    iCamera.position.xy += iParallaxPosition;
+    iCamera.position.xy += iParallaxOffset;
     iCamera.isometric   += iParallaxIsometric;
     iCamera.dolly       += iParallaxDolly;
     iCamera.zoom        += iParallaxZoom - 1;
     iCamera              = iProjectCamera(iCamera);
 
     // Doesn't intersect with the XY plane
     if (iCamera.out_of_bounds) {
         fragColor = vec4(vec3(0.2), 1);
         return;
     }
 
     // // DepthFlow math
 
-    // Point where the ray intersects with the XY plane
-    vec2 lambda = iCamera.gluv;
+    // Point where the ray intersects with the fixed image plane
+    vec2 lambda = (iCamera.gluv - iCamera.position.xy);
 
-    // No camera displacement mode, raw parallax
-    if (iParallaxFixed) {
-        lambda -= iCamera.position.xy;
-    }
+    // Same as above but overshooted by depth focal point (fixed point at depth=focus)
+    vec2 sigma  = iCamera.gluv - iCamera.position.xy * (1 + iParallaxFocus*iParallaxHeight);
 
     // The vector from Lambda to the camera's projection on the XY plane
-    vec2 displacement = iCamera.origin.xy - lambda;
+    vec2 displacement = (iCamera.origin.xy - lambda) + iParallaxCenter;
+    vec2 walk = normalize(displacement);
 
     // Angle between the Ray's origin and the XY plane
     float theta = atan(
         length(displacement),
         abs(1 - iCamera.origin.z)
     );
 
     // The distance Beta we care for the depth map
     float delta = abs(tan(theta) * (1 - iCamera.origin.z - iParallaxHeight));
     float alpha = abs(tan(theta) * (1 - iCamera.origin.z));
     float beta  = abs(alpha - delta);
 
-    // The vector we should walk towards
-    vec2 walk = normalize(displacement);
-
     // Start the parallax on the point itself
-    vec2 parallax = lambda;
+    vec2 parallax = gluv2stuv(sigma);
 
     // The quality of the parallax effect is how tiny the steps are
     const float min_quality = 0.07;
     const float max_quality = 0.002;
     float quality = mix(min_quality, max_quality, iQuality);
 
+    // Note: The Very Expensive Loop
     // Fixme: Can we smartly cache the last walk distance?
     // Fixme: Calculate walk distance based on pixel and angle?
-    // The Very Expensive Loop™
-    for (float i=0.0; i<1.0; i+=quality) {
+    for (float i=1; i>0; i-=quality) {
 
         // Get the uv we'll check for the heights
-        vec2 sample = gluv2stuv(lambda + i*beta*walk);
+        vec2 sample = gluv2stuv(sigma + i*beta*walk);
 
-        // The depth map value
-        float depth_height = iParallaxHeight * draw_image(depth, sample).r;
+        // Interpolate between (0=max) and (0=min) depending on focus
+        float height       = draw_image(depth, sample).r;
+        float depth_height = iParallaxHeight * mix(height, 1-height, iParallaxInvert);
         float walk_height  = (i*beta) / tan(theta);
 
-        // Update uv until the last height > walk
+        // Stop whenever an intersection is found
         if (depth_height >= walk_height) {
             parallax = sample;
+            break;
         }
     }
 
     // Draw the parallax image
     fragColor = draw_image(image, parallax);
 }
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## Pianola/Resources/Shaders/Pianola.frag

```diff
@@ -132,15 +132,15 @@
     } else {
 
         // Piano roll canvas coordinate (-1 to 1)
         vec2 roll = vec2(uv.x, lerp(iPianoHeight, 0, 1, 1, uv.y));
         float seconds = iTime+iPianoRollTime*roll.y;
 
         // Find the current tempo on iPianoTempo texture, pairs or (when, tempo)
-        float beat;
+        float beat = 120;
         for (int i=0; i<100; i++) {
             vec4 tempo = texelFetch(iPianoTempo, ivec2(i, 0), 0);
             if (tempo.y < 1) break;
             beat = 60.0/tempo.y;
             if (seconds < tempo.x) {
                 break;
             }
```

## ShaderFlow/Scene.py

```diff
@@ -27,14 +27,15 @@
     BrokenPlatform,
     BrokenThread,
     BrokenTyper,
     BrokenUtils,
     Ignore,
     SameTracker,
     clamp,
+    denum,
     flatten,
 )
 from Broken.BrokenEnum import BrokenEnum
 from Broken.Externals.FFmpeg import (
     BrokenFFmpeg,
     FFmpegAudioCodec,
     FFmpegFilterFactory,
@@ -97,27 +98,27 @@
             str(BROKEN.RESOURCES.FONTS/"DejaVuSans.ttf"),
             16*self.imguio.font_global_scale,
         )
 
         # Default modules
         self.init_window()
         log.info(f"{self.who} Adding default base Scene modules")
-        ShaderFrametimer(self)
+        ShaderFrametimer(scene=self)
         self.keyboard = ShaderKeyboard(scene=self)
         self.camera   = ShaderCamera(scene=self)
 
         # Create the SSAA Workaround engines
         log.info(f"{self.who} Creating SSAA Implementation")
         self.shader = Shader(self)
         self.shader.texture.name = "iScreen"
         self.shader.texture.track = True
         self._final = Shader(self)
         self._final.texture.components = 3
-        self._final.texture.final = True
         self._final.texture.dtype = "f1"
+        self._final.texture.final = True
         self._final.texture.track = True
         self._final.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/"Final.glsl")
 
     # ---------------------------------------------------------------------------------------------|
     # Basic information
 
     time:       Seconds = 0.0
@@ -140,42 +141,43 @@
     # # Title
 
     _title: str = "ShaderFlow"
 
     @property
     def title(self) -> str:
         return self._title
+
     @title.setter
     def title(self, value: str) -> None:
         log.info(f"{self.who} Changing Window Title to ({value})")
         self.window.title = value
         self._title = value
 
     # # Resizable
 
     _resizable: bool = True
 
     @property
     def resizable(self) -> bool:
         return self._resizable
+
     @resizable.setter
     def resizable(self, value: bool) -> None:
         log.info(f"{self.who} Changing Window Resizable to ({value})")
         self.window.resizable = value
         self._resizable = value
-        if (self._backend == ShaderBackend.GLFW):
-            glfw.set_window_attrib(self.window._window, glfw.RESIZABLE, value)
 
     # # Visible
 
     _visible: bool = False
 
     @property
     def visible(self) -> bool:
         return self._visible
+
     @visible.setter
     def visible(self, value: bool) -> None:
         log.info(f"{self.who} Changing Window Visibility to ({value})")
         self.window.visible = value
         self._visible = value
 
     # # Video modes and monitor
@@ -200,15 +202,15 @@
     @property
     def monitor_resolution(self) -> Optional[Tuple[int, int]]:
         if (mode := self.video_mode):
             return (mode.size.width, mode.size.height)
 
     # # Resolution
 
-    quality: float = field(default=75,   converter=lambda x: clamp(x, 0, 100))
+    quality: float = field(default=80,   converter=lambda x: clamp(x, 0, 100))
     _ssaa:   float = field(default=1.0,  converter=lambda x: max(0.01, x))
     _width:  int   = field(default=1920, converter=lambda x: max(1, x))
     _height: int   = field(default=1080, converter=lambda x: max(1, x))
 
     def resize(self, width: int=Unchanged, height: int=Unchanged) -> Self:
         """
         Resize the true final rendering resolution of the Scene
@@ -234,42 +236,46 @@
             log.info(f"{self.who} Resizing window to resolution {self.resolution}")
             self._width, self._height = resolution
             self.opengl.screen.viewport = (0, 0, self.width, self.height)
             self.window.size = self.resolution
         return self
 
     def read_screen(self) -> bytes:
-        return self.opengl.screen.read(viewport=(0, 0, self.width, self.height), components=3)
+        return self.opengl.screen.read(viewport=(0, 0, self.width, self.height))
 
     # # Resolution related
 
     @property
     def width(self) -> int:
         return self._width
+
     @width.setter
     def width(self, value: int) -> None:
         self.resize(width=value)
 
     @property
     def height(self) -> int:
         return self._height
+
     @height.setter
     def height(self, value: int) -> None:
         self.resize(height=value)
 
     @property
     def resolution(self) -> Tuple[int, int]:
         return self.width, self.height
+
     @resolution.setter
     def resolution(self, value: Tuple[int, int]) -> None:
         self.resize(*value)
 
     @property
     def ssaa(self) -> float:
         return self._ssaa
+
     @ssaa.setter
     def ssaa(self, value: float) -> None:
         log.info(f"{self.who} Changing Fractional SSAA to {value}")
         self._ssaa = value
         self.relay(Message.Shader.RecreateTextures)
 
     @property
@@ -283,36 +289,19 @@
     # # Window Fullscreen
 
     _fullscreen: bool = False
 
     @property
     def fullscreen(self) -> bool:
         return self._fullscreen
+
     @fullscreen.setter
     def fullscreen(self, value: bool) -> None:
         log.info(f"{self.who} Changing Window Fullscreen to ({value})")
         self._fullscreen = value
-        try:
-            self.window.fullscreen = value
-        except AttributeError:
-            pass
-
-    # # Window Vsync
-
-    _window_vsync: bool = False
-
-    @property
-    def window_vsync(self) -> bool:
-        """Set the Window's native Vsync, not recommended at all since BrokenEventLoop is better"""
-        return self._window_vsync
-    @window_vsync.setter
-    def window_vsync(self, value: bool) -> None:
-        log.info(f"{self.who} Changing Window Native Vsync to ({value})")
-        self._window_vsync = value
-        self.window.vsync = value
 
     # # Window Exclusive
 
     _exclusive: bool = False
 
     @property
     def exclusive(self) -> bool:
@@ -320,68 +309,49 @@
 
     @exclusive.setter
     def exclusive(self, value: bool) -> None:
         log.info(f"{self.who} Changing Window Exclusive to ({value})")
         self.window.mouse_exclusivity = value
         self._exclusive = value
 
-    # # Focused
-
-    _focused: bool = False
-
-    @property
-    def focused(self) -> bool:
-        return self._focused
-
-    @focused.setter
-    def focused(self, value: bool) -> None:
-        log.info(f"{self.who} Changing Window Focused to ({value})")
-        if (self._backend == ShaderBackend.GLFW):
-            glfw.set_window_attrib(self.window._window, glfw.FOCUSED, value)
-        self._focused = value
-
     # # Backend
 
-    _backend: ShaderBackend = ShaderBackend.GLFW
-
-    @property
-    def backend(self) -> ShaderBackend:
-        """The ModernGL Window Backend of the Window. Cannot be changed after creation."""
-        return self._backend
+    _backend: ShaderBackend = ShaderBackend.get(os.environ.get("SHADERFLOW_BACKEND", ShaderBackend.GLFW))
+    """The ModernGL Window Backend. Cannot be changed after creation."""
 
     opengl: moderngl.Context = None
     """ModernGL Context of this Scene"""
 
     window: ModernglWindow = None
-    """ModernGL Window object with context/backend defined on self.backend"""
+    """ModernGL Window object with context/backend defined on self._backend"""
 
     imgui: ModernglImgui = None
     """ModernGL Imgui integration class bound to the Window"""
 
     imguio: Any = None
     """Imgui IO object"""
 
     # Todo: Proper UI classes? For main menu, settings, exporting, etc
     render_ui: bool = False
     """Whether to render the Main UI"""
 
     def init_window(self) -> None:
         """Create the window and the OpenGL context"""
         log.info(f"{self.who} Creating Window and OpenGL Context")
-        log.info(f"{self.who} • Backend:    {self.backend}")
+        log.info(f"{self.who} • Backend:    {denum(self._backend)}")
         log.info(f"{self.who} • Resolution: {self.resolution}")
 
-        module = f"moderngl_window.context.{self.backend.value.lower()}"
+        module = f"moderngl_window.context.{denum(self._backend).lower()}"
         self.window = importlib.import_module(module).Window(
             size=self.resolution,
             title=self.title,
             resizable=self.resizable,
             visible=self.visible,
             fullscreen=self.fullscreen,
-            vsync=False if self.rendering else self.window_vsync,
+            vsync=False,
         )
         ShaderKeyboard.set_keymap(self.window.keys)
         self.imgui  = ModernglImgui(self.window)
         self.opengl = self.window.ctx
 
         # Bind window events to relay
         self.window.resize_func               = self.__window_resize__
@@ -389,22 +359,21 @@
         self.window.iconify_func              = self.__window_iconify__
         self.window.key_event_func            = self.__window_key_event__
         self.window.mouse_position_event_func = self.__window_mouse_position_event__
         self.window.mouse_press_event_func    = self.__window_mouse_press_event__
         self.window.mouse_release_event_func  = self.__window_mouse_release_event__
         self.window.mouse_drag_event_func     = self.__window_mouse_drag_event__
         self.window.mouse_scroll_event_func   = self.__window_mouse_scroll_event__
-        self.window.mouse_enter_event_func    = self.__window_mouse_enter_event__
         self.window.unicode_char_entered_func = self.__window_unicode_char_entered__
         self.window.files_dropped_event_func  = self.__window_files_dropped_event__
 
-        # Workaround: Implement file dropping for GLFW and Keys, parallel icon setting
         if (self._backend == ShaderBackend.GLFW):
-            glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)
             BrokenThread.new(target=self.window.set_icon, icon_path=Broken.PROJECT.RESOURCES.ICON)
+            glfw.set_cursor_enter_callback(self.window._window, lambda _, enter: self.__window_mouse_enter_event__(inside=enter))
+            glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)
             ShaderKeyboard.Keys.LEFT_SHIFT = glfw.KEY_LEFT_SHIFT
             ShaderKeyboard.Keys.LEFT_CTRL  = glfw.KEY_LEFT_CONTROL
             ShaderKeyboard.Keys.LEFT_ALT   = glfw.KEY_LEFT_ALT
             # glfw.maximize_window(self.window._window)
 
         log.debug(f"{self.who} Finished Window creation")
 
@@ -652,15 +621,16 @@
         scale:      Annotated[float, Option("--scale",      "-x", help="(🌵 Quality  ) Pre-multiply Width and Height by a Scale Factor")]=1.0,
         fps:        Annotated[float, Option("--fps",        "-f", help="(🌵 Basic    ) Target Frames per Second. On Realtime, defaults to Monitor framerate else 60")]=None,
         fullscreen: Annotated[bool,  Option("--fullscreen",       help="(🌵 Basic    ) Start the Real Time Window in Fullscreen Mode")]=False,
         benchmark:  Annotated[bool,  Option("--benchmark",  "-b", help="(🌵 Basic    ) Benchmark the Scene's speed on raw rendering")]=False,
         quality:    Annotated[float, Option("--quality",    "-q", help="(💎 Quality  ) Shader Quality level if supported (0-100%)")]=80,
         ssaa:       Annotated[float, Option("--ssaa",       "-s", help="(💎 Quality  ) Fractional Super Sampling Anti Aliasing factor, O(N²) GPU cost")]=1.0,
         render:     Annotated[bool,  Option("--render",     "-r", help="(📦 Exporting) Export the current Scene to a Video File defined on --output")]=False,
-        output:     Annotated[str,   Option("--output",     "-o", help="(📦 Exporting) Output File Name: Absolute, Relative Path or Plain Name. Saved on ($DATA/$(plain_name or $scene-$date))")]=None,
+        base:       Annotated[Path,  Option("--base",             help="(📦 Exporting) Output File Base Directory")]=Broken.PROJECT.DIRECTORIES.DATA,
+        output:     Annotated[str,   Option("--output",     "-o", help="(📦 Exporting) Output File Name: Absolute, Relative Path or Plain Name. Saved on ($BASE/$(plain_name or $scene-$date))")]=None,
         format:     Annotated[str,   Option("--format",           help="(📦 Exporting) Output Video Container (mp4, mkv, webm, avi..), overrides --output one")]="mp4",
         time:       Annotated[float, Option("--time-end",   "-t", help="(📦 Exporting) How many seconds to render, defaults to 10 or longest Audio")]=None,
         raw:        Annotated[bool,  Option("--raw",              help="(📦 Exporting) Send raw OpenGL Frames before GPU SSAA to FFmpeg (Enabled if SSAA < 1)")]=False,
         open:       Annotated[bool,  Option("--open",             help="(📦 Exporting) Open the Video's Output Directory after render finishes")]=False,
     ) -> Optional[Path]:
 
         self.relay(Message.Shader.ReloadShaders)
@@ -710,15 +680,15 @@
 
         # Configure FFmpeg and Popen it
         if (self.rendering):
             import arrow
 
             # Get video output path - if not absolute, save to data directory
             output = Path(output or f"({arrow.utcnow().format('YYYY-MM-DD_HH-mm-ss')}) {self.__name__}")
-            output = output if output.is_absolute() else Broken.PROJECT.DIRECTORIES.DATA/output
+            output = output if output.is_absolute() else base/output
             output = output.with_suffix(output.suffix or f".{format}")
 
             # Create FFmpeg process
             self.ffmpeg = (
                 BrokenFFmpeg()
                 .quiet()
                 .overwrite()
@@ -762,18 +732,19 @@
 
             # Don't allocate new buffer on each read
             buffer = self.opengl.buffer(
                 reserve=self._final.texture.length,
                 dynamic=True,
             )
 
-            if BrokenPlatform.OnWindows:
-                self.ffmpeg = self.ffmpeg.Popen(stdin=PIPE)
-            else:
-                self.ffmpeg = self.ffmpeg.pipe()
+            if self.exporting:
+                if BrokenPlatform.OnWindows:
+                    self.ffmpeg = self.ffmpeg.Popen(stdin=PIPE)
+                else:
+                    self.ffmpeg = self.ffmpeg.pipe()
 
             # Add progress bar
             progress_bar = tqdm.tqdm(
                 total=int(self.duration*self.fps),
                 desc=f"Scene ({type(self).__name__}) → Video",
                 dynamic_ncols=True,
                 colour="#43BFEF",
```

## ShaderFlow/Shader.py

```diff
@@ -233,16 +233,16 @@
 
         # Add pipeline variable definitions
         for variable in self._full_pipeline():
             self.common_variable(variable)
 
         try:
             self.program = self.scene.opengl.program(
-                _vertex or self.make_vertex(self._vertex),
-                _fragment or self.make_fragment(self._fragment)
+                self.make_vertex(_vertex or self._vertex),
+                self.make_fragment(_fragment or self._fragment)
             )
         except Exception as error:
             if (_vertex or _fragment):
                 raise RuntimeError(log.error("Recursion on Missing Texture Shader Loading"))
 
             log.error(f"{self.who} Error compiling shaders, loading missing texture shader")
             self.dump_shaders(error=str(error))
@@ -272,42 +272,45 @@
         if clear:
             fbo.clear()
         self.vao.render(
             moderngl.TRIANGLE_STRIP,
             instances=self.instances
         )
 
-    def render(self) -> None:
-        for index, variable in enumerate(self._full_pipeline()):
+    def use_pipeline(self, pipeline: Iterable[ShaderVariable]) -> None:
+        for index, variable in enumerate(pipeline):
             # if variable not in self.fragment_variables:
             #     self.load_shaders()
             if (variable.type == "sampler2D"):
                 self.set_uniform(variable.name, index)
                 variable.value.use(index)
                 continue
 
-            # Optimization: Final shader doesn't need the full pipeline
-            if self.texture.final:
-                continue
-
             self.set_uniform(variable.name, variable.value)
 
+    def render(self) -> None:
+
+        # Optimization: Final shader doesn't need the full pipeline
         if self.texture.final:
+            self.use_pipeline(self.scene.shader.texture.pipeline())
             self.render_fbo(self.texture.fbo(), clear=self.clear)
             return
 
+        self.use_pipeline(self._full_pipeline())
+
         for layer, container in enumerate(self.texture.matrix[0]):
             self.set_uniform("iLayer", layer)
             self.render_fbo(fbo=container.fbo, clear=container.clear)
 
         self.texture.roll()
 
     def handle(self, message: Message) -> None:
         if isinstance(message, Message.Shader.ReloadShaders):
             self.load_shaders()
+
         elif isinstance(message, Message.Shader.Render):
             self.render()
 
             # Fixme: Should this be on a proper User Interface class?
             if self.texture.final:
                 self.scene._render_ui()
```

## ShaderFlow/__init__.py

```diff
@@ -7,10 +7,8 @@
     PACKAGE=__file__,
     APP_NAME="ShaderFlow",
     APP_AUTHOR="BrokenSource",
     RESOURCES=ShaderFlowResources,
 )
 
 Broken.set_project(SHADERFLOW)
-
-# Fixme: Required optimal? Maybe once when shaders fail
 BrokenPath.resetdir(SHADERFLOW.DIRECTORIES.DUMP, echo=False)
```

## ShaderFlow/__main__.py

```diff
@@ -1,44 +1,38 @@
 import re
 import sys
 from pathlib import Path
-import time
 
 from typer import Context
 
 
 import Broken
 from Broken.Base import (
     BrokenPath,
     BrokenPlatform,
     BrokenProfiler,
     BrokenTyper,
-    apply,
 )
 from Broken.Logging import log
 from Broken.Project import BrokenApp
-from Broken.Spinner import BrokenSpinner
 from ShaderFlow import SHADERFLOW
 
 from Broken.Loaders.LoaderString import LoaderString
 
 SHADERFLOW_ABOUT = """
 🌵 Imagine ShaderToy, on a Manim-like architecture. That's ShaderFlow.\n
 • Tip: run "shaderflow (scene) --help" for More Options ✨
 
 ©️ Broken Source Software, AGPL-3.0-only License.
 """
 
 class ShaderFlowManager(BrokenApp):
     def cli(self):
         self.broken_typer = BrokenTyper(description=SHADERFLOW_ABOUT)
-        start = time.perf_counter()
-        with BrokenSpinner("Finding ShaderFlow Scenes"):
-            self.find_all_scenes()
-        log.info(f"Found ShaderFlow Scenes in {time.perf_counter() - start:.4f}s")
+        self.find_all_scenes()
         self.broken_typer(sys.argv[1:], shell=Broken.RELEASE and BrokenPlatform.OnWindows)
 
     def find_all_scenes(self) -> list[Path]:
         """Find all Scenes: Project directory and current directory"""
         direct = sys.argv[1] if (len(sys.argv) > 1) else ""
         files = set()
 
@@ -49,20 +43,20 @@
             files.update(BrokenPath(sys.argv.pop(1)).rglob("*.py"))
         else:
             files.update(SHADERFLOW.DIRECTORIES.REPOSITORY.glob("Community/**/*.py"))
             files.update(SHADERFLOW.RESOURCES.SCENES.rglob("*.py"))
             files.update(Path.cwd().glob("*.py"))
 
         # Add the files, exit if no scene was added
-        if sum(apply(self.add_scene_file, files)) == 0:
+        if sum(map(self.add_scene_file, files)) == 0:
             log.warning("No ShaderFlow Scenes found")
             exit(1)
 
     docscene = re.compile(r"^class\s+(\w+)\s*\(.*?(?:Scene).*\):\s*(?:\"\"\"((?:\n|.)*?)\"\"\")?", re.MULTILINE)
-    """Matches any class that contains "Scene" on the inheritance and its docstring"""
+    """Matches any valid Python class that contains "Scene" on the inheritance and its docstring"""
 
     def add_scene_file(self, file: Path) -> bool:
         """Add classes that inherit from Scene from a file to the CLI"""
 
         # Must be a valid path with string content
         if not (file := BrokenPath(file, valid=True)):
             return False
@@ -75,15 +69,18 @@
                 try:
                     # Note: Point of trust transfer to the file the user is running
                     exec(compile(code, file.stem, "exec"), namespace := {})
                     scene = namespace[name]
                     instance = scene()
                     instance.cli(*ctx.args)
                 finally:
-                    instance.destroy()
+                    try:
+                        instance.destroy()
+                    except Exception:
+                        pass
             return run_scene
 
         # Match all scenes and their optional docstrings
         for match in ShaderFlowManager.docscene.finditer(code):
             name, docstring = match.groups()
             self.broken_typer.command(
                 callable=partial_run(file, name, code),
```

## ShaderFlow/Modules/Audio.py

```diff
@@ -350,15 +350,15 @@
         if (self.final and self.scene.realtime):
             if (self.mode == BrokenAudioMode.File):
                 self.open_speaker()
             else:
                 self.open_recorder()
 
     def ffmpeg(self, ffmpeg: BrokenFFmpeg) -> None:
-        if self.final:
+        if self.final and BrokenPath(self.file, valid=True):
             ffmpeg.input(self.file)
 
     def update(self):
         try:
             if self._file_stream:
                 self._file_reader.chunk = self.scene.rdt
                 data = next(self._file_stream).T
```

## ShaderFlow/Modules/Bouncing.py

```diff
@@ -3,50 +3,66 @@
 from typing import Iterable
 
 import numpy
 from attr import define
 
 from Broken.Base import clamp
 from Broken.Loaders.LoaderPIL import LoadableImage, LoaderImage
-from Broken.Types import TAU
+from Broken.Types import TAU, Degrees
 from ShaderFlow.Module import ShaderModule
 from ShaderFlow.Texture import ShaderTexture
 from ShaderFlow.Variable import ShaderVariable
 
 
 @define
 class ShaderBouncing(ShaderModule):
     name: str = "iBounce"
     position: numpy.ndarray = None
     velocity: numpy.ndarray = None
     aspect_ratio: float = 1
 
     def setup(self):
-        self.position = numpy.array((
-            random.uniform(-1, 1),
-            random.uniform(-1, 1)
-        ))
-
-        self.velocity = 3*numpy.array((
-            cos(random.uniform(0, TAU)),
-            sin(random.uniform(0, TAU))
-        ))
+        self.set_velocity_polar(1, random.uniform(0, TAU))
+        self.position = numpy.array((0.0, 0.0))
 
     def update(self):
         self.position += (self.velocity * self.scene.dt)
 
         for i, limit in enumerate((self.aspect_ratio, 1)):
             if abs(self.position[i]) > limit:
                 self.velocity[i] = -self.velocity[i]
                 self.position[i] = clamp(self.position[i], -limit, limit)
 
     def pipeline(self) -> Iterable[ShaderVariable]:
         yield ShaderVariable("uniform", "vec2", f"{self.name}Position", self.position)
         yield ShaderVariable("uniform", "vec2", f"{self.name}Velocity", self.velocity)
 
+    # # Quality of Life
+
+    def set_velocity_polar(self, magnitude: float, angle: Degrees):
+        self.velocity = magnitude*numpy.array((cos(angle), sin(angle)))
+
+    @property
+    def x(self) -> float:
+        return self.position[0]
+
+    @property
+    def y(self) -> float:
+        return self.position[1]
+
+    @x.setter
+    def x(self, value: float) -> None:
+        self.position[0] = value
+
+    @y.setter
+    def y(self, value: float) -> None:
+        self.position[1] = value
+
+    # # Advanced
+
     def advanced_ratios(self, image: LoadableImage, steps: int=1000) -> ShaderTexture:
         """Get a texture of `aspect_ratio(angle)` from linspace(0, tau, steps)"""
         ratios = numpy.zeros((steps, 1), dtype=numpy.float32)
         image = numpy.array(LoaderImage(image))
         width, height, _ = image.shape
         bigger = max(width, height)
```

## ShaderFlow/Modules/Piano.py

```diff
@@ -18,214 +18,258 @@
 from Broken.Types import BPM, Seconds
 from ShaderFlow.Module import ShaderModule
 from ShaderFlow.Modules.Dynamics import DynamicNumber
 from ShaderFlow.Notes import BrokenPianoNote
 from ShaderFlow.Texture import ShaderTexture
 from ShaderFlow.Variable import ShaderVariable
 
-MAX_NOTE = 256
 MAX_CHANNELS = 32
+MAX_ROLLING = 256
+MAX_NOTE = 128
 
 @define
-class BucketInterval:
-    start: float
-    end:   float
-    data:  Any
+class ShaderPiano(ShaderModule):
+    name: str = "iPiano"
+    """Texture name prefixes for this Module"""
 
-@define
-class BucketTree:
-    trees: Dict[int, Dict[int, Deque[Any]]] = Factory(dict)
-    size: float = 5.0
+    tempo: Deque[Tuple[Seconds, BPM]] = Factory(deque)
+    """List of tempo changes at (seconds, bpm)"""
 
-    def index(self, index: int) -> int:
-        return int(index/self.size)
+    keys_texture: ShaderTexture = None
+    """Velocities texture, X is MIDI index, Y is Velocity, size (MAX_NOTE, 1)"""
 
-    def subtree(self, index: int, B: int) -> Deque[BucketInterval]:
-        return self.trees.setdefault(index, {}).setdefault(B, deque())
+    channel_texture: ShaderTexture = None
+    """Channel being played texture, X is MIDI index, Y is Channel, size (MAX_NOTE, 1)"""
 
-    def subtree_range(self, start: float, end: float) -> range:
-        return range(self.index(start) - 3, self.index(end) + 1)
+    roll_texture: ShaderTexture = None
+    """Piano roll'ling notes main texture'. The X coordinate is the MIDI index, pixels contains data
+    (start, end, channel, velocity), of each playing key on the Y. Size (MAX_ROLLING, MAX_NOTE)"""
 
-    def add(self, index: int, start: float, end: float, data: Any):
-        self.subtree(index, self.index(start)).append(BucketInterval(start, end, data))
+    time_offset: Seconds = 0
+    """Offset the notes being played search from the current time"""
 
-    def overlap(self, index: int, start: float, end: float) -> Iterable[BucketInterval]:
-        for tree in self.subtree_range(start, end):
-            for interval in self.subtree(index, tree):
-                if interval.end >= start and interval.start <= end:
-                    yield interval
+    roll_time: Seconds = 1.5
+    """How long the notes roll for"""
 
-    def at(self, index: int, time: float) -> Iterable[BucketInterval]:
-        for interval in self.subtree(index, self.index(time)):
-            if interval.start <= time <= interval.end:
-                yield interval
+    height: float = 0.275
+    """Height of the piano in the shader (0-1)"""
 
-    def __iter__(self) -> Iterable[BucketInterval]:
-        for tree in self.trees.values():
-            for intervals in tree.values():
-                yield from intervals
+    black_ratio: float = 0.6
+    """How long are black keys compared to white keys"""
 
-    def start(self) -> float:
-        return min(interval.start for interval in self)
+    global_minimum_note: int = MAX_NOTE
+    """The lowest note in the loaded notes"""
 
-    def end(self) -> float:
-        return max(interval.end for interval in self)
+    global_maximum_note: int = 0
+    """The highest note in the loaded notes"""
 
-# -------------------------------------------------------------------------------------------------|
+    extra_side_keys: int = 6
+    """Display the dynamic range plus this many keys on each side"""
 
-@define(slots=False)
-class BrokenPiano:
-    tree: BucketTree = Factory(BucketTree)
-    tempo: Deque[Tuple[Seconds, BPM]] = Factory(deque)
-    global_minimum_note: int = None
-    global_maximum_note: int = None
+    note_range_ahead: Seconds = 2
+    """Lookup notes in (roll_time + this) for setting the dynamic ranges"""
 
-    # # Base actions
+    key_press_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(
+        value=numpy.zeros(MAX_NOTE, numpy.float32),
+        frequency=4, zeta=0.4, response=0, precision=0
+    ))
 
-    def add_note(self, note: BrokenPianoNote):
-        self.global_minimum_note = min(self.global_minimum_note or MAX_NOTE, note.note)
-        self.global_maximum_note = max(self.global_maximum_note or        0, note.note)
-        self.tree.add(note.note, note.start, note.end, note)
+    note_range_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(
+        value=numpy.zeros(2, numpy.float32),
+        frequency=0.05, zeta=1/(2**0.5), response=0,
+    ))
 
-    def clear(self):
-        self.tree = BucketTree()
+    tree: Dict[int, Dict[int, Deque[BrokenPianoNote]]] = Factory(dict)
+    """Internal data structure for storing the notes"""
 
-    def notes_between(self, index: int, start: Seconds, end: Seconds) -> Iterable[BrokenPianoNote]:
-        for interval in self.tree.overlap(index, start, end):
-            yield interval.data
+    # # Internal
 
-    def notes_at(self, index: int, time: Seconds) -> Iterable[BrokenPianoNote]:
-        for interval in self.tree.at(index, time):
-            yield interval.data
-
-    def tempo_at(self, time: Seconds) -> Optional[BPM]:
-        for when, tempo in self.tempo:
-            if when <= time:
-                return tempo
+    def __post__(self):
+        self.keys_texture    = ShaderTexture(scene=self.scene, name=f"{self.name}Keys").from_numpy(self._empty_keys())
+        self.channel_texture = ShaderTexture(scene=self.scene, name=f"{self.name}Chan").from_numpy(self._empty_keys())
+        self.roll_texture    = ShaderTexture(scene=self.scene, name=f"{self.name}Roll").from_numpy(self._empty_roll())
+        self.tempo_texture   = ShaderTexture(scene=self.scene, name=f"{self.name}Tempo").from_numpy(numpy.zeros((100, 1, 2), numpy.float32))
 
-    @property
-    def notes(self) -> Iterable[BrokenPianoNote]:
-        for interval in self.tree:
-            yield interval.data
+    def _empty_keys(self) -> numpy.ndarray:
+        return numpy.zeros((MAX_NOTE, 1), numpy.float32)
 
-    @property
-    def duration(self) -> Seconds:
-        return self.tree.end()
+    def _empty_roll(self) -> numpy.ndarray:
+        return numpy.zeros((MAX_NOTE, MAX_ROLLING, 4), numpy.float32)
 
-    @property
-    def end(self) -> Seconds:
-        return self.tree.end()
+    # # Data structure
+
+    @staticmethod
+    def _ranges(start: Seconds, end: Seconds) -> Iterable[int]:
+        return range(int(start), int(end)+1)
 
-    @end.setter
-    def end(self, value: Seconds):
-        self.force_interval(start=self.start, end=value)
+    def clear(self):
+        self.tree.clear()
+
+    def add_note(self, note: Optional[BrokenPianoNote]) -> None:
+        if note is None:
+            return
+        for index in self._ranges(note.start, note.end):
+            self.tree.setdefault(note.note, dict()).setdefault(index, deque()).append(note)
+        self.update_global_ranges(note.note)
 
     @property
-    def start(self) -> Seconds:
-        return self.tree.begin()
+    def notes(self) -> Iterable[BrokenPianoNote]:
+        for block in self.tree.values():
+            for notes in block.values():
+                yield from notes
+
+    def __iter__(self) -> Iterable[BrokenPianoNote]:
+        return self.notes
 
-    @start.setter
-    def start(self, value: Seconds):
-        self.force_interval(start=value, end=self.end)
-
-    # def force_interval(self, start: Seconds, end: Seconds):
-    #     tree  = BucketTree()
-    #     ratio = ((end + start)/self.tree.end())
-    #     off   = self.tree.begin()
-    #     for interval in self.tree:
-    #         s, e = ((interval.begin-off)*ratio-start, (interval.end - off)*ratio - start)
-    #         tree.add(interval.data, s, e, note)
-    #     self.tree = tree
+    def notes_between(self, index: int, start: Seconds, end: Seconds) -> Iterable[BrokenPianoNote]:
+        exists = set()
+        for other in self._ranges(start, end):
+            for note in self.tree.get(index, dict()).get(other, deque()):
+                if (note.start > end):
+                    continue
+                if (id(note) in exists):
+                    continue
+                exists.add(id(note))
+                yield note
+
+    def update_global_ranges(self, note: int) -> None:
+        self.global_minimum_note = min(self.global_minimum_note, note)
+        self.global_maximum_note = max(self.global_maximum_note, note)
 
     @property
-    def note_range(self) -> range:
-        return range(self.global_minimum_note, self.global_maximum_note)
+    def maximum_velocity(self) -> Optional[int]:
+        return max((note.velocity for note in self.notes), default=None)
 
-    # # Initialization
+    @property
+    def minimum_velocity(self) -> Optional[int]:
+        return min((note.velocity for note in self.notes), default=None)
 
-    @classmethod
-    def from_midi(cls, path: Path):
-        return cls().load_midi(path)
+    def normalize_velocities(self, minimum: int=100, maximum: int=100) -> None:
+        ma, mi = (self.maximum_velocity, self.minimum_velocity)
 
-    # # Utilities
+        # Safe against (minimum-maximum=0)
+        def new(velocity: int) -> int:
+            if (ma==mi): return (maximum+minimum)//2
+            return int((velocity-mi)/(ma-mi)*(maximum-minimum)+minimum)
+
+        for note in self.notes:
+            note.velocity = new(note.velocity)
 
     def load_midi(self, path: Path):
         import pretty_midi
 
         if not (path := BrokenPath(path)).exists():
             log.warning(f"{self.who} Input Midi file not found ({path})")
             return
 
-        self.clear()
-
         with BrokenSpinner(log.info(f"Loading Midi file at ({path})")):
             midi = pretty_midi.PrettyMIDI(str(path))
             for channel, instrument in enumerate(midi.instruments):
                 if instrument.is_drum:
                     pass
                 for note in instrument.notes:
                     self.add_note(BrokenPianoNote(
                         note=note.pitch,
                         start=note.start,
                         end=note.end,
                         channel=channel,
                         velocity=note.velocity,
                     ))
-
             # Add tempo changes
             for when, tempo in zip(*midi.get_tempo_changes()):
                 self.tempo.append((when, tempo))
 
-    @property
-    def minimum_velocity(self) -> int:
-        return min(note.velocity for note in self.notes)
+        self.tempo_texture.clear()
 
-    @property
-    def maximum_velocity(self) -> int:
-        return max(note.velocity for note in self.notes)
+        for offset, (when, tempo) in enumerate(self.tempo):
+            self.tempo_texture.write(data=struct.pack("ff", when, tempo), viewport=(0, offset, 1, 1))
 
-    def normalize_velocities(self, minimum: int=60, maximum: int=100):
-        mi, ma = (self.minimum_velocity, self.maximum_velocity)
+    # # Core Logic
 
-        # Safe against (minimum-maximum)=0
-        def new(velocity: int) -> int:
-            if ma == mi: return (maximum+minimum)//2
-            return int((velocity-mi)/(ma-mi)*(maximum-minimum)+minimum)
+    # A (MAX_MIDI Notes x MAX_CHANNELS Channels) matrix of the end-most note being played
+    _playing_matrix: List[List[Optional[BrokenPianoNote]]] = Factory(lambda: [[None]*MAX_CHANNELS for _ in range(MAX_NOTE)])
 
-        for note in self.notes:
-            note.velocity = new(note.velocity)
+    def update(self):
 
-    def __iter__(self) -> Iterable[BrokenPianoNote]:
-        yield from self.tree
+        # Utilities and trackers
+        time     = (self.scene.time + self.time_offset)
+        lookup   = (self.roll_time + self.note_range_ahead)
+        upcoming = set()
 
-# -------------------------------------------------------------------------------------------------|
+        # # Get and update pressed keys
+        self.key_press_dynamics.target.fill(0)
+        roll = self._empty_roll()
 
-@define
-class ShaderPiano(BrokenPiano, ShaderModule):
-    name: str = "iPiano"
-    keys_texture: ShaderTexture = None
-    roll_texture: ShaderTexture = None
-    channel_texture: ShaderTexture = None
-    roll_time: Seconds = 2
-    height: float = 0.275
-    black_ratio: float = 0.6
-    minimum_visible: int = 12*3
-    roll_note_limit: int = 256
-    extra_side_keys: int = 6
-    time_offset: Seconds = 0
-    time_scale: float = 1
-    dynamic_note_ahead: float = 4
+        # Channel '-1' means the note is not being played !
+        channels = (self._empty_keys() - 1)
 
-    key_press_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(
-        value=numpy.zeros(MAX_NOTE, numpy.float32), frequency=4, zeta=0.4, response=0, precision=0
-    ))
+        # No need to check for the entire range 😉
+        for midi in range(self.global_minimum_note, self.global_maximum_note+1):
+            simultaneous = 0
 
-    note_range_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(
-        value=numpy.zeros(2, numpy.float32), frequency=0.05, zeta=1/(2**0.5), response=0,
-    ))
+            for note in self.notes_between(midi, time, time+lookup):
+                upcoming.add(midi)
+
+                # This note is being played
+                if (playing := (note.start <= time <= note.end)):
+                    self.key_press_dynamics.target[midi] = note.velocity
+                    channels[midi] = note.channel
+
+                # Build a 2D Grid of the piano keys being played
+                # • Coordinate: (Note, #offset) @ (Start, End, Channel, Velocity)
+                if (simultaneous < MAX_ROLLING):
+                    roll[note.note, simultaneous] = (note.start, note.end, note.channel, note.velocity)
+                    simultaneous += 1
+
+                # Real time play notes condition
+                if self.scene.rendering: continue
+                if not self.fluidsynth:  continue
+                if not playing: continue
+
+                # Find empty slots or notes that will end soon, replace and play
+                other = self._playing_matrix[midi][note.channel]
+                if (other is None) or (other.end > note.end):
+                    self.fluid_key_down(midi, note.velocity, note.channel)
+                    self._playing_matrix[midi][note.channel] = note
+
+            # Find notes that are not being played
+            for channel in range(MAX_CHANNELS if self.scene.realtime else 0):
+                if (other := self._playing_matrix[midi][channel]) and (other.end < time):
+                    self._playing_matrix[midi][channel] = None
+                    self.fluid_key_up(midi, other.channel)
+
+        # Dynamic zoom velocity based on future lookup
+        self.note_range_dynamics.frequency = 0.5/lookup
+
+        # Set dynamic note range to the globals on the start
+        if sum(self.note_range_dynamics.value) == 0:
+            self.note_range_dynamics.value[:] = (self.global_minimum_note, self.global_maximum_note)
+
+        # Set new targets for dynamic keys
+        self.note_range_dynamics.target[:] = (
+            min(upcoming, default=self.global_minimum_note),
+            max(upcoming, default=self.global_maximum_note)
+        )
+
+        # Write to keys textures
+        self.note_range_dynamics.next(dt=abs(self.scene.dt))
+        self.key_press_dynamics.next(dt=abs(self.scene.dt))
+        self.keys_texture.write(data=self.key_press_dynamics.value)
+        self.roll_texture.write(data=roll)
+        self.channel_texture.write(data=channels)
+
+    def pipeline(self) -> Iterable[ShaderVariable]:
+        yield ShaderVariable("uniform", "int",   f"{self.name}GlobalMin",  self.global_minimum_note)
+        yield ShaderVariable("uniform", "int",   f"{self.name}GlobalMax",  self.global_maximum_note)
+        yield ShaderVariable("uniform", "vec2",  f"{self.name}Dynamic",    self.note_range_dynamics.value)
+        yield ShaderVariable("uniform", "float", f"{self.name}RollTime",   self.roll_time)
+        yield ShaderVariable("uniform", "float", f"{self.name}Extra",      self.extra_side_keys)
+        yield ShaderVariable("uniform", "float", f"{self.name}Height",     self.height)
+        yield ShaderVariable("uniform", "int",   f"{self.name}Limit",      MAX_ROLLING)
+        yield ShaderVariable("uniform", "float", f"{self.name}BlackRatio", self.black_ratio)
 
     # # Fluidsynth
 
     fluidsynth: Any = None
     soundfont:  Any = None
 
     def fluid_load(self, sf2: Path, driver: str=("pulseaudio" if BrokenPlatform.OnLinux else None)) -> None:
@@ -295,121 +339,8 @@
                 .input(output)
                 .custom("-filter:a", "loudnorm")
                 .custom("-c:a", FFmpegAudioCodec.AAC)
                 .custom("-b:a", "300k")
                 .output(normalized)
             ).run()
 
-        return BrokenPath(normalized)
-
-    # # Piano roll
-
-    def _empty_keys(self) -> numpy.ndarray:
-        return numpy.zeros((MAX_NOTE, 1), numpy.float32)
-
-    def _empty_roll(self) -> numpy.ndarray:
-        return numpy.zeros((MAX_NOTE, self.roll_note_limit, 4), numpy.float32)
-
-    def __post__(self):
-        self.keys_texture    = ShaderTexture(scene=self.scene, name=f"{self.name}Keys").from_numpy(self._empty_keys())
-        self.channel_texture = ShaderTexture(scene=self.scene, name=f"{self.name}Chan").from_numpy(self._empty_keys())
-        self.roll_texture    = ShaderTexture(scene=self.scene, name=f"{self.name}Roll").from_numpy(self._empty_roll())
-        self.tempo_texture   = ShaderTexture(scene=self.scene, name=f"{self.name}Tempo").from_numpy(numpy.zeros((100, 1, 2), numpy.float32))
-        self.tree.size       = self.roll_time
-
-    def load_midi(self, path: Path):
-        super().load_midi(path=path)
-
-        self.tempo_texture.clear()
-        for offset, (when, tempo) in enumerate(self.tempo):
-            self.tempo_texture.write(data=struct.pack("ff", when, tempo), viewport=(0, offset, 1, 1))
-
-    # A (MAX_MIDI Notes x MAX_CHANNELS Channels) matrix of the end-most note being played
-    _playing_matrix: List[List[Optional[BrokenPianoNote]]] = Factory(lambda: [[None]*MAX_CHANNELS for _ in range(MAX_NOTE)])
-
-    def update(self):
-
-        # Utilities and trackers
-        time        = (self.scene.time - self.time_offset)
-        lookup      = self.roll_time + self.dynamic_note_ahead
-        upcoming    = set()
-
-        def in_range(note: BrokenPianoNote, end: Seconds) -> bool:
-            return (note.end+time>=time) and (note.start<=end+time)
-
-        def time_travel(cond: bool) -> bool:
-            return cond if (self.time_scale > 0) else (not cond)
-
-        # # Get and update pressed keys
-        self.key_press_dynamics.target.fill(0)
-        roll = self._empty_roll()
-
-        # Channel '-1' means the note is not being played !
-        self.channel_texture.write(self._empty_keys() - 1)
-
-        # No need to check for the entire range 😉
-        for midi in range(self.global_minimum_note, self.global_maximum_note):
-            matrix_row = self._playing_matrix[midi]
-            simultaneous = 0
-
-            for note in self.notes_between(midi, time, time+lookup):
-                upcoming.add(midi)
-
-                # This note is being played
-                if in_range(note, self.scene.frametime):
-                    self.key_press_dynamics.target[midi] = note.velocity
-                    self.channel_texture.write(
-                        data=numpy.array(note.channel, dtype="f4"),
-                        viewport=(midi, 0, 1, 1)
-                    )
-
-                # Build a 2D Grid of the piano keys being played
-                # • Coordinate: (Note, #offset) @ (Start, End, Channel, Velocity)
-                if (simultaneous<self.roll_note_limit) and in_range(note, self.roll_time):
-                    roll[note.note, simultaneous] = (note.start, note.end, note.channel, note.velocity)
-                    simultaneous += 1
-
-                # Real time play notes condition
-                if self.scene.rendering: continue
-                if not self.fluidsynth:  continue
-                if not in_range(note, self.scene.frametime): continue
-
-                # Find empty slots or notes that will end soon, replace and play
-                other = matrix_row[note.channel]
-                if (other is None) or time_travel(other.end > note.end):
-                    self.fluid_key_down(midi, note.velocity, note.channel)
-                    matrix_row[note.channel] = note
-
-            # Find notes that are not being played
-            for channel in range(MAX_CHANNELS if self.scene.realtime else 0):
-                if (other := matrix_row[channel]) and time_travel(other.end < time):
-                    self.fluid_key_up(midi, other.channel)
-                    matrix_row[channel] = None
-
-        # The viewport should be present whenever the 'ahead' found keys
-        self.note_range_dynamics.frequency = 1/lookup
-
-        # Set dynamic note range to the globals on the start
-        if sum(self.note_range_dynamics.value) == 0:
-            self.note_range_dynamics.value[:] = (self.global_minimum_note, self.global_maximum_note)
-
-        # Set new targets for dynamic keys
-        self.note_range_dynamics.target = numpy.array([
-            min(upcoming, default=self.global_minimum_note),
-            max(upcoming, default=self.global_maximum_note)
-        ], numpy.float32)
-
-        # Write to keys textures
-        self.note_range_dynamics.next(dt=abs(self.scene.dt))
-        self.key_press_dynamics.next(dt=abs(self.scene.dt))
-        self.keys_texture.write(data=self.key_press_dynamics.value)
-        self.roll_texture.write(roll)
-
-    def pipeline(self) -> Iterable[ShaderVariable]:
-        yield ShaderVariable("uniform", "int",   f"{self.name}GlobalMin",  self.global_minimum_note)
-        yield ShaderVariable("uniform", "int",   f"{self.name}GlobalMax",  self.global_maximum_note)
-        yield ShaderVariable("uniform", "vec2",  f"{self.name}Dynamic",    self.note_range_dynamics.value)
-        yield ShaderVariable("uniform", "float", f"{self.name}RollTime",   self.roll_time)
-        yield ShaderVariable("uniform", "float", f"{self.name}Extra",      self.extra_side_keys)
-        yield ShaderVariable("uniform", "float", f"{self.name}Height",     self.height)
-        yield ShaderVariable("uniform", "int",   f"{self.name}Limit",      self.roll_note_limit)
-        yield ShaderVariable("uniform", "float", f"{self.name}BlackRatio", self.black_ratio)
+        return BrokenPath(normalized)
```

## ShaderFlow/Modules/Video.py

```diff
@@ -57,15 +57,15 @@
         self._fps = BrokenFFmpeg.get_framerate(self.path)
         self._width, self._height = BrokenFFmpeg.get_resolution(self.path)
 
         if not all((self._fps, self._width, self._height)):
             raise ValueError("Could not get video metadata")
 
         # TurboJPEG will raise if shared lib is not found
-        with contextlib.suppress(RuntimeError):
+        with contextlib.suppress(RuntimeError, ModuleNotFoundError):
             import turbojpeg
             self._turbo = turbojpeg.TurboJPEG()
 
         if self.lossless:
             log.warning("Using lossless frames. Limiting buffer length for Out of Memory safety")
             self.buffer = min(self.buffer, BrokenSmartVideoFrames.LOSSLESS_MAX_BUFFER_LENGTH)
             self.encode = lambda frame: frame
```

## ShaderFlow/Modules/__init__.py

```diff
@@ -1,19 +0,0 @@
-00000000: 6672 6f6d 202e 2e20 696d 706f 7274 202a  from .. import *
-00000010: 0a0a 2320 6973 6f72 743a 206f 6666 0a66  ..# isort: off.f
-00000020: 726f 6d20 2e4b 6579 626f 6172 6420 2020  rom .Keyboard   
-00000030: 2069 6d70 6f72 7420 2a0a 6672 6f6d 202e   import *.from .
-00000040: 4479 6e61 6d69 6373 2020 2020 696d 706f  Dynamics    impo
-00000050: 7274 202a 0a66 726f 6d20 2e43 616d 6572  rt *.from .Camer
-00000060: 6120 2020 2020 2069 6d70 6f72 7420 2a0a  a      import *.
-00000070: 6672 6f6d 202e 4e6f 6973 6520 2020 2020  from .Noise     
-00000080: 2020 696d 706f 7274 202a 0a66 726f 6d20    import *.from 
-00000090: 2e41 7564 696f 2020 2020 2020 2069 6d70  .Audio       imp
-000000a0: 6f72 7420 2a0a 6672 6f6d 202e 5370 6563  ort *.from .Spec
-000000b0: 7472 6f67 7261 6d20 696d 706f 7274 202a  trogram import *
-000000c0: 0a66 726f 6d20 2e46 7261 6d65 7469 6d65  .from .Frametime
-000000d0: 7220 2069 6d70 6f72 7420 2a0a 6672 6f6d  r  import *.from
-000000e0: 202e 5069 616e 6f20 2020 2020 2020 696d   .Piano       im
-000000f0: 706f 7274 202a 0a66 726f 6d20 2e56 6964  port *.from .Vid
-00000100: 656f 2020 2020 2020 2069 6d70 6f72 7420  eo       import 
-00000110: 2a0a 6672 6f6d 202e 5761 7665 666f 726d  *.from .Waveform
-00000120: 2020 2020 696d 706f 7274 202a                import *
```

## Comparing `broken_source-0.1.2.dist-info/METADATA` & `broken_source-0.1.3.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 Metadata-Version: 2.3
 Name: broken-source
-Version: 0.1.2
+Version: 0.1.3
 Summary: Broken Source Software Framework
 Project-URL: repository, https://github.com/BrokenSource/BrokenSource
 Project-URL: homepage, https://brokensrc.dev
 Project-URL: documentation, https://brokensrc.dev
 Project-URL: issues, https://brokensrc.dev/contact
 Author-email: Tremeschin <29046864+Tremeschin@users.noreply.github.com>
+License-Expression: AGPL-3.0
 Requires-Python: >=3.10
 Requires-Dist: appdirs>=1.4.4
 Requires-Dist: arrow>=1.3.0
 Requires-Dist: attrs>=23.2.0
 Requires-Dist: audioread>=3.0.1
 Requires-Dist: cachetools>=5.3.3
 Requires-Dist: cattrs>=23.2.3
@@ -18,28 +19,30 @@
 Requires-Dist: distro>=1.9.0
 Requires-Dist: dotmap>=1.3.30
 Requires-Dist: glcontext>=2.5.0
 Requires-Dist: glfw>=2.7.0
 Requires-Dist: imgui>=2.0.0
 Requires-Dist: intervaltree>=3.1.0
 Requires-Dist: midi2audio>=0.1.1
+Requires-Dist: mido>=1.3.2
 Requires-Dist: moderngl-window>=2.4.6
 Requires-Dist: moderngl>=5.10.0
 Requires-Dist: numpy-quaternion>=2023.0.3
 Requires-Dist: numpy>=1.26.3
 Requires-Dist: opencv-contrib-python>=4.9.0.80
 Requires-Dist: opensimplex>=0.4.5
 Requires-Dist: pillow==10.2.0
 Requires-Dist: pip>=24.0
 Requires-Dist: pretty-errors>=1.2.25
 Requires-Dist: pretty-midi>=0.2.10
 Requires-Dist: pyfiglet>=1.0.2
 Requires-Dist: pyfluidsynth>=1.3.3
 Requires-Dist: pygame>=2.5.2
 Requires-Dist: python-dotenv>=1.0.1
+Requires-Dist: python-rtmidi>=1.5.8
 Requires-Dist: pyturbojpeg>=1.7.3
 Requires-Dist: pyyaml>=6.0.1
 Requires-Dist: requests-cache>=1.2.0
 Requires-Dist: requests>=2.28.1
 Requires-Dist: rich>=13.7.1
 Requires-Dist: samplerate>=0.2.1
 Requires-Dist: schedule>=1.2.1
```

### html2text {}

```diff
@@ -1,32 +1,34 @@
-Metadata-Version: 2.3 Name: broken-source Version: 0.1.2 Summary: Broken Source
+Metadata-Version: 2.3 Name: broken-source Version: 0.1.3 Summary: Broken Source
 Software Framework Project-URL: repository, https://github.com/BrokenSource/
 BrokenSource Project-URL: homepage, https://brokensrc.dev Project-URL:
 documentation, https://brokensrc.dev Project-URL: issues, https://
 brokensrc.dev/contact Author-email: Tremeschin
-<29046864+Tremeschin@users.noreply.github.com> Requires-Python: >=3.10
-Requires-Dist: appdirs>=1.4.4 Requires-Dist: arrow>=1.3.0 Requires-Dist:
-attrs>=23.2.0 Requires-Dist: audioread>=3.0.1 Requires-Dist: cachetools>=5.3.3
-Requires-Dist: cattrs>=23.2.3 Requires-Dist: datetime>=5.5 Requires-Dist:
-distro>=1.9.0 Requires-Dist: dotmap>=1.3.30 Requires-Dist: glcontext>=2.5.0
-Requires-Dist: glfw>=2.7.0 Requires-Dist: imgui>=2.0.0 Requires-Dist:
-intervaltree>=3.1.0 Requires-Dist: midi2audio>=0.1.1 Requires-Dist: moderngl-
+<29046864+Tremeschin@users.noreply.github.com> License-Expression: AGPL-3.0
+Requires-Python: >=3.10 Requires-Dist: appdirs>=1.4.4 Requires-Dist:
+arrow>=1.3.0 Requires-Dist: attrs>=23.2.0 Requires-Dist: audioread>=3.0.1
+Requires-Dist: cachetools>=5.3.3 Requires-Dist: cattrs>=23.2.3 Requires-Dist:
+datetime>=5.5 Requires-Dist: distro>=1.9.0 Requires-Dist: dotmap>=1.3.30
+Requires-Dist: glcontext>=2.5.0 Requires-Dist: glfw>=2.7.0 Requires-Dist:
+imgui>=2.0.0 Requires-Dist: intervaltree>=3.1.0 Requires-Dist:
+midi2audio>=0.1.1 Requires-Dist: mido>=1.3.2 Requires-Dist: moderngl-
 window>=2.4.6 Requires-Dist: moderngl>=5.10.0 Requires-Dist: numpy-
 quaternion>=2023.0.3 Requires-Dist: numpy>=1.26.3 Requires-Dist: opencv-
 contrib-python>=4.9.0.80 Requires-Dist: opensimplex>=0.4.5 Requires-Dist:
 pillow==10.2.0 Requires-Dist: pip>=24.0 Requires-Dist: pretty-errors>=1.2.25
 Requires-Dist: pretty-midi>=0.2.10 Requires-Dist: pyfiglet>=1.0.2 Requires-
 Dist: pyfluidsynth>=1.3.3 Requires-Dist: pygame>=2.5.2 Requires-Dist: python-
-dotenv>=1.0.1 Requires-Dist: pyturbojpeg>=1.7.3 Requires-Dist: pyyaml>=6.0.1
-Requires-Dist: requests-cache>=1.2.0 Requires-Dist: requests>=2.28.1 Requires-
-Dist: rich>=13.7.1 Requires-Dist: samplerate>=0.2.1 Requires-Dist:
-schedule>=1.2.1 Requires-Dist: scipy>=1.12.0 Requires-Dist: soundcard>=0.4.3
-Requires-Dist: thefuzz>=0.22.1 Requires-Dist: toml>=0.10.2 Requires-Dist:
-tqdm>=4.64.1 Requires-Dist: typer>=0.10.0 Requires-Dist: validators>=0.24.0
-Requires-Dist: watchdog>=4.0.0 Description-Content-Type: text/markdown
+dotenv>=1.0.1 Requires-Dist: python-rtmidi>=1.5.8 Requires-Dist:
+pyturbojpeg>=1.7.3 Requires-Dist: pyyaml>=6.0.1 Requires-Dist: requests-
+cache>=1.2.0 Requires-Dist: requests>=2.28.1 Requires-Dist: rich>=13.7.1
+Requires-Dist: samplerate>=0.2.1 Requires-Dist: schedule>=1.2.1 Requires-Dist:
+scipy>=1.12.0 Requires-Dist: soundcard>=0.4.3 Requires-Dist: thefuzz>=0.22.1
+Requires-Dist: toml>=0.10.2 Requires-Dist: tqdm>=4.64.1 Requires-Dist:
+typer>=0.10.0 Requires-Dist: validators>=0.24.0 Requires-Dist: watchdog>=4.0.0
+Description-Content-Type: text/markdown
   _[_h_t_t_p_s_:_/_/_r_a_w_._g_i_t_h_u_b_u_s_e_r_c_o_n_t_e_n_t_._c_o_m_/_B_r_o_k_e_n_S_o_u_r_c_e_/_B_r_o_k_e_n_S_o_u_r_c_e_/_M_a_s_t_e_r_/_B_r_o_k_e_n_/
                          _R_e_s_o_u_r_c_e_s_/_I_m_a_g_e_s_/_B_r_o_k_e_n_._p_n_g_]
                       ********** BBrrookkeenn SSoouurrccee SSooffttwwaarree **********
 
     Here lies BBrrookkeenn: The SShhaarreedd LLiibbrraarryy and MMaannaaggeerr + SSuubbmmoodduulleess of all my
                                    PPrroojjeeccttss
```

## Comparing `broken_source-0.1.2.dist-info/RECORD` & `broken_source-0.1.3.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-Broken/Base.py,sha256=PwgZbassTSWt7ELXOp7grCGNExUYncNAQTb2MZn4VTE,61393
+Broken/Base.py,sha256=V9KsoObvT72cEyAWYbZSQMjuMHssEQCT32kNFk4yKWo,61304
 Broken/Dotmap.py,sha256=5ZAgSo2nv0lE33r14i-j4Bb_iVFzRHWpllR9bNzGUEw,8139
 Broken/Logging.py,sha256=rxVXHDQFdBKYKwhv9UBd8ehIFq9rxV08tx62lEsLymM,6363
-Broken/Project.py,sha256=dTU7cRHr7ir7rCeIGpSNBDwFMIbwc7n73_qm7-I2kWE,14924
+Broken/Project.py,sha256=on9OzegxJcfy00jxktBO5kfen--i8CFUZEDyqS8R20A,14839
 Broken/Spinner.py,sha256=J9bX0PBQ_myn55h8a_TNnCYz97AbQ3h43XU_cdDS7Z4,2221
 Broken/Types.py,sha256=GZiW_njBuTIM_UYx7yrLG5_SJaZupyW6KFPvCZWJ9Ls,1395
-Broken/__init__.py,sha256=9CHame_-L8anAGlUJjrX6EjJvoQSGErHzEFMnIHhlL0,3666
-Broken/__main__.py,sha256=VPLpYBzXJFsMkEazbvCD6yKjb8RhhsjFu3ubWMOQtb4,29382
+Broken/__init__.py,sha256=-cXW7nlCVSNCzFosWOsk1bXqONl_CjtCCbMXMygrNow,3983
+Broken/__main__.py,sha256=PJSGcON9fXSd5JMrzKa50NJQ6U6QNpjXSa1hZC6fUtE,29393
 Broken/BrokenEnum/Readme.md,sha256=86oajJkRmzWKoC_2eTEEc1fXMJ8-QOfrUDIzAHqkujQ,1983
 Broken/BrokenEnum/__init__.py,sha256=gw-wbYTgKPyQdh57riiPUb63ZR1zZ8FhLC3q_lSyk7g,9815
 Broken/BrokenEnum/__test__.py,sha256=9wMz89O0FSrKUaSgF24r39ReKNqPXN0Eey4bM9qzPvo,3815
 Broken/Externals/__init__.py,sha256=OZQHtHaBYL-u0mDfTJFwMY3_NDNhzQl0gpOXKcn8fX4,276
 Broken/Externals/FFmpeg/Readme.md,sha256=8ejqL6Ca5P9UNIGUuD7DMELdmJ9JepavQ_RYU-6ZdQI,1480
 Broken/Externals/FFmpeg/__init__.py,sha256=BhI3BUlUJgfU82unXecshyMQn7IvzX-lVKZaKbXaw4M,45735
 Broken/Externals/Upscaler/__init__.py,sha256=amnD0zakvjj8mmeRAHsriNUPC2MmEc4I-xtPZqBYoGI,4964
 Broken/Externals/Upscaler/ncnn.py,sha256=Y8dFz-ywLBbG7iGKfd9it_5Pk6P5dbk-1lTj-8ort8c,5221
-Broken/Loaders/LoaderBytes.py,sha256=xvgCJM7MMcFuh5-kJo18sjz8aIUmye2XLLs4SMvZfzI,618
-Broken/Loaders/LoaderPIL.py,sha256=wErnSxfelkOfVrt3xdvvo5XHlzKRN2Fik6ARyUxlDSo,1601
-Broken/Loaders/LoaderString.py,sha256=V5c-JrkjOrmg2mF-RzZwX5x9BK4gFIexViuxsBkhA2I,648
+Broken/Loaders/LoaderBytes.py,sha256=m_1_ZRLbsrYIdauMNE26TiGd5Lj93V7PsvY49jgb5HY,811
+Broken/Loaders/LoaderPIL.py,sha256=7O26XiKwE2ukS_mP59ciQ4sDIKaNbNJ8D1cl_pBixvk,1910
+Broken/Loaders/LoaderString.py,sha256=HOo9n2n0oB9ARRQsrfrVRBwaPC6fYwG41rLa7X1MsVI,852
 Broken/Loaders/__init__.py,sha256=SOWCiS2vpyNHFvXrD_qjyrtwjvTNQsSyPWIVXvvxZRI,344
 Broken/Resources/Fonts/DejaVu License.txt,sha256=ow8kZqlc0erv9gQWkvQ0ae3MoFLQAuh3AVqBnG4xwZQ,4765
 Broken/Resources/Fonts/DejaVuSans.ttf,sha256=faGVp0xVvvmI0NSPlQi9XYSUJcF3Dbpde_xs6e2EiVQ,757076
 Broken/Resources/Images/Broken.ico,sha256=Geb0VBYO_QIKhbWCqiG58LYo_6mVa1Yq-XjPI8NodL8,8764
 Broken/Resources/Images/Broken.png,sha256=9zBkD7_ZiWnTXXFXLqmIpnS0qfb_5C3dh-3PZ2Kn4uQ,15418
 Broken/Resources/Images/Broken.svg,sha256=dxfZZVKPutJOriOfGtjnaF8mCQkGu8K1oHM1zF-8DDE,1444
 Broken/Staging/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
@@ -29,51 +29,51 @@
 Broken/Staging/Dotmap/BrokenDotmap.py,sha256=PDYmq1qojJMc71Y7Gf8LPlPTN4ZOqIuAW88vd-piDJQ,12082
 Broken/Staging/Dotmap/Readme.md,sha256=vnlwmb2qAeivLvsh3weieTyf4HgGbUoGxmeQgPLGkLc,368
 Broken/Staging/Dotmap/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 Broken/Staging/Dotmap/__test__.py,sha256=Hg-kTzP8AvGt_mCg241Uz5cbOtXnTebuLb7cl594U5Y,3568
 Broken/Staging/Dotmap/Loaders/LoaderPIL.py,sha256=X1U6O2v0sx6Wcqd-vbudWh-h-y2lqCwdCx_a-AoHsJ8,1467
 Broken/Staging/Dotmap/Loaders/LoaderTOML.py,sha256=VvruuBpPEXKgWnkiRlmW6JPxBsb0Ni0fJQ6lyopaOlc,1263
 Broken/Staging/Dotmap/Loaders/__init__.py,sha256=wcJEGoWRpwKIgSR4sEwyrjk-LQ9jIKYXDJ3CZxwDagg,68
-DepthFlow/DepthFlow.py,sha256=NtyEDzAmyRgMYs16iQaefQP4faSJhAl5yUk3q_xtSpE,7207
+DepthFlow/DepthFlow.py,sha256=6AdySEHDSm3bUmD32GzUuWN2xUTsXTPIZdvoVoQOKcg,9545
 DepthFlow/__init__.py,sha256=9DEp3wDXKhx7FdpSyqnFfaa8L8hQTssrqYBpApGlgZI,356
 DepthFlow/__main__.py,sha256=K0Sg8hwj4oXg79dJfjfC-2gmpRg2ARW9jmazocqH-hs,350
 DepthFlow/Resources/Images/DepthFlow.png,sha256=oUlRG-luFGw_D4vEEK4YX_fyNlJVoosIp3fYTXRUld8,14623
 DepthFlow/Resources/Images/DepthFlow.svg,sha256=PJ4PG-Bg9guS_kCOrmWrjPAF4R7i9WG26zJIIjT4rmc,1445
-DepthFlow/Resources/Shaders/DepthFlow.frag,sha256=6HWixbGg573llz5J8b1r4kGY3REn4rvITAWlo6pHsfE,2295
+DepthFlow/Resources/Shaders/DepthFlow.frag,sha256=GFI9dBaL5CBgVFCB4v9-OgBxLs9KEwwzqAuviUnl0Kg,2499
 DepthFlow/Resources/Shaders/DepthFlow2D.frag,sha256=2bbH0HQQjkidtB2d2_szqktFMQ_cSsXErzj03RiCOyw,2499
 DepthFlow/Resources/Shaders/DepthFlowMarch.frag,sha256=ynyTiNw9tyUqXijUfg-xtKKsN1Cyia8HEYJEGmohvh4,1688
 Pianola/Pianola.py,sha256=7EkVf8BbguyVjnj9odzfKx3WO9MTThf6cCv-pkhF5Mw,3031
 Pianola/__init__.py,sha256=TMR-5n6kjD_cR-Wf774y74SFr9bWM9WRyG1qtgJUncU,280
 Pianola/__main__.py,sha256=_hwG3KAM5fG6520XE_QLsXYGs1bcZKnuOuHPYQbhXcw,302
 Pianola/Resources/Images/Pianola.png,sha256=8gOx3TNtazAUt4tbm0bs5NAf32KzMBBZpZJ-P6Q0SiE,12579
 Pianola/Resources/Images/Pianola.svg,sha256=JRXhOtJMihRQdALQtm1b-i7HLsnwryFHZxKHll1zxOk,3038
 Pianola/Resources/Midis/Hopeless Sparkle.mid,sha256=LIVjUHMXzl_8vKH2cIUbpMsYbxntvY7IdYLosYNiQNQ,27430
-Pianola/Resources/Shaders/Pianola.frag,sha256=inY9iEJ1Q_dccW_g5O-yam8Vp5yYdM0IgsDFgzdrTJA,8165
+Pianola/Resources/Shaders/Pianola.frag,sha256=9aoTG2z5r21v8jrmIjooF84laqP-jVGmTKM8tGskfwE,8171
 ShaderFlow/Imgui.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ShaderFlow/Message.py,sha256=0RMNw1WBrSaF5wDjl9G_BFaFSxwOA8hszi2zKfcZ7Yk,2574
 ShaderFlow/Module.py,sha256=uNS-Yrop8j_zLabM0mChjPsb66BDfN9_xSBz4q3dr1Y,3321
 ShaderFlow/Notes.py,sha256=UAaxG2FsYyKQBHTmOhlBE2sJTtHDXIPwbjfcxXczzO4,3878
-ShaderFlow/Scene.py,sha256=oYscRkdtGsIH6I85uRrziJlEUAdJcaI-ultbSYH8awg,37584
-ShaderFlow/Shader.py,sha256=5i7oFUHp-mCchdGY6oJiUFI1FSZXJdP2G5Y_KKKr3L4,11684
+ShaderFlow/Scene.py,sha256=rBpVzXwYEfYLmLtmavMdyQwpGOQICBvkhhJ0bb7-d9k,36552
+ShaderFlow/Shader.py,sha256=Atv5i6ELtxurUslluVUZ8UHRSoKXm9lhYVwAeThsHOc,11798
 ShaderFlow/Texture.py,sha256=TjvJBRae8rhPyhcm-XnGjmEBCdxTv2mil_pBmkEUFW4,12979
 ShaderFlow/Variable.py,sha256=78H8K1hUKtIfK56u9HiEB6fs3Xr3HS66UR-EjbpC2iA,4219
-ShaderFlow/__init__.py,sha256=Joj_tFA2qYy86nLgRhUKwnV9pwdzcGHa7R-vmLnM4nQ,437
-ShaderFlow/__main__.py,sha256=XHKcI0hdKRlGO9604KWr_EopMfRuABAIxQ4lUlnvNyA,3699
-ShaderFlow/Modules/Audio.py,sha256=fJkdIF-mZVteSymQdanyc7fTcic1NiRUjvVKVwA_Lu4,12133
-ShaderFlow/Modules/Bouncing.py,sha256=HiI3qakzVPTrYIrrLe6RqGCkP1_v1cexyO1BlfAG9wo,2806
+ShaderFlow/__init__.py,sha256=pZLBMXybUnLb4mRtaM54uq5pmcsBbmpx9LQRJ1C5oWQ,380
+ShaderFlow/__main__.py,sha256=K1edpNBwznHr1HH7RRcm778RMX56_JGRmGRZpPBvNrw,3562
+ShaderFlow/Modules/Audio.py,sha256=2mtzHxdnyh89ftUR5hguH8abX5WbUeehbUF9UxrDi_s,12171
+ShaderFlow/Modules/Bouncing.py,sha256=LV4H2pty8G69v9YkBayH8Cnb6eJI8PfxQ9eF2QxbiWc,3175
 ShaderFlow/Modules/Camera.py,sha256=BmJ2yI-cIIR-i4qTf8VeM0BGLl_TTUYfBEOiqcW0sMI,17629
 ShaderFlow/Modules/Dynamics.py,sha256=TpOZ19SDa1g4h2GOZGDBQr3Wfn9dOOa24VkRWp-e1qw,9042
 ShaderFlow/Modules/Frametimer.py,sha256=9fsVLPoV90v6cXeyv5wszxv9v4_lLSUazCMhCPgIv_w,2332
 ShaderFlow/Modules/Keyboard.py,sha256=uSq0WKVcZA3gNklF9vdtnKa1ZQWH92MA533cXSNvoLU,1494
 ShaderFlow/Modules/Noise.py,sha256=MDUHEA4kS-5iUCHaKgdyDXRnRBqplIBSUVNMuGEYlvY,2475
-ShaderFlow/Modules/Piano.py,sha256=kBTE1s9tsPk2a0tLnYLkALPltUbm4yIneroN1zRQ6e0,16180
+ShaderFlow/Modules/Piano.py,sha256=rMuzdkxYzlAhSez7bJM3vV5Mt_VugrX4ROiL9l30PPk,14001
 ShaderFlow/Modules/Spectrogram.py,sha256=QZ_lnIkq471wvYHnJMoCHKKAIrAztLwH1IOZY_vIjBw,10943
-ShaderFlow/Modules/Video.py,sha256=cqnuuXqYnZpZJtO3nsosP_ibEFCbaHHQvD3tzAsPk08,7197
+ShaderFlow/Modules/Video.py,sha256=bvEisvFEeehzy7QS2kglj4G3mJ1DQpZsQjUReMGjp2c,7218
 ShaderFlow/Modules/Waveform.py,sha256=DxKDXhhh-Sy2yOuPXK8FKq8Bp_IEz3of1yqnjJFTo3U,3137
-ShaderFlow/Modules/__init__.py,sha256=yMGxGtirpP2e6P0pljFmfH1tsvbI87gnZsyqoLARVVQ,300
+ShaderFlow/Modules/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ShaderFlow/Optional/Monocular.py,sha256=RTV4P44FlDU10WVtOnVQRS30Unf5iv3PGlRb_d3MKX8,3961
 ShaderFlow/Optional/OpticalFlow.py,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
 ShaderFlow/Optional/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ShaderFlow/Resources/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ShaderFlow/Resources/Images/ShaderFlow.png,sha256=Z7DL7FqIiwG6o6U3inHe1QmipsRkcmnjXNPxM5-xlWs,20132
 ShaderFlow/Resources/Images/ShaderFlow.svg,sha256=5SlxYmSOAODpXpClTSI2DceG8gbmfKViU1EX2scIbDE,1448
 ShaderFlow/Resources/Scenes/Examples/Demo.py,sha256=XVEBJkzHYzW-fHKTSmrpufGJH_vIObwlQ3wH5eIM7x0,10158
@@ -98,11 +98,11 @@
 ShaderFlow/Resources/Shaders/Vertex/Default.glsl,sha256=mptLPRKopeWq7ybJL5kV4xT_yL3hMeUAxe2LsJYX4gA,538
 SpectroNote/SpectroNote.py,sha256=ldoN5iXHaxLpxYt-PE9Aa2NtG2P98WIvm1qQDdfgrr8,1965
 SpectroNote/__init__.py,sha256=eTj2Y_jbZgApkTk-d8z2UM1AnofAMRZPnlbd6nc3z1w,290
 SpectroNote/__main__.py,sha256=gT5JAcy6y0HMfOAlnKJUxx_Va1qsOUQuMYL7yfP6gx0,342
 SpectroNote/Resources/Images/SpectroNote.png,sha256=Z7DL7FqIiwG6o6U3inHe1QmipsRkcmnjXNPxM5-xlWs,20132
 SpectroNote/Resources/Images/SpectroNote.svg,sha256=5SlxYmSOAODpXpClTSI2DceG8gbmfKViU1EX2scIbDE,1448
 SpectroNote/Resources/Shaders/SpectroNote.frag,sha256=EO1NrbDp8yZGo6X5ZV0g7NKmGMk68jNL3NX4UnmPYjo,3088
-broken_source-0.1.2.dist-info/METADATA,sha256=XmrovUwwQtRqduxh7VFRoKcBizBHPAsBfSJir5YX18k,2934
-broken_source-0.1.2.dist-info/WHEEL,sha256=as-1oFTWSeWBgyzh0O_qF439xqBe6AbBgt4MfYe5zwY,87
-broken_source-0.1.2.dist-info/entry_points.txt,sha256=sliTXdLGMPAHvny75SJgCoSIb556KPPyvqTew_2EI98,194
-broken_source-0.1.2.dist-info/RECORD,,
+broken_source-0.1.3.dist-info/METADATA,sha256=UarfC0mrWyejE6bIpjY6vVOtJVGmURkaQJHoUXZ_mjE,3026
+broken_source-0.1.3.dist-info/WHEEL,sha256=as-1oFTWSeWBgyzh0O_qF439xqBe6AbBgt4MfYe5zwY,87
+broken_source-0.1.3.dist-info/entry_points.txt,sha256=sliTXdLGMPAHvny75SJgCoSIb556KPPyvqTew_2EI98,194
+broken_source-0.1.3.dist-info/RECORD,,
```

