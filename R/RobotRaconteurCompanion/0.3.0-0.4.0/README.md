# Comparing `tmp/RobotRaconteurCompanion-0.3.0-py3-none-any.whl.zip` & `tmp/RobotRaconteurCompanion-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,11 +1,11 @@
-Zip file size: 65023 bytes, number of entries: 67
--rw-rw-rw-  2.0 fat      355 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/__init__.py
--rw-rw-rw-  2.0 fat    13037 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/InfoParser/__init__.py
--rw-rw-rw-  2.0 fat     2454 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/StdRobDef/__init__.py
+Zip file size: 70472 bytes, number of entries: 68
+-rw-rw-rw-  2.0 fat      356 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/__init__.py
+-rw-rw-rw-  2.0 fat    15114 b- defN 24-Apr-04 06:40 RobotRaconteurCompanion/InfoParser/__init__.py
+-rw-rw-rw-  2.0 fat     2467 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/StdRobDef/__init__.py
 -rw-rw-rw-  2.0 fat      182 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef
 -rw-rw-rw-  2.0 fat     2197 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef
 -rw-rw-rw-  2.0 fat      373 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef
 -rw-rw-rw-  2.0 fat      781 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef
 -rw-rw-rw-  2.0 fat     1005 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef
 -rw-rw-rw-  2.0 fat     1042 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef
 -rw-rw-rw-  2.0 fat     1415 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef
@@ -43,27 +43,28 @@
 -rw-rw-rw-  2.0 fat     2952 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef
 -rw-rw-rw-  2.0 fat     5361 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef
 -rw-rw-rw-  2.0 fat      616 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef
 -rw-rw-rw-  2.0 fat     4166 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef
 -rw-rw-rw-  2.0 fat     2522 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef
 -rw-rw-rw-  2.0 fat      127 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef
 -rw-rw-rw-  2.0 fat       97 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef
--rw-rw-rw-  2.0 fat     2456 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/AttributesUtil.py
--rw-rw-rw-  2.0 fat     5188 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/DateTimeUtil.py
--rw-rw-rw-  2.0 fat    31608 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/GeometryUtil.py
--rw-rw-rw-  2.0 fat     7229 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/IdentifierUtil.py
--rw-rw-rw-  2.0 fat    10396 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/ImageUtil.py
--rw-rw-rw-  2.0 fat     4070 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/InfoFileLoader.py
--rw-rw-rw-  2.0 fat     2553 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/LocalIdentifiersManager.py
--rw-rw-rw-  2.0 fat     2339 b- defN 23-Sep-24 00:55 RobotRaconteurCompanion/Util/RobDef.py
--rw-rw-rw-  2.0 fat     5951 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/RobotUtil.py
--rw-rw-rw-  2.0 fat     4768 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/RobustFunctionCaller.py
--rw-rw-rw-  2.0 fat     1834 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/SensorDataUtil.py
--rw-rw-rw-  2.0 fat    10309 b- defN 23-Dec-21 16:44 RobotRaconteurCompanion/Util/TaskGenerator.py
--rw-rw-rw-  2.0 fat     4087 b- defN 23-Dec-21 16:44 RobotRaconteurCompanion/Util/TestFixtures.py
--rw-rw-rw-  2.0 fat     2473 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/UuidUtil.py
--rw-rw-rw-  2.0 fat    11354 b- defN 23-Dec-21 16:45 RobotRaconteurCompanion-0.3.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat      543 b- defN 23-Dec-21 16:45 RobotRaconteurCompanion-0.3.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Dec-21 16:45 RobotRaconteurCompanion-0.3.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       24 b- defN 23-Dec-21 16:45 RobotRaconteurCompanion-0.3.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     7870 b- defN 23-Dec-21 16:45 RobotRaconteurCompanion-0.3.0.dist-info/RECORD
-67 files, 220913 bytes uncompressed, 51669 bytes compressed:  76.6%
+-rw-rw-rw-  2.0 fat     3105 b- defN 24-Apr-04 06:40 RobotRaconteurCompanion/Util/AttributesUtil.py
+-rw-rw-rw-  2.0 fat     5194 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/DateTimeUtil.py
+-rw-rw-rw-  2.0 fat    24642 b- defN 24-Apr-09 18:52 RobotRaconteurCompanion/Util/DeviceConnector.py
+-rw-rw-rw-  2.0 fat    31726 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/GeometryUtil.py
+-rw-rw-rw-  2.0 fat     7208 b- defN 24-Apr-04 06:28 RobotRaconteurCompanion/Util/IdentifierUtil.py
+-rw-rw-rw-  2.0 fat    10397 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/ImageUtil.py
+-rw-rw-rw-  2.0 fat     5001 b- defN 24-Apr-04 06:35 RobotRaconteurCompanion/Util/InfoFileLoader.py
+-rw-rw-rw-  2.0 fat     2536 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/LocalIdentifiersManager.py
+-rw-rw-rw-  2.0 fat     2342 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/RobDef.py
+-rw-rw-rw-  2.0 fat     5922 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/RobotUtil.py
+-rw-rw-rw-  2.0 fat     4732 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/RobustFunctionCaller.py
+-rw-rw-rw-  2.0 fat     1850 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/SensorDataUtil.py
+-rw-rw-rw-  2.0 fat    10035 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/TaskGenerator.py
+-rw-rw-rw-  2.0 fat     3966 b- defN 24-Apr-04 06:40 RobotRaconteurCompanion/Util/TestFixtures.py
+-rw-rw-rw-  2.0 fat     2468 b- defN 24-Mar-19 01:10 RobotRaconteurCompanion/Util/UuidUtil.py
+-rw-rw-rw-  2.0 fat    11355 b- defN 24-Apr-09 20:09 RobotRaconteurCompanion-0.4.0.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat      542 b- defN 24-Apr-09 20:09 RobotRaconteurCompanion-0.4.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-09 20:09 RobotRaconteurCompanion-0.4.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       24 b- defN 24-Apr-09 20:09 RobotRaconteurCompanion-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     7975 b- defN 24-Apr-09 20:09 RobotRaconteurCompanion-0.4.0.dist-info/RECORD
+68 files, 248972 bytes uncompressed, 56948 bytes compressed:  77.1%
```

## zipnote {}

```diff
@@ -144,14 +144,17 @@
 
 Filename: RobotRaconteurCompanion/Util/AttributesUtil.py
 Comment: 
 
 Filename: RobotRaconteurCompanion/Util/DateTimeUtil.py
 Comment: 
 
+Filename: RobotRaconteurCompanion/Util/DeviceConnector.py
+Comment: 
+
 Filename: RobotRaconteurCompanion/Util/GeometryUtil.py
 Comment: 
 
 Filename: RobotRaconteurCompanion/Util/IdentifierUtil.py
 Comment: 
 
 Filename: RobotRaconteurCompanion/Util/ImageUtil.py
@@ -180,23 +183,23 @@
 
 Filename: RobotRaconteurCompanion/Util/TestFixtures.py
 Comment: 
 
 Filename: RobotRaconteurCompanion/Util/UuidUtil.py
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.3.0.dist-info/LICENSE.txt
+Filename: RobotRaconteurCompanion-0.4.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.3.0.dist-info/METADATA
+Filename: RobotRaconteurCompanion-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.3.0.dist-info/WHEEL
+Filename: RobotRaconteurCompanion-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.3.0.dist-info/top_level.txt
+Filename: RobotRaconteurCompanion-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.3.0.dist-info/RECORD
+Filename: RobotRaconteurCompanion-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## RobotRaconteurCompanion/__init__.py

 * *Ordering differences only*

```diff
@@ -6,8 +6,8 @@
     import warnings
     warnings.warn("Could not initialize RobotRaconteurCompanion.StdRobDef")
 
 try:
     from .InfoParser import InfoParser
 except:
     import warnings
-    warnings.warn("Could not initialize RobotRaconteurCompanion.InfoParser")
+    warnings.warn("Could not initialize RobotRaconteurCompanion.InfoParser")
```

## RobotRaconteurCompanion/InfoParser/__init__.py

```diff
@@ -1,67 +1,70 @@
 import yaml
 import RobotRaconteur as RR
 from RobotRaconteur.RobotRaconteurPythonUtil import SplitQualifiedName
 import traceback
 import numpy as np
 import uuid
+from pathlib import Path
 
-def _find_by_name(v,name):
+
+def _find_by_name(v, name):
     for i in v:
-        if (i.Name==name):
+        if (i.Name == name):
             return i
     return None
 
+
 class InfoParser(object):
     """
     Class to load YAML info files into Robot Raconteur device info structures. This wil
     typically be called from InfoFileLoader instead of being called directly.
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
 
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self.node = RR.RobotRaconteurNode.s
         else:
             self.node = node
         self.client_obj = client_obj
 
     def _find_namedarray(self, n):
         try:
-            dtype = self.node.GetNamedArrayDType(n,self.client_obj)
+            dtype = self.node.GetNamedArrayDType(n, self.client_obj)
         except:
             return None, None
         service_name, n1 = SplitQualifiedName(n)
-        type_def = _find_by_name(self.node.GetServiceType(service_name).NamedArrays,n1)
+        type_def = _find_by_name(self.node.GetServiceType(service_name).NamedArrays, n1)
         assert type_def is not None
         return dtype, type_def
 
     def _find_structure(self, s):
         try:
-            stype = self.node.GetStructureType(s,self.client_obj)
+            stype = self.node.GetStructureType(s, self.client_obj)
         except:
             return None, None
         service_name, s1 = SplitQualifiedName(s)
-        type_def = _find_by_name(self.node.GetServiceType(service_name).Structures,s1)
+        type_def = _find_by_name(self.node.GetServiceType(service_name).Structures, s1)
         assert type_def is not None
         return stype, type_def
 
     def _find_enum(self, s):
         service_name, s1 = SplitQualifiedName(s)
         try:
-            return _find_by_name(self.node.GetServiceType(service_name).Enums,s1)
+            return _find_by_name(self.node.GetServiceType(service_name).Enums, s1)
         except:
             return None
-    
-    def _rr_type_to_dtype(self,rr_type_code):
+
+    def _rr_type_to_dtype(self, rr_type_code):
         if rr_type_code == RR.DataTypes_double_t:
             return np.float64
         if rr_type_code == RR.DataTypes_single_t:
             return np.float32
         if rr_type_code == RR.DataTypes_int8_t:
             return np.int8
         if rr_type_code == RR.DataTypes_uint8_t:
@@ -73,237 +76,280 @@
         if rr_type_code == RR.DataTypes_int32_t:
             return np.int32
         if rr_type_code == RR.DataTypes_uint32_t:
             return np.uint32
         if rr_type_code == RR.DataTypes_int64_t:
             return np.int64
         if rr_type_code == RR.DataTypes_uint64_t:
-            return np.uint64        
-    
-    def _check_array_len(self,arr,type_def):
+            return np.uint64
+
+    def _check_array_len(self, arr, type_def):
         if type_def.ArrayVarLength == True:
             if len(type_def.ArrayLength) == 0 or type_def.ArrayLength[0] == 0:
                 return True
             if len(arr) <= type_def.ArrayLength[0]:
                 return True
             return False
         else:
             return len(arr) == type_def.ArrayLength[0]
 
-    def _parse_number(self,d,type_def):
+    def _parse_number(self, d, type_def):
         if type_def.ArrayType == RR.DataTypes_ArrayTypes_none:
             if type_def.Type == RR.DataTypes_bool_t:
                 return bool(d)
             if type_def.Type == RR.DataTypes_double_t or type_def.Type == RR.DataTypes_single_t:
                 return float(d)
             else:
-                if isinstance(d,str):
-                    return int(d,0)
-                else:                    
-                        return int(d)
+                if isinstance(d, str):
+                    return int(d, 0)
+                else:
+                    return int(d)
         elif type_def.ArrayType == RR.DataTypes_ArrayTypes_array:
             f_dtype = self._rr_type_to_dtype(type_def.Type)
-            arr = np.array(d,dtype=f_dtype)
-            assert self._check_array_len(arr,type_def)
+            arr = np.array(d, dtype=f_dtype)
+            assert self._check_array_len(arr, type_def)
             return arr
         elif type_def.ArrayType == RR.DataTypes_ArrayTypes_multidimarray:
             # TODO: handle more than fixed 2D multidim arrays
             if len(type_def.ArrayLength) != 2:
                 return None
             f_dtype = self._rr_type_to_dtype(type_def.Type)
-            arr = np.array(d,dtype=f_dtype)
-            return arr.reshape(type_def.ArrayLength,order="F")
+            arr = np.array(d, dtype=f_dtype)
+            return arr.reshape(type_def.ArrayLength, order="F")
         else:
             return None
 
-    def _parse_structure(self, d, struct_type, struct_def):        
+    def _parse_structure(self, d, struct_type, struct_def):
         service_def = struct_def.GetServiceDefinition()
         struct_type_name = service_def.Name + "." + struct_def.Name
-        s_override = "_override_structure_" + struct_type_name.replace(".","__")
-        if hasattr(self,s_override):
-            ov_res,ov_val = getattr(self,s_override)(d,struct_type,struct_def)
+        s_override = "_override_structure_" + struct_type_name.replace(".", "__")
+        if hasattr(self, s_override):
+            ov_res, ov_val = getattr(self, s_override)(d, struct_type, struct_def)
             if ov_res:
                 return ov_val
         ret = struct_type()
         for i in range(len(struct_def.Members)):
             f_def = struct_def.Members[i]
             f_name = f_def.Name
             if not f_name in d:
                 continue
-            f_override = "_override_field_" + (service_def.Name + "." + struct_def.Name + "." + f_def.Name).replace(".","__")
-            if hasattr(self,f_override):
-               f_res = getattr(self,f_override)(d[f_name],f_def.Type,service_def)
-               setattr(ret,f_name,f_res)
-               continue
-            f_res,f_val = self._parse_field_value(d[f_name], f_def.Type, struct_def, service_def)
+            f_override = "_override_field_" + (service_def.Name + "." +
+                                               struct_def.Name + "." + f_def.Name).replace(".", "__")
+            if hasattr(self, f_override):
+                f_res = getattr(self, f_override)(d[f_name], f_def.Type, service_def)
+                setattr(ret, f_name, f_res)
+                continue
+            f_res, f_val = self._parse_field_value(d[f_name], f_def.Type, struct_def, service_def)
             if f_res:
-                setattr(ret,f_name,f_val)
+                setattr(ret, f_name, f_val)
                 continue
 
+        s_extra = "_extra_structure_" + struct_type_name.replace(".", "__")
+        if hasattr(self, s_extra):
+            getattr(self, s_extra)(ret, d, struct_type, struct_def)
+
         return ret
-        
+
     def _parse_field_value(self, d, f_type, struct_def, service_def):
-        
+
         if f_type.ContainerType != RR.DataTypes_ContainerTypes_none:
             f_type_e = f_type.Clone()
             f_type_e.RemoveContainers()
             if f_type.ContainerType == RR.DataTypes_ContainerTypes_list:
                 ret = []
                 for e in d:
-                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
+                    e_res, e_val = self._parse_field_value(e, f_type_e, struct_def, service_def)
                     assert e_res
                     ret.append(e_val)
-                return True,ret
+                return True, ret
             if f_type.ContainerType == RR.DataTypes_ContainerTypes_map_int32:
                 ret = {}
-                for k,v in d:
-                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
+                for k, v in d:
+                    e_res, e_val = self._parse_field_value(e, f_type_e, struct_def, service_def)
                     assert e_res
-                    ret[int(k,0)] = e_val
-                return True,ret
+                    ret[int(k, 0)] = e_val
+                return True, ret
             if f_type.ContainerType == RR.DataTypes_ContainerTypes_map_string:
                 ret = {}
-                for k,v in d:
-                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
+                for k, v in d:
+                    e_res, e_val = self._parse_field_value(e, f_type_e, struct_def, service_def)
                     assert e_res
                     ret[str(k)] = e_val
-                return True,ret
+                return True, ret
         if RR.IsTypeNumeric(f_type.Type):
-            f_res = self._parse_number(d,f_type)
+            f_res = self._parse_number(d, f_type)
             if f_res is not None:
                 return True, f_res
-        
+
         if f_type.Type == RR.DataTypes_string_t:
-            return True,str(d)
-            
-        
+            return True, str(d)
+
         if f_type.Type == RR.DataTypes_namedtype_t:
             typename = f_type.TypeString
             if "." not in typename:
-                typename = service_def.Name + "." + typename            
+                typename = service_def.Name + "." + typename
             s_type, s_def = self._find_structure(typename)
             if s_type is not None:
-                return True, self._parse_structure(d,s_type,s_def)
+                return True, self._parse_structure(d, s_type, s_def)
             n_dtype, n_def = self._find_namedarray(typename)
             if n_dtype is not None:
-                return True, self._parse_namedarray(d,f_type,n_dtype,n_def)
+                return True, self._parse_namedarray(d, f_type, n_dtype, n_def)
             e_def = self._find_enum(typename)
             if e_def is not None:
-                enum_val = _find_by_name(e_def.Values,str(d))
+                enum_val = _find_by_name(e_def.Values, str(d))
                 assert enum_val is not None, "Invalid enum value"
-                return True, int(enum_val.Value)           
-        return False,None        
+                return True, int(enum_val.Value)
+        return False, None
 
     def _parse_namedarray_el(self, d, arr, ind, d_type):
-        
-        for k,v in d_type.fields.items():
+
+        for k, v in d_type.fields.items():
             if v[0].fields is not None:
-                self._parse_namedarray_el(d[k],arr[ind],k,v[0])
+                self._parse_namedarray_el(d[k], arr[ind], k, v[0])
             else:
-                arr[ind][k] = np.array(d[k],dtype=v[0])   
+                arr[ind][k] = np.array(d[k], dtype=v[0])
 
     def _parse_namedarray(self, d, f_type, namedarray_dtype, namedarray_def):
         service_def = namedarray_def.GetServiceDefinition()
         namedarray_type_name = service_def.Name + "." + namedarray_def.Name
-        n_override = "_override_namedarray_" + namedarray_type_name.replace(".","__")
-        if hasattr(self,n_override):
-            return getattr(self,n_override)(d,f_type,namedarray_dtype,namedarray_def)
+        n_override = "_override_namedarray_" + namedarray_type_name.replace(".", "__")
+        if hasattr(self, n_override):
+            return getattr(self, n_override)(d, f_type, namedarray_dtype, namedarray_def)
         if f_type.ArrayType == RR.DataTypes_ArrayTypes_none:
-            arr = np.zeros((1,),dtype=namedarray_dtype)
-            self._parse_namedarray_el(d,arr,0,namedarray_dtype)
+            arr = np.zeros((1,), dtype=namedarray_dtype)
+            self._parse_namedarray_el(d, arr, 0, namedarray_dtype)
             return arr
         if f_type.ArrayType == RR.DataTypes_ArrayTypes_array:
             n = len(d)
-            arr = np.zeros((n,),dtype=namedarray_dtype)
+            arr = np.zeros((n,), dtype=namedarray_dtype)
             for i in range(n):
-                self._parse_namedarray_el(d[i],arr,i,namedarray_dtype)
+                self._parse_namedarray_el(d[i], arr, i, namedarray_dtype)
             return arr
         return None
 
     def ParseInfoFile(self, filename, type_name):
         """
-        Load and parse a YAML file containing contents of a device info structure. The type_name 
+        Load and parse a YAML file containing contents of a device info structure. The type_name
         must be the fully qualified name of the structure type. The structure type must be defined
         in a service definition loaded into the node, or pulled by a client object.
 
         :param filename: The filename of the YAML file to load
         :type filename: str
-        :param type_name: The fully qualified name of the structure type. Examples include 
+        :param type_name: The fully qualified name of the structure type. Examples include
           ``com.robotraconteur.robotics.robot.DeviceInfo`` and ``com.robotraconteur.robotics.robot.RobotInfo``
         :type type_name: str
         :return: The parsed structure
 
         """
 
         struct_type = self._find_structure(type_name)
-
-        with open(filename, 'r') as f:
-            file_text = f.read()
-
-        return self.ParseInfoString(file_text, type_name)
+        if isinstance(filename, str) or isinstance(filename, Path):
+            with open(filename, 'r') as f:
+                file_text = f.read()
+        else:
+            file_text = filename.read()
+        info_dict = yaml.safe_load(file_text)
+        return self.ParseInfoDict(info_dict, type_name)
 
     def ParseInfoString(self, info_string, type_name):
         """
         Parse a YAML string containing contents of a device info structure. The type_name
         must be the fully qualified name of the structure type. The structure type must be defined
         in a service definition loaded into the node, or pulled by a client object.
 
         :param info_string: The YAML string to parse
         :type info_string: str
         :param type_name: The fully qualified name of the structure type. Examples include
             ``com.robotraconteur.robotics.robot.DeviceInfo`` and ``com.robotraconteur.robotics.robot.RobotInfo``
         :type type_name: str
         :return: The parsed structure
+        """
+        struct_type = self._find_structure(type_name)
 
+        info_dict = yaml.safe_load(info_string)
+        return self.ParseInfoDict(info_dict, type_name)
+
+    def ParseInfoDict(self, info_dict, type_name):
+        """
+        Use a parsed YAML string containing contents of a device info structure. The type_name
+        must be the fully qualified name of the structure type. The structure type must be defined
+        in a service definition loaded into the node, or pulled by a client object.
+
+        :param info_dict: The dictionary containing the parsed YAML structure
+        :type info_dict: dict
+        :param type_name: The fully qualified name of the structure type. Examples include
+            ``com.robotraconteur.robotics.robot.DeviceInfo`` and ``com.robotraconteur.robotics.robot.RobotInfo``
+        :type type_name: str
+        :return: The parsed structure
         """
 
         struct_type, struct_def = self._find_structure(type_name)
         if struct_type is None:
             raise RR.InvalidArgumentException("Invalid structure type specified")
-        
-        d = yaml.safe_load(info_string)
-        
-        ret = self._parse_structure(d,struct_type,struct_def)
+
+        ret = self._parse_structure(info_dict, struct_type, struct_def)
         return ret
 
-    ## Overrides for standard types
+    # Overrides for standard types
 
     def _override_field_com__robotraconteur__robotics__robot__RobotInfo__robot_capabilities(self, d, f_type, service_def):
-        enum_def = _find_by_name(service_def.Enums,"RobotCapabilities")
-        return self._flags_override(d,enum_def)
-    
+        enum_def = _find_by_name(service_def.Enums, "RobotCapabilities")
+        return self._flags_override(d, enum_def)
+
     def _override_field_com__robotraconteur__robotics__tool__ToolInfo__tool_capabilities(self, d, f_type, service_def):
-        enum_def = _find_by_name(service_def.Enums,"ToolCapabilities")
-        return self._flags_override(d,enum_def)
+        enum_def = _find_by_name(service_def.Enums, "ToolCapabilities")
+        return self._flags_override(d, enum_def)
 
     def _override_field_com__robotraconteur__servo__ServoInfo__capabilities(self, d, f_type, service_def):
-        enum_def = _find_by_name(service_def.Enums,"ServoCapabilities")
-        return self._flags_override(d,enum_def)
+        enum_def = _find_by_name(service_def.Enums, "ServoCapabilities")
+        return self._flags_override(d, enum_def)
 
     def _flags_override(self, d, enum_def):
         ret = 0
         for e in d:
-            enum_val = _find_by_name(enum_def.Values,e)
+            enum_val = _find_by_name(enum_def.Values, e)
             assert enum_val is not None, "Invalid flag name"
             ret |= int(enum_val.Value)
         return ret
 
-    def _override_namedarray_com__robotraconteur__uuid__UUID(self,d,f_type,namedarray_dtype,namedarray_def):
+    def _override_namedarray_com__robotraconteur__uuid__UUID(self, d, f_type, namedarray_dtype, namedarray_def):
         ret_uuid = uuid.UUID(str(d))
-        ret_bytes = np.frombuffer(ret_uuid.bytes,dtype=np.uint8)
-        ret = np.zeros((1,),dtype=namedarray_dtype)
-        ret[0]["uuid_bytes"]=ret_bytes
+        ret_bytes = np.frombuffer(ret_uuid.bytes, dtype=np.uint8)
+        ret = np.zeros((1,), dtype=namedarray_dtype)
+        ret[0]["uuid_bytes"] = ret_bytes
         return ret
 
-    def _override_structure_com__robotraconteur__identifier__Identifier(self, d, struct_type, struct_def):        
-        if isinstance(d,str) or isinstance(d,int) or isinstance(d,float):
+    def _override_structure_com__robotraconteur__identifier__Identifier(self, d, struct_type, struct_def):
+        if isinstance(d, str) or isinstance(d, int) or isinstance(d, float):
             ret = struct_type()
             ret.name = str(d)
-            ret.uuid = np.resize(ret.uuid,(1,))
-            return True,ret
-        return False,None
+            ret.uuid = np.resize(ret.uuid, (1,))
+            return True, ret
+        return False, None
 
-    def _override_field_com__robotraconteur__imaging__camerainfo__CameraCalibration__distortion_info(self,d,f_type,service_def):
-        s_type,s_def = self._find_structure('com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
+    def _override_field_com__robotraconteur__imaging__camerainfo__CameraCalibration__distortion_info(self, d, f_type, service_def):
+        s_type, s_def = self._find_structure('com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
         assert s_type is not None
-        return RR.VarValue(self._parse_structure(d,s_type,s_def),'com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
-        
+        return RR.VarValue(self._parse_structure(d, s_type, s_def), 'com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
+
+    def _extra_structure_com__robotraconteur__device__DeviceInfo(self, s, d, struct_type, struct_def):
+        s_type, s_def = self._find_structure("com.robotraconteur.identifier.Identifier")
+
+        tags_out = []
+        tags_in = []
+        tags1 = d.get("tags", None)
+        if tags1 is not None:
+            tags_in.extend(tags1)
+        extended1 = d.get("extended", None)
+        if extended1 is not None:
+            tags2 = extended1.get("tags", None)
+            if tags2 is not None:
+                tags_in.extend(tags2)
+
+        for t in tags_in:
+            tags_out.append(RR.VarValue(self._parse_structure(t, s_type, s_def),
+                            "com.robotraconteur.identifier.Identifier"))
+
+        if len(tags_out) > 0:
+            if s.extended is None:
+                s.extended = {}
+            s.extended["tags"] = tags_out
```

## RobotRaconteurCompanion/StdRobDef/__init__.py

```diff
@@ -43,28 +43,31 @@
     'com.robotraconteur.sensordata',
     'com.robotraconteur.servo',
     'com.robotraconteur.signal',
     'com.robotraconteur.units',
     'com.robotraconteur.uuid'
 ]
 
-STANDARD_ROBDEF_TEXT={}
+STANDARD_ROBDEF_TEXT = {}
+
 
 def _load_standard_robdef_text():
     import importlib_resources
     for n in STANDARD_ROBDEF_NAMES:
-        robdef_text = (importlib_resources.files() / (n + '.robdef')).read_text()
+        robdef_text = (importlib_resources.files(__package__) / (n + '.robdef')).read_text()
         STANDARD_ROBDEF_TEXT[n] = robdef_text
 
+
 _load_standard_robdef_text()
 
+
 def RegisterStdRobDefServiceTypes(node):
     """
     Register standard Robot Raconteur service types to a node. This function will call RegisterServiceTypes() for
     the standard services types to register them into the node.
 
     :param node: The node to register the service types to. Typically this will be ``RRN`` for the default node.
     :type node: RobotRaconteur.RobotRaconteurNode
     """
-    
+
     robdefs_text = list(STANDARD_ROBDEF_TEXT.values())
-    node.RegisterServiceTypes(robdefs_text)
+    node.RegisterServiceTypes(robdefs_text)
```

## RobotRaconteurCompanion/Util/AttributesUtil.py

```diff
@@ -2,66 +2,81 @@
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 
 from .IdentifierUtil import IdentifierUtil
 
 
 class AttributesUtil(object):
-    """  
+    """
     Utility class to get the default attributes from a DeviceInfo structure. These attributes are
     used to populate the default service attributes when registering a service
     with a device.
-    
+
     The following attributes are used:
-    
+
     - device
     - parent_device
     - manufacturer
     - model
     - serial_number
     - user_description
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
         self._ident_util = IdentifierUtil(self._node, self._client_obj)
 
     def _try_add_identifier(self, o, name, id_):
         if not self._ident_util.IsIdentifierAny(id_):
-            o[name] =  RR.VarValue(self._ident_util.IdentifierToString(id_),"string")
+            o[name] = RR.VarValue(self._ident_util.IdentifierToString(id_), "string")
             return True
         return False
 
     def _try_add_string(self, o, name, str_):
         if str_ is not None and len(str_) > 0:
-            o[name] = RR.VarValue(str_,"string")
+            o[name] = RR.VarValue(str_, "string")
+            return True
+        return False
+
+    def _try_add_identifier_list(self, o, name, id_list):
+        tags_str_list = []
+        if id_list is not None and len(id_list) > 0:
+            for x in id_list:
+                if hasattr(x, "data"):
+                    x = x.data
+                if not self._ident_util.IsIdentifierAny(x):
+                    tags_str_list.append(self._ident_util.IdentifierToString(x))
+            if len(tags_str_list) > 0:
+                o[name] = RR.VarValue(",".join(tags_str_list), "string")
             return True
-        return False        
-        
+        return False
+
     def GetDefaultServiceAttributesFromDeviceInfo(self, device_info):
         """
         Get the default service attributes from a DeviceInfo structure. These attributes are
         used to populate the default service attributes when registering a service.
 
         :param device_info: The device info structure
         :type device_info: com.robotraconteur.DeviceInfo
         :return: The default service attributes
         :rtype: dict
         """
         o = dict()
-        self._try_add_identifier(o,"device", device_info.device)
-        self._try_add_identifier(o,"parent_device", device_info.parent_device)
-        self._try_add_identifier(o,"manufacturer", device_info.manufacturer)
-        self._try_add_identifier(o,"model", device_info.model)
-        self._try_add_string(o,"serial_number",device_info.serial_number)
-        self._try_add_string(o,"user_description",device_info.user_description)
-        return o
+        self._try_add_identifier(o, "device", device_info.device)
+        self._try_add_identifier(o, "parent_device", device_info.parent_device)
+        self._try_add_identifier(o, "manufacturer", device_info.manufacturer)
+        self._try_add_identifier(o, "model", device_info.model)
+        self._try_add_string(o, "serial_number", device_info.serial_number)
+        self._try_add_string(o, "user_description", device_info.user_description)
+        if device_info.extended is not None:
+            self._try_add_identifier_list(o, "tags", device_info.extended.get("tags"))
+        return o
```

## RobotRaconteurCompanion/Util/DateTimeUtil.py

```diff
@@ -1,24 +1,25 @@
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import datetime
 import numpy as np
 import math
 
+
 class DateTimeUtil(object):
     """
     Utility class to populate Robot Raconteur time structures
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
         self._datetimeutc_dt = self._node.GetPodDType("com.robotraconteur.datetime.DateTimeUTC", self._client_obj)
@@ -26,86 +27,86 @@
         self._timespec2_dt = self._node.GetPodDType("com.robotraconteur.datetime.TimeSpec2", self._client_obj)
         self._timespec3_dt = self._node.GetNamedArrayDType("com.robotraconteur.datetime.TimeSpec3", self._client_obj)
         self._devicetime_dt = self._node.GetPodDType("com.robotraconteur.device.clock.DeviceTime", self._client_obj)
 
         self._datetime_const = self._node.GetConstants("com.robotraconteur.datetime")
         self._clock_codes = self._datetime_const["ClockTypeCode"]
 
-    def UtcNow(self, device_info = None):
+    def UtcNow(self, device_info=None):
         """
         Get the current DateTimeUTC Time from the node
 
         :param device_info: (optional) The device info structure to use for the clock UUID. Defaults to None
         :type device_info: com.robotraconteur.device.DeviceInfo
         :return: The current UTC time
         :rtype: com.robotraconteur.datetime.DateTimeUTC
         """
         now_dt = self._node.NowUTC()
-        now = (now_dt - datetime.datetime(1970,1,1,0,0,0,0)).total_seconds()
-        ret = np.zeros((1,),dtype=self._datetimeutc_dt)
+        now = (now_dt - datetime.datetime(1970, 1, 1, 0, 0, 0, 0)).total_seconds()
+        ret = np.zeros((1,), dtype=self._datetimeutc_dt)
         ret[0]["seconds"] = int(math.floor(now))
-        ret[0]["nanoseconds"] = int((now % 1.0)*1e9)
+        ret[0]["nanoseconds"] = int((now % 1.0) * 1e9)
         ret[0]["clock_info"]["clock_type"] = self._clock_codes["default"]
         if device_info is not None and device_info.device is not None:
             ret[0]["clock_info"]["clock_uuid"] = device_info.device.uuid
         return ret
 
-    def TimeSpec2Now(self, device_info = None):
+    def TimeSpec2Now(self, device_info=None):
         """
         Get the current TimeSpec from the node, stored as TimeSpec2
 
         TimeSpec is based on the performance counter, and is not guaranteed to be
         synchronized between nodes or with the system real-time clock. It is expected
-        to be close to the system real-time clock, but may drift over time and is 
+        to be close to the system real-time clock, but may drift over time and is
         guaranteed to remain stable even if the system real-time clock is changed.
 
         :param device_info: (optional) The device info structure to use for the clock UUID. Defaults to None
         :type device_info: com.robotraconteur.device.DeviceInfo
         :return: The current TimeSpec as TimeSpec2
         :rtype: com.robotraconteur.datetime.TimeSpec2
         """
         now_ts = self._node.NowTimeSpec()
-        ret = np.zeros((1,),dtype=self._timespec2_dt)
+        ret = np.zeros((1,), dtype=self._timespec2_dt)
         ret[0]["seconds"] = now_ts.seconds
         ret[0]["nanoseconds"] = now_ts.nanoseconds
         ret[0]["clock_info"]["clock_type"] = self._clock_codes["default"]
         if device_info is not None and device_info.device is not None:
             ret[0]["clock_info"]["clock_uuid"] = device_info.device.uuid
         return ret
 
     def TimeSpec3Now(self):
         """
         Get the current TimeSpec from the node, stored as TimeSpec3
-  
+
         The TimeSpec3 is a 64-bit integer representing microseconds since the epoch
         of the real-time clock. It is intended to be a compact representation of the
         current time that can be used for timestamping data.
 
         TimeSpec is based on the performance counter, and is not guaranteed to be
         synchronized between nodes or with the system real-time clock. It is expected
-        to be close to the system real-time clock, but may drift over time and is 
+        to be close to the system real-time clock, but may drift over time and is
         guaranteed to remain stable even if the system real-time clock is changed.
 
         :return: The current TimeSpec as TimeSpec3
         :rtype: com.robotraconteur.datetime.TimeSpec3
         """
         now_ts = self._node.NowTimeSpec()
-        ret = np.zeros((1,),dtype=self._timespec3_dt)
-        ret[0]["microseconds"] = now_ts.seconds*1e6 + now_ts.nanoseconds*1e-3
+        ret = np.zeros((1,), dtype=self._timespec3_dt)
+        ret[0]["microseconds"] = now_ts.seconds * 1e6 + now_ts.nanoseconds * 1e-3
         return ret
 
     def FillDeviceTime(self, device_info, seqno):
         """
         Fill a DeviceTime structure with the current time
 
         :param device_info: The device info structure to use for the clock UUID
         :type device_info: com.robotraconteur.device.DeviceInfo
         :param seqno: The sequence number to use
         :type seqno: int
         :return: The DeviceTime structure
         :rtype: com.robotraconteur.device.clock.DeviceTime
         """
-        ret = np.zeros((1,),self._devicetime_dt)
+        ret = np.zeros((1,), self._devicetime_dt)
         ret[0]["device_seqno"] = seqno
         ret[0]["device_ts"] = self.TimeSpec2Now(device_info)
         ret[0]["device_utc"] = self.UtcNow(device_info)
-        return ret
+        return ret
```

## RobotRaconteurCompanion/Util/GeometryUtil.py

```diff
@@ -1,29 +1,32 @@
+"""
+Utility class to convert between Robot Raconteur types and Python types. Python numpy or general_robotics_toolbox
+types are used when applicable.
+
+:param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+:type node: RobotRaconteur.RobotRaconteurNode
+:param client_obj: (optional) The client object to use for finding types. Defaults to None
+:type client_obj: RobotRaconteur.ClientObject
+"""
+
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 import general_robotics_toolbox as rox
 from .IdentifierUtil import IdentifierUtil
 
+
 def _name_from_identifier(id_):
     if id_ is None:
         return None
     return id_.name
 
-"""
-Utility class to convert between Robot Raconteur types and Python types. Python numpy or general_robotics_toolbox
-types are used when applicable.
 
-:param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
-:type node: RobotRaconteur.RobotRaconteurNode
-:param client_obj: (optional) The client object to use for finding types. Defaults to None
-:type client_obj: RobotRaconteur.ClientObject
-"""
 class GeometryUtil(object):
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
         self._vector2_type = self._create_dtypes("Vector2")
@@ -42,59 +45,56 @@
         self._spatial_acceleration_type = self._create_dtypes("SpatialAcceleration")
         self._wrench_type = self._create_dtypes("Wrench")
 
         self._ident_util = IdentifierUtil(self._node, self._client_obj)
 
     def _create_dtypes(self, type_name):
         try:
-            d_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometry.{type_name}",self._client_obj)
+            d_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometry.{type_name}", self._client_obj)
         except:
             d_type = None
         try:
-            f_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryf.{type_name}",self._client_obj)
+            f_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryf.{type_name}", self._client_obj)
         except:
             f_type = None
         try:
-            i_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryi.{type_name}",self._client_obj)
+            i_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryi.{type_name}", self._client_obj)
         except:
             i_type = None
 
         assert any((d_type, f_type, i_type)), "No geometry service types registered"
         return d_type, f_type, i_type
 
-
-
-
     def _create_structtypes(self, type_name):
         try:
-            d_type = self._node.GetStructureType(f"com.robotraconteur.geometry.{type_name}",self._client_obj)
+            d_type = self._node.GetStructureType(f"com.robotraconteur.geometry.{type_name}", self._client_obj)
         except:
             d_type = None
         try:
-            f_type = self._node.GetStructureType(f"com.robotraconteur.geometryf.{type_name}",self._client_obj)
+            f_type = self._node.GetStructureType(f"com.robotraconteur.geometryf.{type_name}", self._client_obj)
         except:
             f_type = None
         try:
-            i_type = self._node.GetStructureType(f"com.robotraconteur.geometryi.{type_name}",self._client_obj)
+            i_type = self._node.GetStructureType(f"com.robotraconteur.geometryi.{type_name}", self._client_obj)
         except:
             i_type = None
-        
+
         assert any((d_type, f_type, i_type)), "No geometry service types registered"
         return d_type, f_type, i_type
 
     def _create_return_np(self, rr_dtypes, dtype):
         if dtype == np.float64:
             assert rr_dtypes[0], "com.robotraconteur.geometry not registered"
-            return np.zeros((1,),dtype=rr_dtypes[0])
+            return np.zeros((1,), dtype=rr_dtypes[0])
         elif dtype == np.float32:
             assert rr_dtypes[1], "com.robotraconteur.geometryf not registered"
-            return np.zeros((1,),dtype=rr_dtypes[1])
+            return np.zeros((1,), dtype=rr_dtypes[1])
         elif dtype == np.int32:
             assert rr_dtypes[2], "com.robotraconteur.geometryi not registered"
-            return np.zeros((1,),dtype=rr_dtypes[2])
+            return np.zeros((1,), dtype=rr_dtypes[2])
         else:
             assert False, "Invalid dtype"
 
     def _create_return_struct(self, rr_struct_types, dtype):
         if dtype == np.float64:
             assert rr_struct_types[0], "com.robotraconteur.geometry not registered"
             return rr_struct_types[0]()
@@ -121,15 +121,15 @@
         ret[0]["y"] = xy[1]
         return ret
 
     def vector2_to_xy(self, rr_vector2):
         """
         Converts a Robot Raconteur Vector2 to a 2 element vector
 
-        :param rr_vector2: The Robot Raconteur Vector2 
+        :param rr_vector2: The Robot Raconteur Vector2
         :type rr_vector2: com.robotraconteur.geometry.Vector2
         :return: The 2D vector
         :rtype: numpy.ndarray
         """
         return np.array([rr_vector2[0]["x"], rr_vector2[0]["y"]])
 
     def xyz_to_vector3(self, xyz, dtype=np.float64):
@@ -175,16 +175,16 @@
         Converts a Robot Raconteur Vector6 to a 6 element vector
 
         :param rr_vector6: The Robot Raconteur Vector6
         :type rr_vector6: com.robotraconteur.geometry.Vector6
         :return: The 6D vector
         :rtype: numpy.ndarray
         """
-        return np.array([rr_vector6[0]["alpha"], rr_vector6[0]["beta"], rr_vector6[0]["gamma"], \
-            rr_vector6[0]["x"], rr_vector6[0]["y"], rr_vector6[0]["z"]])
+        return np.array([rr_vector6[0]["alpha"], rr_vector6[0]["beta"], rr_vector6[0]["gamma"],
+                         rr_vector6[0]["x"], rr_vector6[0]["y"], rr_vector6[0]["z"]])
 
     def xy_to_point2d(self, xy, dtype=np.float64):
         """
         Converts a 2 element vector to a Robot Raconteur Point2D
 
         :param xy: The 2 element vector
         :type xy: numpy.ndarray
@@ -232,15 +232,14 @@
         :param rr_point: The Robot Raconteur Point
         :type rr_point: com.robotraconteur.geometry.Point
         :return: The 3 element vector
         :rtype: numpy.ndarray
         """
         return np.array([rr_point[0]["x"], rr_point[0]["y"], rr_point[0]["z"]])
 
-
     def wh_to_size2d(self, wh, dtype=np.float64):
         """
         Converts a 2 element vector to a Robot Raconteur Size2D
 
         :param wh: The 2 element vector
         :type wh: numpy.ndarray
         :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
@@ -315,15 +314,15 @@
         Converts a Robot Raconteur Quaternion to a 4 element vector. The order of the elements is [w,x,y,z]
 
         :param rr_quaternion: The Robot Raconteur Quaternion
         :type rr_quaternion: com.robotraconteur.geometry.Quaternion
         :return: The 4 element vector
         :rtype: numpy.ndarray
         """
-        return np.array([rr_quaternion[0]["w"],rr_quaternion[0]["x"],rr_quaternion[0]["y"],rr_quaternion[0]["z"]])
+        return np.array([rr_quaternion[0]["w"], rr_quaternion[0]["x"], rr_quaternion[0]["y"], rr_quaternion[0]["z"]])
 
     def R_to_quaternion(self, R, dtype=np.float64):
         """
         Converts a 3x3 rotation matrix to a Robot Raconteur Quaternion
 
         :param R: The 3x3 rotation matrix
         :type R: numpy.ndarray
@@ -391,20 +390,20 @@
         :param rr_transform: The Robot Raconteur Transform
         :type rr_transform: com.robotraconteur.geometry.Transform
         :return: The general_robotics_toolbox Transform
         :rtype: general_robotics_toolbox.Transform
         """
         R = self.quaternion_to_R(rr_transform["rotation"])
         p = self.vector3_to_xyz(rr_transform["translation"])
-        return rox.Transform(R,p)
+        return rox.Transform(R, p)
 
-    def _xyz_rpy_to_rox_transform(self, xyz,rpy,parent_frame_id=None,child_frame_id=None):
+    def _xyz_rpy_to_rox_transform(self, xyz, rpy, parent_frame_id=None, child_frame_id=None):
         p = xyz
         R = rox.rpy2R(rpy)
-        return rox.Transform(R,p,parent_frame_id,child_frame_id)
+        return rox.Transform(R, p, parent_frame_id, child_frame_id)
 
     def _rox_transform_to_xyz_rpy(self, rox_transform):
         R = rox_transform.R
         p = rox_transform.p
         return p, rox.R2rpy(R)
 
     def _rox_transform_to_xyz_rpy_named(self, rox_transform):
@@ -412,31 +411,31 @@
         p = rox_transform.p
         parent_frame_id = rox_transform.parent_frame_id
         child_frame_id = rox_transform.child_frame_id
         return p, rox.R2rpy(R), parent_frame_id, child_frame_id
 
     def xyz_rpy_to_transform(self, xyz, rpy, dtype=np.float64):
         """
-        Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a 
+        Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
         Robot Raconteur Transform
 
         :param xyz: The 3 element position vector
         :type xyz: numpy.ndarray
         :param rpy: The 3 element roll-pitch-yaw vector in radians
         :type rpy: numpy.ndarray
         :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
         :type dtype: com.robotraconteur.geometry.Transform
         :return: The Robot Raconteur Transform
         :rtype: com.robotraconteur.geometry.Transform
         """
-        return self.rox_transform_to_transform(self._xyz_rpy_to_rox_transform(xyz,rpy),dtype)
+        return self.rox_transform_to_transform(self._xyz_rpy_to_rox_transform(xyz, rpy), dtype)
 
     def transform_to_xyz_rpy(self, transform):
         """
-        Converts a Robot Raconteur Transform to a 3 element position vector and 3 element roll-pitch-yaw vector 
+        Converts a Robot Raconteur Transform to a 3 element position vector and 3 element roll-pitch-yaw vector
         in radians.
 
         :param transform: The Robot Raconteur Transform
         :type transform: com.robotraconteur.geometry.Transform
         :return: The 3 element position vector and 3 element roll-pitch-yaw vector in radians
         :rtype: Tuple[numpy.ndarray, numpy.ndarray]
         """
@@ -467,16 +466,16 @@
         :param rr_named_transform: The Robot Raconteur NamedTransform
         :type rr_named_transform: com.robotraconteur.geometry.NamedTransform
         :return: The general_robotics_toolbox Transform
         :rtype: general_robotics_toolbox.Transform
         """
         R = self.quaternion_to_R(rr_named_transform.transform["rotation"])
         p = self.vector3_to_xyz(rr_named_transform.transform["translation"])
-        return rox.Transform(R,p, _name_from_identifier(rr_named_transform.parent_frame), \
-            _name_from_identifier(rr_named_transform.child_frame))
+        return rox.Transform(R, p, _name_from_identifier(rr_named_transform.parent_frame),
+                             _name_from_identifier(rr_named_transform.child_frame))
 
     def xyz_rpy_to_named_transform(self, xyz, rpy, parent_frame_id, child_frame_id, dtype=np.float64):
         """
         Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
         Robot Raconteur NamedTransform
 
         :param xyz: The 3 element position vector
@@ -488,15 +487,15 @@
         :param child_frame_id: The child frame name
         :type child_frame_id: str
         :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
         :type dtype: com.robotraconteur.geometry.NamedTransform
         :return: The Robot Raconteur NamedTransform
         :rtype: com.robotraconteur.geometry.NamedTransform
         """
-        return self.rox_transform_to_named_transform(self._xyz_rpy_to_rox_transform(xyz,rpy,parent_frame_id,child_frame_id),dtype)
+        return self.rox_transform_to_named_transform(self._xyz_rpy_to_rox_transform(xyz, rpy, parent_frame_id, child_frame_id), dtype)
 
     def named_transform_to_xyz_rpy(self, transform):
         """
         Converts a Robot Raconteur NamedTransform to a 3 element position vector and 3 element roll-pitch-yaw vector
         in radians.
 
         :param transform: The Robot Raconteur NamedTransform
@@ -529,15 +528,15 @@
         :param rr_pose: The Robot Raconteur Pose
         :type rr_pose: com.robotraconteur.geometry.Pose
         :return: The general_robotics_toolbox Transform
         :rtype: general_robotics_toolbox.Transform
         """
         R = self.quaternion_to_R(rr_pose["orientation"])
         p = self.vector3_to_xyz(rr_pose["position"])
-        return rox.Transform(R,p)
+        return rox.Transform(R, p)
 
     def xyz_rpy_to_pose(self, xyz, rpy, dtype=np.float64):
         """
         Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
         Robot Raconteur Pose
 
         :param xyz: The 3 element position vector
@@ -545,15 +544,15 @@
         :param rpy: The 3 element roll-pitch-yaw vector in radians
         :type rpy: numpy.ndarray
         :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
         :type dtype: com.robotraconteur.geometry.Pose
         :return: The Robot Raconteur Pose
         :rtype: com.robotraconteur.geometry.Pose
         """
-        return self.rox_transform_to_pose(self._xyz_rpy_to_rox_transform(xyz,rpy),dtype)
+        return self.rox_transform_to_pose(self._xyz_rpy_to_rox_transform(xyz, rpy), dtype)
 
     def pose_to_xyz_rpy(self, transform):
         """
         Converts a Robot Raconteur Pose to a 3 element position vector and 3 element roll-pitch-yaw vector
 
         :param transform: The Robot Raconteur Pose
         :type transform: com.robotraconteur.geometry.Pose
@@ -587,16 +586,16 @@
         :param rr_named_pose: The Robot Raconteur NamedPose
         :type rr_named_pose: com.robotraconteur.geometry.NamedPose
         :return: The general_robotics_toolbox Transform
         :rtype: general_robotics_toolbox.Transform
         """
         R = self.quaternion_to_R(rr_named_pose.pose["orientation"])
         p = self.vector3_to_xyz(rr_named_pose.pose["position"])
-        return rox.Transform(R,p,_name_from_identifier(rr_named_pose.parent_frame), \
-            _name_from_identifier(rr_named_pose.frame))
+        return rox.Transform(R, p, _name_from_identifier(rr_named_pose.parent_frame),
+                             _name_from_identifier(rr_named_pose.frame))
 
     def xyz_rpy_to_named_pose(self, xyz, rpy, parent_frame_id, child_frame_id, dtype=np.float64):
         """
         Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
         Robot Raconteur NamedPose
 
         :param xyz: The 3 element position vector
@@ -605,15 +604,15 @@
         :type rpy: numpy.ndarray
         :param parent_frame_id: The parent frame identifier
         :type parent_frame_id: str
         :param child_frame_id: The child frame identifier
         :type child_frame_id: str
 
         """
-        return self.rox_transform_to_named_pose(self._xyz_rpy_to_rox_transform(xyz,rpy,parent_frame_id,child_frame_id),dtype)
+        return self.rox_transform_to_named_pose(self._xyz_rpy_to_rox_transform(xyz, rpy, parent_frame_id, child_frame_id), dtype)
 
     def named_pose_to_xyz_rpy(self, transform):
         """
         Convert a Robot Raconteur NamedPose to a 3 element position vector and 3 element roll-pitch-yaw vector in radians
 
         :param transform: The Robot Raconteur NamedPose
         :type transform: com.robotraconteur.geometry.NamedPose
@@ -647,17 +646,17 @@
         Converts a Robot Raconteur SpatialVelocity to a 6 element spatial velocity vector
 
         :param rr_spatial_velocity: The Robot Raconteur SpatialVelocity
         :type rr_spatial_velocity: com.robotraconteur.geometry.SpatialVelocity
         :return: The 6 element spatial velocity vector
         :rtype: numpy.ndarray
         """
-        return np.array([rr_spatial_velocity[0]["angular"]["x"], rr_spatial_velocity[0]["angular"]["y"],\
-            rr_spatial_velocity[0]["angular"]["z"], rr_spatial_velocity[0]["linear"]["x"], \
-            rr_spatial_velocity[0]["linear"]["y"], rr_spatial_velocity[0]["linear"]["z"]])
+        return np.array([rr_spatial_velocity[0]["angular"]["x"], rr_spatial_velocity[0]["angular"]["y"],
+                         rr_spatial_velocity[0]["angular"]["z"], rr_spatial_velocity[0]["linear"]["x"],
+                         rr_spatial_velocity[0]["linear"]["y"], rr_spatial_velocity[0]["linear"]["z"]])
 
     def array_to_spatial_acceleration(self, spatial_acceleration, dtype=np.float64):
         """
         Converts a 6 element spatial acceleration vector to a Robot Raconteur SpatialAcceleration
 
         :param spatial_acceleration: The 6 element spatial acceleration vector
         :type spatial_acceleration: numpy.ndarray
@@ -680,19 +679,18 @@
         Converts a Robot Raconteur SpatialAcceleration to a 6 element spatial acceleration vector
 
         :param rr_spatial_acceleration: The Robot Raconteur SpatialAcceleration
         :type rr_spatial_acceleration: com.robotraconteur.geometry.SpatialAcceleration
         :return: The 6 element spatial acceleration vector
         :rtype: numpy.ndarray
         """
-        return np.array([rr_spatial_acceleration[0]["angular"]["x"], rr_spatial_acceleration[0]["angular"]["y"],\
-            rr_spatial_acceleration[0]["angular"]["z"], rr_spatial_acceleration[0]["linear"]["x"], \
-            rr_spatial_acceleration[0]["linear"]["y"], rr_spatial_acceleration[0]["linear"]["z"]])
+        return np.array([rr_spatial_acceleration[0]["angular"]["x"], rr_spatial_acceleration[0]["angular"]["y"],
+                         rr_spatial_acceleration[0]["angular"]["z"], rr_spatial_acceleration[0]["linear"]["x"],
+                         rr_spatial_acceleration[0]["linear"]["y"], rr_spatial_acceleration[0]["linear"]["z"]])
 
-    
     def array_to_wrench(self, wrench, dtype=np.float64):
         """
         Converts a 6 element wrench vector to a Robot Raconteur Wrench
 
         :param wrench: The 6 element wrench vector
         :type wrench: numpy.ndarray
         :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
@@ -714,12 +712,10 @@
         Converts a Robot Raconteur Wrench to a 6 element wrench vector
 
         :param rr_wrench: The Robot Raconteur Wrench
         :type rr_wrench: com.robotraconteur.geometry.Wrench
         :return: The 6 element wrench vector
         :rtype: numpy.ndarray
         """
-        return np.array([rr_wrench[0]["torque"]["x"], rr_wrench[0]["torque"]["y"],\
-            rr_wrench[0]["torque"]["z"], rr_wrench[0]["force"]["x"], \
-            rr_wrench[0]["force"]["y"], rr_wrench[0]["force"]["z"]])
-
-    
+        return np.array([rr_wrench[0]["torque"]["x"], rr_wrench[0]["torque"]["y"],
+                         rr_wrench[0]["torque"]["z"], rr_wrench[0]["force"]["x"],
+                         rr_wrench[0]["force"]["y"], rr_wrench[0]["force"]["z"]])
```

## RobotRaconteurCompanion/Util/IdentifierUtil.py

```diff
@@ -1,63 +1,64 @@
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 import re
 
 from .UuidUtil import UuidUtil
 
+
 class IdentifierUtil(object):
     """
     Utility class for working with Robot Raconteur identifiers
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
         self._identifier = self._node.GetStructureType("com.robotraconteur.identifier.Identifier", self._client_obj)
         self._uuid_dt = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_obj)
 
-        self._uuid_util = UuidUtil(node,client_obj)
+        self._uuid_util = UuidUtil(node, client_obj)
 
-    def IsIdentifierAnyUuid(self,identifier):
+    def IsIdentifierAnyUuid(self, identifier):
         """
         Check if an identifier is "any" (UUID is all zeros)
 
         :param identifier: The identifier to check
         :type identifier: com.robotraconteur.identifier.Identifier
         :return: True if the identifier is "any"
         :rtype: bool
         """
         if identifier is None or identifier.uuid is None:
             return True
         return np.all(identifier.uuid["uuid_bytes"] == 0)
 
-    def IsIdentifierAnyName(self,identifier):
+    def IsIdentifierAnyName(self, identifier):
         """
         Check if an identifier is "any" (name is empty)
 
         :param identifier: The identifier to check
         :type identifier: com.robotraconteur.identifier.Identifier
         :return: True if the identifier is "any"
         :rtype: bool
         """
         if identifier is None or identifier.name is None:
             return True
         return len(identifier.name) == 0
 
-    def IsIdentifierAny(self,identifier):
+    def IsIdentifierAny(self, identifier):
         """
         Check if an identifier is "any" (UUID is all zeros and name is empty)
 
         :param identifier: The identifier to check
         :type identifier: com.robotraconteur.identifier.Identifier
         :return: True if the identifier is "any"
         :rtype: bool
@@ -69,17 +70,17 @@
         if not self.IsIdentifierAnyName(identifier):
             return False
         return True
 
     def IsIdentifierMatch(self, expected, test):
         """
         Check if two identifiers match
-      
+
         Identifiers have a complex matching rules:
-        
+
         - If both identifiers are "any", they match
         - If either identifier is "any", they match
         - If both identifiers have the same name and UUID, they match
         - If the name is Any for either identifier and UUID matches, they match
         - If the UUID is Any for either identifier and name matches, they match
         - Otherwise, they do not match
 
@@ -88,15 +89,15 @@
         :param test: The test identifier
         :type test: com.robotraconteur.identifier.Identifier
         :return: True if the identifiers match
         :rtype: bool
         """
         if self.IsIdentifierAny(expected) or self.IsIdentifierAny(test):
             return True
-        
+
         name_match = False
         uuid_match = False
 
         if self.IsIdentifierAnyName(expected) or self.IsIdentifierAnyName(test):
             name_match = True
         else:
             if expected.name == test.name:
@@ -106,94 +107,88 @@
             uuid_match = True
         else:
             if np.all(expected.uuid["uuid_bytes"] == test.uuid["uuid_bytes"]):
                 uuid_match = True
 
         return name_match and uuid_match
 
-    def CreateIdentifier(self,name,uuid):
+    def CreateIdentifier(self, name, uuid):
         """
         Create an identifier from a name and UUID
 
         :param name: The name of the identifier
         :type name: str
         :param uuid: The UUID of the identifier
         :type uuid: str
         :return: The created identifier
         :rtype: com.robotraconteur.identifier.Identifier
         """
-        ret = self._identifier()        
+        ret = self._identifier()
         ret.name = name if name is not None else ""
         if uuid is not None:
             ret.uuid = self._uuid_util.ParseUuid(uuid)
         else:
-            ret.uuid = np.zeros((1,),dtype=self._uuid_dt)
+            ret.uuid = np.zeros((1,), dtype=self._uuid_dt)
         return ret
 
-    def CreateIdentifierFromName(self,name):
+    def CreateIdentifierFromName(self, name):
         """
         Create an identifier from a name. The UUID will be all zeros.
 
         :param name: The name of the identifier
         :type name: str
         :return: The created identifier
         :rtype: com.robotraconteur.identifier.Identifier
         """
         assert name is not None
-        ret = self._identifier()        
-        ret.name = name        
-        ret.uuid = np.zeros((1,),dtype=self._uuid_dt)
+        ret = self._identifier()
+        ret.name = name
+        ret.uuid = np.zeros((1,), dtype=self._uuid_dt)
         return ret
 
-    def IdentifierToString(self,identifier):
+    def IdentifierToString(self, identifier):
         """
         Create a string representation of an identifier. The string representation is in the form "name|uuid".
 
         :param identifier: The identifier to convert to a string
         :type identifier: com.robotraconteur.identifier.Identifier
         :return: The string representation of the identifier
         :rtype: str
         """
         if identifier is None:
             return ""
         if not self.IsIdentifierAnyName(identifier) and not self.IsIdentifierAnyUuid(identifier):
             return identifier.name + "|" + self._uuid_util.UuidToString(identifier.uuid)
-        if not self.IsIdentifierAny(identifier):
+        if not self.IsIdentifierAnyName(identifier):
             return identifier.name
         if not self.IsIdentifierAnyUuid(identifier):
-            return identifier.uuid
+            return self._uuid_util.UuidToString(identifier.uuid)
         return ""
 
     def StringToIdentifier(self, string_id):
         """
         Parse a string representation of an identifier. The string representation is in the form "name|uuid".
 
         :param string_id: The string representation of the identifier
         :type string_id: str
         :return: The parsed identifier
         :rtype: com.robotraconteur.identifier.Identifier
         """
         name_regex_str = "(?:[a-zA-Z](?:[a-zA-Z0-9_]*[a-zA-Z0-9])?)(?:\\.[a-zA-Z](?:[a-zA-Z0-9_]*[a-zA-Z0-9])?)*"
         uuid_regex_str = "\\{?[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}?"
-        identifier_regex = "(?:(" + name_regex_str + ")\\|(" + uuid_regex_str + "))|(" + name_regex_str + ")|(" + uuid_regex_str + ")"
+        identifier_regex = "(?:(" + name_regex_str + ")\\|(" + uuid_regex_str + "))|(" + \
+            name_regex_str + ")|(" + uuid_regex_str + ")"
 
         r_res = re.match(identifier_regex, string_id)
         if r_res is None:
             raise RR.InvalidArgumentException("Invalid identifier string")
 
         if r_res.group(1) is not None and r_res.group(2) is not None:
             return self.CreateIdentifier(r_res.group(1), r_res.group(2))
-        
+
         if r_res.group(3) is not None:
             return self.CreateIdentifierFromName(r_res.group(3))
 
         if r_res.group(4) is not None:
             return self.CreateIdentifier("", r_res.group(4))
 
         raise RR.InvalidArgumentException("Invalid identifier string")
-
-
-
-
-        
-
-
```

## RobotRaconteurCompanion/Util/ImageUtil.py

```diff
@@ -1,41 +1,44 @@
+"""
+Utility class to convert between Robot Raconteur Image structures and OpenCV format images. The OpenCV format
+images are typically numpy arrays in monochrom, BGR, or BGRA format.
+
+:param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+:type node: RobotRaconteur.RobotRaconteurNode
+:param client_obj: (optional) The client object to use for finding types. Defaults to None
+:type client_obj: RobotRaconteur.ClientObject
+"""
+
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 
 import sys
 
 try:
     import cv2
 except:
     cv2 = None
 
-"""
-Utility class to convert between Robot Raconteur Image structures and OpenCV format images. The OpenCV format
-images are typically numpy arrays in monochrom, BGR, or BGRA format.
 
-:param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
-:type node: RobotRaconteur.RobotRaconteurNode
-:param client_obj: (optional) The client object to use for finding types. Defaults to None
-:type client_obj: RobotRaconteur.ClientObject
-"""
 class ImageUtil(object):
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
-        
+
         self._image_type = self._node.GetStructureType("com.robotraconteur.image.Image", self._client_obj)
         self._image_info_type = self._node.GetStructureType("com.robotraconteur.image.ImageInfo", self._client_obj)
-        self._compressed_image_type = self._node.GetStructureType("com.robotraconteur.image.CompressedImage", self._client_obj)
+        self._compressed_image_type = self._node.GetStructureType(
+            "com.robotraconteur.image.CompressedImage", self._client_obj)
         self._image_const = self._node.GetConstants("com.robotraconteur.image", self._client_obj)
-        
+
     def image_to_array(self, rr_image):
         """
         Convert a Robot Raconteur Image to an array. The array will be in the format specified by the image encoding.
 
         The following image encoding codes are supported:
 
         - bgr888
@@ -58,24 +61,24 @@
         encodings = self._image_const["ImageEncoding"]
 
         if encoding == encodings["bgr888"]:
             return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 3], order='C')
 
         if encoding == encodings["rgb888"]:
             img1 = rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 3], order='C')
-            return img1[...,::-1].copy()
+            return img1[..., ::-1].copy()
 
         if encoding == encodings["bgra8888"]:
             return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 4], order='C')
 
         if encoding == encodings["rgba8888"]:
             img1 = rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 4], order='C')
             img2 = img1.copy()
-            img2[...,0] = img1[...,2]
-            img2[...,2] = img1[...,0]
+            img2[..., 0] = img1[..., 2]
+            img2[..., 2] = img1[..., 0]
             return img2
 
         if encoding == encodings["mono8"]:
             return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width], order='C')
 
         if encoding == encodings["mono16"] or encoding == encodings["depth_u16"]:
             assert sys.byteorder == "little"
@@ -84,15 +87,15 @@
         if encoding == encodings["mono32"] or encoding == encodings["depth_u32"]:
             assert sys.byteorder == "little"
             return rr_image.data.view(dtype=np.uint32).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
 
         if encoding == encodings["depth_f32"]:
             assert sys.byteorder == "little"
             return rr_image.data.view(dtype=np.float32).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
-        
+
         assert False, f"Unknown image encoding: {encoding}"
 
     def array_to_image(self, arr, encoding):
         """
         Convert a numpy array to a Robot Raconteur Image. The array must be in the format specified by the image encoding.
 
         The following image encoding codes are supported:
@@ -133,16 +136,16 @@
 
         if encoding == "rgb888":
             assert arr.shape[2] == 3
             assert arr.dtype == np.uint8
             rr_image.image_info.encoding = encodings["rgb888"]
             rr_image.image_info.step = rr_image.image_info.width * 3
             rr_image.data = arr.flatten(order="C")
-            rr_image.data[0::3] = arr[...,2].flatten(order="C")
-            rr_image.data[2::3] = arr[...,0].flatten(order="C")
+            rr_image.data[0::3] = arr[..., 2].flatten(order="C")
+            rr_image.data[2::3] = arr[..., 0].flatten(order="C")
             return rr_image
 
         if encoding == "bgra8888":
             assert arr.shape[2] == 4
             assert arr.dtype == np.uint8
             rr_image.image_info.encoding = encodings["bgra8888"]
             rr_image.image_info.step = rr_image.image_info.width * 4
@@ -150,59 +153,59 @@
             return rr_image
 
         if encoding == "rgba8888":
             assert arr.shape[2] == 4
             assert arr.dtype == np.uint8
             rr_image.image_info.encoding = encodings["rgba8888"]
             rr_image.image_info.step = rr_image.image_info.width * 4
-            rr_image.data = np.zeros((arr.size,),dtype=np.uint8)
-            rr_image.data[0::4] = arr[...,2].flatten(order="C")
-            rr_image.data[1::4] = arr[...,1].flatten(order="C")
-            rr_image.data[2::4] = arr[...,0].flatten(order="C")
-            rr_image.data[3::4] = arr[...,3].flatten(order="C")
+            rr_image.data = np.zeros((arr.size,), dtype=np.uint8)
+            rr_image.data[0::4] = arr[..., 2].flatten(order="C")
+            rr_image.data[1::4] = arr[..., 1].flatten(order="C")
+            rr_image.data[2::4] = arr[..., 0].flatten(order="C")
+            rr_image.data[3::4] = arr[..., 3].flatten(order="C")
             return rr_image
 
         if encoding == "mono8":
-            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.ndim == 2 or arr.shape[2] == 1
             assert arr.dtype == np.uint8
             rr_image.image_info.encoding = encodings["mono8"]
             rr_image.image_info.step = rr_image.image_info.width
             rr_image.data = arr.flatten(order="C")
             return rr_image
 
         if encoding == "mono16" or encoding == "depth_u16":
-            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.ndim == 2 or arr.shape[2] == 1
             assert arr.dtype == np.uint16
             assert sys.byteorder == "little"
             rr_image.image_info.encoding = encodings[encoding]
             rr_image.image_info.step = rr_image.image_info.width * 2
             rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
             return rr_image
 
         if encoding == "mono32" or encoding == "depth_u32":
-            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.ndim == 2 or arr.shape[2] == 1
             assert arr.dtype == np.uint32
             assert sys.byteorder == "little"
             rr_image.image_info.encoding = encodings[encoding]
             rr_image.image_info.step = rr_image.image_info.width * 4
             rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
             return rr_image
 
         if encoding == "depth_f32":
-            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.ndim == 2 or arr.shape[2] == 1
             assert arr.dtype == np.float32
             assert sys.byteorder == "little"
             rr_image.image_info.encoding = encodings[encoding]
             rr_image.image_info.step = rr_image.image_info.width * 4
             rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
             return rr_image
 
         assert False, f"Unknown image encoding: {encoding}"
 
-    def array_to_compressed_image_jpg(self, arr, quality = 95):
+    def array_to_compressed_image_jpg(self, arr, quality=95):
         """
         Convert a numpy array to a compressed Robot Raconteur Image in jpg format.
 
         :param arr: The array to convert
         :type arr: numpy.ndarray
         :param quality: The JPEG quality (0-100). Default is 95.
         :type quality: int
@@ -215,15 +218,15 @@
         rr_image_info = self._image_info_type()
 
         rr_image.image_info = rr_image_info
         rr_image_info.width = arr.shape[1]
         rr_image_info.height = arr.shape[0]
         rr_image_info.encoding = self._image_const["ImageEncoding"]["compressed"]
 
-        res, encimg = cv2.imencode(".jpg",arr,[int(cv2.IMWRITE_JPEG_QUALITY), quality])
+        res, encimg = cv2.imencode(".jpg", arr, [int(cv2.IMWRITE_JPEG_QUALITY), quality])
 
         assert res, "Image compression failed"
 
         rr_image.data = encimg
         return rr_image
 
     def array_to_compressed_image_png(self, arr):
@@ -241,27 +244,25 @@
         rr_image_info = self._image_info_type()
 
         rr_image.image_info = rr_image_info
         rr_image_info.width = arr.shape[1]
         rr_image_info.height = arr.shape[0]
         rr_image_info.encoding = self._image_const["ImageEncoding"]["compressed"]
 
-        res, encimg = cv2.imencode(".png",arr)
+        res, encimg = cv2.imencode(".png", arr)
 
         assert res, "Image compression failed"
 
         rr_image.data = encimg
         return rr_image
 
-    def compressed_image_to_array(self,rr_compressed_image,flags=-1):
+    def compressed_image_to_array(self, rr_compressed_image, flags=-1):
         """
         Convert a compressed Robot Raconteur Image to a numpy array. This function uses cv2.imdecode to decode the image.
 
         :param rr_compressed_image: The image to convert
         :type rr_compressed_image: com.robotraconteur.image.CompressedImage
         :param flags: OpenCV flags for decoding. Default is -1.
         :type flags: int
         """
 
-        return cv2.imdecode(rr_compressed_image.data,flags)
-
-    
+        return cv2.imdecode(rr_compressed_image.data, flags)
```

## RobotRaconteurCompanion/Util/InfoFileLoader.py

```diff
@@ -3,60 +3,62 @@
 import numpy as np
 import re
 
 from .LocalIdentifiersManager import LocalIdentifiersManager
 from .IdentifierUtil import IdentifierUtil
 from ..InfoParser import InfoParser
 
+
 class InfoFileLoader(object):
     """
     Utility class to load device info Yaml structures from file
 
     See the Robot Raconteur camera driver for an example of using this class.
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
-        self._info_parser = InfoParser(self._node,self._client_obj)
-        self._id_manager = LocalIdentifiersManager(self._node,self._client_obj)
-        self._id_util = IdentifierUtil(self._node,self._client_obj)
+        self._info_parser = InfoParser(self._node, self._client_obj)
+        self._id_manager = LocalIdentifiersManager(self._node, self._client_obj)
+        self._id_util = IdentifierUtil(self._node, self._client_obj)
 
     def _load_device_identifier(self, info_file, category):
-        
-        if hasattr(info_file,"device_info"):
+
+        if hasattr(info_file, "device_info"):
             if info_file is not None and info_file.device_info is not None and info_file.device_info.device is not None \
-                and not self._id_util.IsIdentifierAnyName(info_file.device_info.device) and \
-                self._id_util.IsIdentifierAnyUuid(info_file.device_info.device):
+                    and not self._id_util.IsIdentifierAnyName(info_file.device_info.device) and \
+                    self._id_util.IsIdentifierAnyUuid(info_file.device_info.device):
 
-                dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(category, info_file.device_info.device.name)
+                dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(
+                    category, info_file.device_info.device.name)
                 info_file.device_info.device = dev_id
-                return True, dev_id,lock_fd
+                return True, dev_id, lock_fd
             return False, None, None
-        elif hasattr(info_file,"device"):
+        elif hasattr(info_file, "device"):
             if info_file is not None and info_file.device \
-                and not self._id_util.IsIdentifierAnyName(info_file.device) and \
-                self._id_util.IsIdentifierAnyUuid(info_file.device):
+                    and not self._id_util.IsIdentifierAnyName(info_file.device) and \
+                    self._id_util.IsIdentifierAnyUuid(info_file.device):
 
                 dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(category, info_file.device.name)
                 info_file.device = dev_id
-                return True, dev_id,lock_fd
+                return True, dev_id, lock_fd
             return False, None, None
         return False, None, None
 
-    def LoadInfoFileFromString(self, info_text, info_type_name, category = "unspecified"):
+    def LoadInfoFileFromString(self, info_text, info_type_name, category="unspecified"):
         """
         Load a device info Yaml structure from a string and assign a device identifier
 
         In most cases the category should be set to "device".
 
         :param info_text: The info Yaml structure to load
         :type info_text: str
@@ -64,18 +66,37 @@
         :type info_type_name: str
         :param category: (optional) The category of the device identifier. Defaults to "unspecified".
         :type category: str
         :return: The loaded info Yaml structure and the device identifier lock file descriptor
         :rtype: tuple
         """
         info = self._info_parser.ParseInfoString(info_text, info_type_name)
-        _, _, fds = self._load_device_identifier(info,category)
+        _, _, fds = self._load_device_identifier(info, category)
+        return info, fds
+
+    def LoadInfoFileFromDict(self, info_dict, info_type_name, category="unspecified"):
+        """
+        Load a device info Yaml structure from a dictionary and assign a device identifier
+
+        In most cases the category should be set to "device".
+
+        :param info_dict: The dictionary containing the info parsed from a Yaml file
+        :type info_dict: dict
+        :param info_type_name: The type name of the info Yaml structure
+        :type info_type_name: str
+        :param category: (optional) The category of the device identifier. Defaults to "unspecified".
+        :type category: str
+        :return: The loaded info Yaml structure and the device identifier lock file descriptor
+        :rtype: tuple
+        """
+        info = self._info_parser.ParseInfoDict(info_dict, info_type_name)
+        _, _, fds = self._load_device_identifier(info, category)
         return info, fds
 
-    def LoadInfoFile(self, file_name, info_type_name, category = "unspecified"):
+    def LoadInfoFile(self, file_name, info_type_name, category="unspecified"):
         """
         Load a device info Yaml structure from a file and assign a device identifier
 
         In most cases the category should be set to "device".
 
         :param file_name: The file name of the info Yaml structure to load
         :type file_name: str
@@ -83,9 +104,9 @@
         :type info_type_name: str
         :param category: (optional) The category of the device identifier. Defaults to "unspecified".
         :type category: str
         :return: The loaded info Yaml structure and the device identifier lock file descriptor
         :rtype: tuple
         """
         info = self._info_parser.ParseInfoFile(file_name, info_type_name)
-        _, _, fds = self._load_device_identifier(info,category)
-        return info, fds
+        _, _, fds = self._load_device_identifier(info, category)
+        return info, fds
```

## RobotRaconteurCompanion/Util/LocalIdentifiersManager.py

```diff
@@ -6,44 +6,48 @@
 import sys
 import RobotRaconteur as RR
 import uuid
 import numpy as np
 import stat
 import errno
 
+
 class _LocalIdentifiersManagerFD(object):
     """
     Class to hold lock on device identifier file
     """
-    def __init__(self,fd):
+
+    def __init__(self, fd):
         self.fd = fd
+
     def __enter__(self):
         pass
 
     def __exit__(self, exc_type, exc_value, traceback):
         if self.fd is not None:
             fd = self.fd
             self.fd = None
             del fd
 
+
 class LocalIdentifiersManager(object):
     """
     Utility class to manage device identifiers and locks
 
     See the Robot Raconteur camera driver for an example of using this class.
 
     Users do not normally need to use this class directly.
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_object: (optional) The client object to use for finding types. Defaults to None
     :type client_object: RobotRaconteur.ClientObject
     """
 
-    def __init__(self,node,client_object = None):
+    def __init__(self, node, client_object=None):
         self._node = node
         self._client_object = client_object
 
     def GetIdentifierForNameAndLock(self, category, name):
         """
         Get a device identifier for a given name and lock the identifier file for exclusive access.
         The category should be "device" for most devices.
@@ -51,28 +55,27 @@
         :param category: The category of the identifier
         :type category: str
         :param name: The name of the identifier
         :type name: str
         :return: The identifier and lock
         :rtype: (RobotRaconteur.Identifier, LocalIdentifiersManagerFD)
         """
-        
-        assert re.match("^[a-zA-Z][a-zA-Z0-9_\\.\\-]*$",name) is not None, "Invalid identifier name"
-        category2=category.lower()
+
+        assert re.match("^[a-zA-Z][a-zA-Z0-9_\\.\\-]*$", name) is not None, "Invalid identifier name"
+        category2 = category.lower()
 
         node_dirs = self._node.GetNodeDirectories()
-        p = RR.GetUuidForNameAndLock(node_dirs,name,["identifiers",category2])
+        p = RR.GetUuidForNameAndLock(node_dirs, name, ["identifiers", category2])
 
         f = p.fd
         f_text = p.uuid.ToString("D")
-        
+
         ident_uuid = uuid.UUID(str(f_text))
 
-        ident_type = self._node.GetStructureType("com.robotraconteur.identifier.Identifier",self._client_object)
-        uuid_dtype = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID",self._client_object)
+        ident_type = self._node.GetStructureType("com.robotraconteur.identifier.Identifier", self._client_object)
+        uuid_dtype = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_object)
         ret = ident_type()
         ret.name = name
-        ret.uuid = np.zeros((1,),dtype=uuid_dtype)
-        ret.uuid["uuid_bytes"] = np.frombuffer(ident_uuid.bytes,dtype=np.uint8)
-        
+        ret.uuid = np.zeros((1,), dtype=uuid_dtype)
+        ret.uuid["uuid_bytes"] = np.frombuffer(ident_uuid.bytes, dtype=np.uint8)
+
         return ret, _LocalIdentifiersManagerFD(f)
-
```

## RobotRaconteurCompanion/Util/RobDef.py

```diff
@@ -1,55 +1,59 @@
 import RobotRaconteur as RR
 import importlib_resources
 
+
 def register_service_type_from_resource(node, package, resource):
     """
     Register a service type from a package resource
 
     :param node: The node to register the service type with
     :type node: RobotRaconteur.RobotRaconteurNode
     :param package: The package containing the resource
     :type package: str
     :param resource: The resource name
     :type resource: str
     """
-    robdef_text = get_service_type_from_resource(package,resource)
+    robdef_text = get_service_type_from_resource(package, resource)
     node.RegisterServiceType(robdef_text)
 
+
 def register_service_types_from_resources(node, package, resources):
     """
     Register a list of service types from a package resource
 
     :param node: The node to register the service types with
     :type node: RobotRaconteur.RobotRaconteurNode
     :param package: The package containing the resource
     :type package: str
     :param resources: The list of resource names
     :type resources: list[str]
     """
-    robdefs_text = get_service_types_from_resources(package,resources)
+    robdefs_text = get_service_types_from_resources(package, resources)
     node.RegisterServiceTypes(robdefs_text)
 
+
 def get_service_type_from_resource(package, resource):
     """
     Return the text of a service type from a package resource
 
     :param package: The package containing the resource
     :type package: str
     :param resource: The resource name
     :type resource: str
     :return: The service type text
     :rtype: str
     """
     ext = ""
     if (importlib_resources.files(package) / (resource + ".robdef")).exists():
-        ext = ".robdef"    
+        ext = ".robdef"
     robdef_text = (importlib_resources.files(package) / (resource + ext)).read_text()
     return robdef_text
 
+
 def get_service_types_from_resources(package, resources):
     """
     Get a list of service type texts from a package resource
 
     :param package: The package containing the resource
     :type package: str
     :param resources: The list of resource names
@@ -60,8 +64,8 @@
     robdefs_text = []
     for resource in resources:
         ext = ""
         if (importlib_resources.files(package) / (resource + ".robdef")).exists():
             ext = ".robdef"
         robdef_text = (importlib_resources.files(package) / (resource + ext)).read_text()
         robdefs_text.append(robdef_text)
-    return robdefs_text
+    return robdefs_text
```

## RobotRaconteurCompanion/Util/RobotUtil.py

```diff
@@ -1,98 +1,100 @@
 import general_robotics_toolbox as rox
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 
-def _check_list(l, error_msg, expected_count = -1):
+
+def _check_list(l, error_msg, expected_count=-1):
     if l is None:
         raise RR.InvalidArgumentException(error_msg)
 
     if expected_count >= 0:
         if len(l) != expected_count:
             raise RR.InvalidArgumentException(error_msg)
 
+
 class RobotUtil:
     """
     Utility class to convert a Robot Raconteur com.robotraconteur.robotics.robot.RobotInfo to
     a general_robotics_toolbox.Robot object.
 
     The RobotInfo is provided by robot drivers and is used to describe the kinematics of the robot.
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
-    def __init__(self, node = None, client_obj = None):
+
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
     def robot_info_to_rox_robot(self, robot_info, chain_number):
         """
         Convert a RobotInfo to a general_robotics_toolbox.Robot object
 
         :param robot_info: The RobotInfo to convert
         :type robot_info: com.robotraconteur.robotics.robot.RobotInfo
-        :param chain_number: The kinematic chain number to convert. For a single arm robot, this is 0. 
+        :param chain_number: The kinematic chain number to convert. For a single arm robot, this is 0.
             For a dual arm robot, this is 0 for the left arm and 1 for the right arm.
         :type chain_number: int
         :return: The converted robot
         :rtype: general_robotics_toolbox.Robot
         """
         _check_list(robot_info.chains, f"could not find kinematic chain number {chain_number}")
-        if chain_number >= len(robot_info.chains): 
+        if chain_number >= len(robot_info.chains):
             raise RR.InvalidArgumentException(f"invalid kinematic chain number {chain_number}")
 
         chain = robot_info.chains[chain_number]
         joint_count = len(chain.joint_numbers)
-        for i in range(1,joint_count):
-            if chain.joint_numbers[i-1] >= chain.joint_numbers[i]:
+        for i in range(1, joint_count):
+            if chain.joint_numbers[i - 1] >= chain.joint_numbers[i]:
                 raise RR.InvalidArgumentException(f"joint numbers must be increasing in chain number {chain_number}")
 
             if chain.joint_numbers[i] >= len(robot_info.joint_info):
                 raise RR.InvalidArgumentException(f"joint number out of bounds in chain number {chain_number}")
 
         _check_list(chain.H, f"invalid shape for H in chain number {chain_number}", joint_count)
         _check_list(chain.P, f"invalid shape for P in chain number {chain_number}", joint_count + 1)
 
-        H = np.zeros((3, joint_count),dtype=np.float64)
+        H = np.zeros((3, joint_count), dtype=np.float64)
         for i in range(joint_count):
             H[0, i] = chain.H[i]["x"]
             H[1, i] = chain.H[i]["y"]
             H[2, i] = chain.H[i]["z"]
 
-        P = np.zeros((3, joint_count + 1),dtype=np.float64)
-        for i in range(joint_count+1):
+        P = np.zeros((3, joint_count + 1), dtype=np.float64)
+        for i in range(joint_count + 1):
             P[0, i] = chain.P[i]["x"]
             P[1, i] = chain.P[i]["y"]
             P[2, i] = chain.P[i]["z"]
 
-        joint_type = [0]*joint_count
-        joint_lower_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_upper_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_vel_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_acc_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_names = [None]*joint_count
+        joint_type = [0] * joint_count
+        joint_lower_limit = np.zeros((joint_count,), dtype=np.float64)
+        joint_upper_limit = np.zeros((joint_count,), dtype=np.float64)
+        joint_vel_limit = np.zeros((joint_count,), dtype=np.float64)
+        joint_acc_limit = np.zeros((joint_count,), dtype=np.float64)
+        joint_names = [None] * joint_count
 
         for i in range(joint_count):
             j = robot_info.joint_info[i]
             if j.joint_type == 1:
                 # Revolute joint
                 joint_type[i] = 0
             elif j.joint_type == 3:
                 # Prismatic joint
                 joint_type[i] = 1
             else:
-                raise RR.InvalidArgumentException(f"invalid joint type: {j.joint_type}");                        
-            
-            
+                raise RR.InvalidArgumentException(f"invalid joint type: {j.joint_type}")
+
             if j.joint_limits is None:
                 raise RR.InvalidArgumentException("joint_limits must not be null")
             joint_lower_limit[i] = j.joint_limits.lower
             joint_upper_limit[i] = j.joint_limits.upper
             joint_vel_limit[i] = j.joint_limits.velocity
             joint_acc_limit[i] = j.joint_limits.acceleration
             if j.joint_identifier is not None:
@@ -103,15 +105,15 @@
         root_link_name = None
         if chain.link_identifiers is not None and len(chain.link_identifiers) > 0 and chain.link_identifiers[0] is not None:
             root_link_name = chain.link_identifiers[0].name
 
         tip_link_name = None
         if chain.flange_identifier is not None:
             tip_link_name = chain.flange_identifier.name
-        
+
         flange_q = chain.flange_pose["orientation"]
         flange_p = chain.flange_pose["position"]
 
         r_flange = rox.q2R(self._node.NamedArrayToArray(flange_q).flatten())
         p_flange = np.array(self._node.NamedArrayToArray(flange_p).flatten())
 
         T_base = None
@@ -121,13 +123,11 @@
                 robot_origin_pose = robot_device_info.device_origin_pose
                 if robot_origin_pose.pose is not None:
                     r_base = rox.q2R(self._node.NamedArrayToArray(robot_origin_pose.pose["orientation"]).flatten())
                     p_base = np.array(self._node.NamedArrayToArray(robot_origin_pose.pose["position"]).flatten())
                     T_base = rox.Transform(r_base, p_base)
 
         rox_robot = rox.Robot(H, P, joint_type, joint_lower_limit, joint_upper_limit, joint_vel_limit,
-            joint_acc_limit, joint_names=joint_names, root_link_name=root_link_name, tip_link_name=tip_link_name,
-            T_flange=rox.Transform(r_flange,p_flange), T_base=T_base)
+                              joint_acc_limit, joint_names=joint_names, root_link_name=root_link_name, tip_link_name=tip_link_name,
+                              T_flange=rox.Transform(r_flange, p_flange), T_base=T_base)
 
         return rox_robot
-            
-
```

## RobotRaconteurCompanion/Util/RobustFunctionCaller.py

```diff
@@ -1,12 +1,13 @@
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import threading
 import traceback
 
+
 class RobustPollingAsyncFunctionCaller:
     """
     Class to call function that is polled periodically, or
     when requested
 
     :param f: The function to call
     :type f: callable
@@ -24,15 +25,15 @@
     :type error_handler: callable
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, f, f_args, retry_backoff = 1, max_retry_attempts = 10, poll_interval = 30, call_timeout = 1, error_handler = None, node = None, client_obj = None):
+    def __init__(self, f, f_args, retry_backoff=1, max_retry_attempts=10, poll_interval=30, call_timeout=1, error_handler=None, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
         self._f = f
@@ -58,16 +59,17 @@
 
     @property
     def poll_data(self):
         """
         Returns the current polled data
         """
         return self._poll_data
+
     @poll_data.setter
-    def poll_data(self,value):
+    def poll_data(self, value):
         assert value == self._poll_data
 
     def request_poll(self):
         """
         Call to request a poll
         """
 
@@ -77,50 +79,49 @@
                 return
             else:
                 self._do_refresh()
 
     def _do_refresh(self):
         try:
             if len(self._f_args) == 0:
-                self._f(self._refresh_handler,self._call_timeout)
+                self._f(self._refresh_handler, self._call_timeout)
             else:
-                self._f(*self._f_args,self._refresh_handler,self._call_timeout)
-    
+                self._f(*self._f_args, self._refresh_handler, self._call_timeout)
+
             self._refreshing = True
         except Exception as e:
             try:
                 if self._error_handler is not None:
                     self._error_handler(e)
             except:
                 traceback.print_exc()
             try:
                 self._refresh_retry()
             except RR.InvalidOperationException:
                 pass
 
-
     def _refresh_handler(self, val, err):
         with self._lock:
             if err is not None:
                 # TODO: log internal error
                 self._refresh_retry()
                 return
             self._retry_attempts = 0
-        
+
         try:
             self._poll_data.fire(val)
         except Exception as e:
             try:
                 if self._error_handler is not None:
                     self._error_handler(e)
             except:
                 traceback.print_exc()
 
         with self._lock:
-            if self._refresh_requested:                
+            if self._refresh_requested:
                 self._refresh_retry()
             else:
                 self._refreshing = False
 
     def _refresh_retry(self):
         if self._retry_attempts >= self._max_retry_attempts:
             return
@@ -142,8 +143,8 @@
         self.request_poll()
 
     def close(self):
         """
         Close the polling function caller
         """
         self._poll_timer.Stop()
-        self._poll_timer = None
+        self._poll_timer = None
```

## RobotRaconteurCompanion/Util/SensorDataUtil.py

```diff
@@ -1,35 +1,38 @@
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 
 from .DateTimeUtil import DateTimeUtil
 
+
 class SensorDataUtil(object):
     """
     Fill in a SensorDataHeader with the current time and sequence number
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
 
-        self._sensordataheader = self._node.GetStructureType("com.robotraconteur.sensordata.SensorDataHeader", self._client_obj)
-        self._sourceinfo = self._node.GetStructureType("com.robotraconteur.sensordata.SensorDataSourceInfo", self._client_obj)
+        self._sensordataheader = self._node.GetStructureType(
+            "com.robotraconteur.sensordata.SensorDataHeader", self._client_obj)
+        self._sourceinfo = self._node.GetStructureType(
+            "com.robotraconteur.sensordata.SensorDataSourceInfo", self._client_obj)
         self._pose_dt = self._node.GetNamedArrayDType("com.robotraconteur.geometry.Pose")
-        
-        self._datetime_util = DateTimeUtil(node,client_obj)
+
+        self._datetime_util = DateTimeUtil(node, client_obj)
 
     def FillSensorDataHeader(self, device_info, seqno):
         """
         Fill in a SensorDataHeader with the current time and sequence number
 
         :param device_info: The device info to use for the source info
         :type device_info: com.robotraconteur.device.DeviceInfo
@@ -37,10 +40,9 @@
         :type seqno: int
         """
         ret = self._sensordataheader()
         ret.seqno = seqno
         ret.ts = self._datetime_util.TimeSpec2Now(device_info)
         ret.source_info = self._sourceinfo()
         ret.source_info.source = device_info.device
-        ret.source_info.source_world_pose = np.zeros((1,),self._pose_dt)
+        ret.source_info.source_world_pose = np.zeros((1,), self._pose_dt)
         return ret
-
```

## RobotRaconteurCompanion/Util/TaskGenerator.py

```diff
@@ -1,287 +1,295 @@
-import RobotRaconteur as RR
-import threading
-
-class AsyncTaskGenerator:
-    """
-    Base class for asynchronous task generators
-
-    Base class for asynchronous task generators. This utility class is used
-    to help implement generators that represent long running operations.
-
-    Subclasses should override the following functions:
-
-    * StartTask() - Called when the generator is started
-    * FillStatus() - Called to fill the next intermediate status report
-    * CloseRequested() - Called when the generator is closed
-    * AbortRequested() - Called when the generator is aborted
-
-    The operation should call SetResult() or SetResultException() when the
-    operation is complete. The generator will then return the result to the
-    caller.
-
-    :param node: The Robot Raconteur node for the generator
-    :type node: RobotRaconteur.RobotRaconteurNode
-    :param status_type: The status type for the generator. Used to create the status report structure
-    :type status_type: type
-    :param next_timeout: The timeout to return from the Next() function in seconds
-    :type next_timeout: float
-    :param watchdog_timeout: The timeout for the watchdog in seconds. -1 to disable.
-    :type watchdog_timeout: float
-    """
-    def __init__(self, node, status_type, next_timeout, watchdog_timeout):
-        self._node = node
-        self._status_type = status_type
-        self._next_timer = None
-        self._watchdog_timer = None
-        self._started = False
-        self._closed = False
-        self._aborted = False
-        self._completed = False
-        self._task_completed = False
-        self._next_timeout = next_timeout
-        self._watchdog_timeout = watchdog_timeout
-        self._this_lock = threading.Lock()
-        self._next_handler = None
-        self._result = None
-        self._exception_result = None
-        self._send_update = False
-        self._action_const = node.GetConstants("com.robotraconteur.action")
-
-    def AsyncNext(self,handler):
-        with self._this_lock:
-            if self._watchdog_timeout is not None:
-                try:
-                    self._watchdog_timer.Stop()
-                except Exception: pass
-                self._watchdog_timer = None
-            if self._aborted:
-                raise RR.OperationAbortedException("Operation aborted")
-            if (self._closed and not self._started) or self._completed:
-                raise RR.StopIterationException("")
-            if not self._started:
-                self.StartTask()
-                self._started = True
-                ret = self._status_type()
-                ret.action_status = self._action_const["ActionStatusCode"]["running"]
-                handler(ret, None)
-                return
-            
-            if self._next_handler is not None:
-                raise RR.InvalidOperationException("Next call already in progress")
-            
-            if self._task_completed:
-                self._complete_gen(handler)
-                return
-            
-            if (self._send_update):
-                self._send_update = False
-                ret = self._status_type()
-                ret.action_status = self._action_const["ActionStatusCode"]["running"]
-                self.FillStatus(ret)
-                handler(ret, None)
-                return
-            
-            self._next_handler = handler
-            self._next_timer = self._node.CreateTimer(self._next_timeout, self._next_timer_handler, True)
-            self._next_timer.Start()
-
-            if self._watchdog_timeout > 0:
-                self._watchdog_timer = self._node.CreateTimer(self._watchdog_timeout, self._watchdog_timer_handler, True)
-                self._watchdog_timer.Start()
-
-    def AsyncAbort(self, handler, timeout):
-        with self._this_lock:
-            if self._closed or self._aborted:
-                handler(None)
-                return
-            self._aborted = True
-            if self._started:
-                self.AbortRequested()
-        handler(None)
-
-    def AsyncClose(self, handler, timeout):
-        with self._this_lock:
-            if self._closed or self._aborted:
-                handler(None)
-                return            
-            self._closed = True
-            if self._started:
-                self.CloseRequested()
-        handler(None)
-            
-
-    def SetResult(self, result):
-        """
-        Set the result of the generator
-
-        This method sets the result of the generator. The generator will return
-        the result to the caller.
-
-        :param result: The result to return
-        """
-        with self._this_lock:
-            if self._task_completed: return
-            self._result = result
-            self._do_result()
-
-    def SetResultException(self, exp):
-        """
-        Set the exception result of the generator
-
-        This method sets the exception result of the generator. The generator will return
-        the exception to the caller.
-
-        :param exp: The exception to return
-        """
-        with self._this_lock:
-            if self._task_completed: return
-            self._exception_result = exp
-            self._do_result()
-
-    def _do_result(self):
-        self._task_completed = True
-        h = self._next_handler
-        self._next_handler = None
-        if h is not None:
-            try:
-                self._next_timer.Stop()
-            except Exception: pass
-            self._next_timer = None
-            self._complete_gen(h)
-            return
-        
-    def _complete_gen(self, handler):
-        self._completed = True
-        if self._exception_result is not None:
-            exp = self._exception_result
-            self._exception_result = None
-            handler(None, exp)
-            return
-        ret = self._result
-        self._result = None
-        handler(ret, None)
-
-    def SendUpdate(self):
-        """
-        Send an update to the caller
-
-        This method triggers Next() to return an intermediate status report. Override
-        FillStatus() to fill the status report.
-        """
-        with self._this_lock:
-            if self._task_completed or self._aborted or self._closed: 
-                return
-            
-            if self._next_handler is None:
-                self._send_update = True
-                return
-            
-            try:
-                self._next_timer.Stop()
-            except Exception: pass
-
-            self._do_send_update()
-
-    def StartTask(self):
-        """
-        Start the task
-
-        This method is called when the generator is started. Subclasses should
-        override this method to start the task.
-        """
-        raise NotImplementedError("")
-    
-    def CloseRequested(self):
-        """
-        This method is called when a close request is received.
-        """
-        pass
-
-    def AbortRequested(self):
-        """
-        This method is called when an abort request is received.
-        """
-        pass
-
-    def FillStatus(self, status):
-        """
-        This method is called to fill the next status report
-
-        This method is called to fill the next status report. Subclasses should
-        override this method to fill the next status report.
-
-        :param status: The status report to fill
-        """
-        pass
-
-    def _next_timer_handler(self, evt):
-        with self._this_lock:
-            self._do_send_update()
-
-    def _do_send_update(self):
-        h = self._next_handler
-        self._next_handler = None
-        if h is not None:
-            ret = self._status_type()
-            ret.action_status = self._action_const["ActionStatusCode"]["running"]
-            self.FillStatus(ret)
-            h(ret, None)
-            return
-        
-    def _watchdog_timer_handler(self, evt):
-        with self._this_lock:
-            if evt.stopped: return
-            if self._task_completed: return
-            self._aborted = True
-            self.AbortRequested()    
-
-
-class SyncTaskGenerator(AsyncTaskGenerator):
-    """
-    Base class for synchronous task generators
-
-    This class is derived from the AsyncTaskGenerator class and provides a framework for generating synchronous tasks.
-    It allows the user to define a RunTask() function that performs the actual task and returns a result of type StatusType.
-    The task is executed in a separate thread and the result is set using the SetResult() function.
-    If an exception occurs during task execution, it is caught and converted to a RobotRaconteurException, which is then set as the result exception.
-
-    The user should override the RunTask() function to perform the actual task. The StartTask(),
-    SetResult(), and SetResultException() functions should not be called by the user.
-
-    :param node: The Robot Raconteur node for the generator
-    :type node: RobotRaconteur.RobotRaconteurNode
-    :param status_type: The status type for the generator. Used to create the status report structure
-    :type status_type: type
-    :param next_timeout: The timeout to return from the Next() function in seconds
-    :type next_timeout: float
-    :param watchdog_timeout: The timeout for the watchdog in seconds. -1 to disable.
-    :type watchdog_timeout: float
-    """
-    def __init__(self, node, status_type, next_timeout, watchdog_timeout):
-        super().__init__(node, status_type, next_timeout, watchdog_timeout)
-
-        self._thread = None
-
-    def RunTask(self):
-        """
-        Pure virtual function to be implemented by the user.
-
-        This function should perform the actual task and return a result of type StatusType.
-
-        :return: The result of the task.
-        :rtype: status_type
-        """
-        raise NotImplementedError("RunTask not implemented")
-    
-    def run_task_thread(self):
-        try:
-            ret = self.RunTask()
-            self.SetResult(ret)
-        except Exception as exp:
-            self.SetResultException(exp)
-
-    def StartTask(self):
-        self._thread = threading.Thread(target=self.run_task_thread)
-        self._thread.start()
-
-
+import RobotRaconteur as RR
+import threading
+
+
+class AsyncTaskGenerator:
+    """
+    Base class for asynchronous task generators
+
+    Base class for asynchronous task generators. This utility class is used
+    to help implement generators that represent long running operations.
+
+    Subclasses should override the following functions:
+
+    * StartTask() - Called when the generator is started
+    * FillStatus() - Called to fill the next intermediate status report
+    * CloseRequested() - Called when the generator is closed
+    * AbortRequested() - Called when the generator is aborted
+
+    The operation should call SetResult() or SetResultException() when the
+    operation is complete. The generator will then return the result to the
+    caller.
+
+    :param node: The Robot Raconteur node for the generator
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param status_type: The status type for the generator. Used to create the status report structure
+    :type status_type: type
+    :param next_timeout: The timeout to return from the Next() function in seconds
+    :type next_timeout: float
+    :param watchdog_timeout: The timeout for the watchdog in seconds. -1 to disable.
+    :type watchdog_timeout: float
+    """
+
+    def __init__(self, node, status_type, next_timeout, watchdog_timeout):
+        self._node = node
+        self._status_type = status_type
+        self._next_timer = None
+        self._watchdog_timer = None
+        self._started = False
+        self._closed = False
+        self._aborted = False
+        self._completed = False
+        self._task_completed = False
+        self._next_timeout = next_timeout
+        self._watchdog_timeout = watchdog_timeout
+        self._this_lock = threading.Lock()
+        self._next_handler = None
+        self._result = None
+        self._exception_result = None
+        self._send_update = False
+        self._action_const = node.GetConstants("com.robotraconteur.action")
+
+    def AsyncNext(self, handler):
+        with self._this_lock:
+            if self._watchdog_timeout is not None:
+                try:
+                    self._watchdog_timer.Stop()
+                except Exception:
+                    pass
+                self._watchdog_timer = None
+            if self._aborted:
+                raise RR.OperationAbortedException("Operation aborted")
+            if (self._closed and not self._started) or self._completed:
+                raise RR.StopIterationException("")
+            if not self._started:
+                self.StartTask()
+                self._started = True
+                ret = self._status_type()
+                ret.action_status = self._action_const["ActionStatusCode"]["running"]
+                handler(ret, None)
+                return
+
+            if self._next_handler is not None:
+                raise RR.InvalidOperationException("Next call already in progress")
+
+            if self._task_completed:
+                self._complete_gen(handler)
+                return
+
+            if (self._send_update):
+                self._send_update = False
+                ret = self._status_type()
+                ret.action_status = self._action_const["ActionStatusCode"]["running"]
+                self.FillStatus(ret)
+                handler(ret, None)
+                return
+
+            self._next_handler = handler
+            self._next_timer = self._node.CreateTimer(self._next_timeout, self._next_timer_handler, True)
+            self._next_timer.Start()
+
+            if self._watchdog_timeout > 0:
+                self._watchdog_timer = self._node.CreateTimer(
+                    self._watchdog_timeout, self._watchdog_timer_handler, True)
+                self._watchdog_timer.Start()
+
+    def AsyncAbort(self, handler, timeout):
+        with self._this_lock:
+            if self._closed or self._aborted:
+                handler(None)
+                return
+            self._aborted = True
+            if self._started:
+                self.AbortRequested()
+        handler(None)
+
+    def AsyncClose(self, handler, timeout):
+        with self._this_lock:
+            if self._closed or self._aborted:
+                handler(None)
+                return
+            self._closed = True
+            if self._started:
+                self.CloseRequested()
+        handler(None)
+
+    def SetResult(self, result):
+        """
+        Set the result of the generator
+
+        This method sets the result of the generator. The generator will return
+        the result to the caller.
+
+        :param result: The result to return
+        """
+        with self._this_lock:
+            if self._task_completed:
+                return
+            self._result = result
+            self._do_result()
+
+    def SetResultException(self, exp):
+        """
+        Set the exception result of the generator
+
+        This method sets the exception result of the generator. The generator will return
+        the exception to the caller.
+
+        :param exp: The exception to return
+        """
+        with self._this_lock:
+            if self._task_completed:
+                return
+            self._exception_result = exp
+            self._do_result()
+
+    def _do_result(self):
+        self._task_completed = True
+        h = self._next_handler
+        self._next_handler = None
+        if h is not None:
+            try:
+                self._next_timer.Stop()
+            except Exception:
+                pass
+            self._next_timer = None
+            self._complete_gen(h)
+            return
+
+    def _complete_gen(self, handler):
+        self._completed = True
+        if self._exception_result is not None:
+            exp = self._exception_result
+            self._exception_result = None
+            handler(None, exp)
+            return
+        ret = self._result
+        self._result = None
+        handler(ret, None)
+
+    def SendUpdate(self):
+        """
+        Send an update to the caller
+
+        This method triggers Next() to return an intermediate status report. Override
+        FillStatus() to fill the status report.
+        """
+        with self._this_lock:
+            if self._task_completed or self._aborted or self._closed:
+                return
+
+            if self._next_handler is None:
+                self._send_update = True
+                return
+
+            try:
+                self._next_timer.Stop()
+            except Exception:
+                pass
+
+            self._do_send_update()
+
+    def StartTask(self):
+        """
+        Start the task
+
+        This method is called when the generator is started. Subclasses should
+        override this method to start the task.
+        """
+        raise NotImplementedError("")
+
+    def CloseRequested(self):
+        """
+        This method is called when a close request is received.
+        """
+        pass
+
+    def AbortRequested(self):
+        """
+        This method is called when an abort request is received.
+        """
+        pass
+
+    def FillStatus(self, status):
+        """
+        This method is called to fill the next status report
+
+        This method is called to fill the next status report. Subclasses should
+        override this method to fill the next status report.
+
+        :param status: The status report to fill
+        """
+        pass
+
+    def _next_timer_handler(self, evt):
+        with self._this_lock:
+            self._do_send_update()
+
+    def _do_send_update(self):
+        h = self._next_handler
+        self._next_handler = None
+        if h is not None:
+            ret = self._status_type()
+            ret.action_status = self._action_const["ActionStatusCode"]["running"]
+            self.FillStatus(ret)
+            h(ret, None)
+            return
+
+    def _watchdog_timer_handler(self, evt):
+        with self._this_lock:
+            if evt.stopped:
+                return
+            if self._task_completed:
+                return
+            self._aborted = True
+            self.AbortRequested()
+
+
+class SyncTaskGenerator(AsyncTaskGenerator):
+    """
+    Base class for synchronous task generators
+
+    This class is derived from the AsyncTaskGenerator class and provides a framework for generating synchronous tasks.
+    It allows the user to define a RunTask() function that performs the actual task and returns a result of type StatusType.
+    The task is executed in a separate thread and the result is set using the SetResult() function.
+    If an exception occurs during task execution, it is caught and converted to a RobotRaconteurException, which is then set as the result exception.
+
+    The user should override the RunTask() function to perform the actual task. The StartTask(),
+    SetResult(), and SetResultException() functions should not be called by the user.
+
+    :param node: The Robot Raconteur node for the generator
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param status_type: The status type for the generator. Used to create the status report structure
+    :type status_type: type
+    :param next_timeout: The timeout to return from the Next() function in seconds
+    :type next_timeout: float
+    :param watchdog_timeout: The timeout for the watchdog in seconds. -1 to disable.
+    :type watchdog_timeout: float
+    """
+
+    def __init__(self, node, status_type, next_timeout, watchdog_timeout):
+        super().__init__(node, status_type, next_timeout, watchdog_timeout)
+
+        self._thread = None
+
+    def RunTask(self):
+        """
+        Pure virtual function to be implemented by the user.
+
+        This function should perform the actual task and return a result of type StatusType.
+
+        :return: The result of the task.
+        :rtype: status_type
+        """
+        raise NotImplementedError("RunTask not implemented")
+
+    def run_task_thread(self):
+        try:
+            ret = self.RunTask()
+            self.SetResult(ret)
+        except Exception as exp:
+            self.SetResultException(exp)
+
+    def StartTask(self):
+        self._thread = threading.Thread(target=self.run_task_thread)
+        self._thread.start()
```

## RobotRaconteurCompanion/Util/TestFixtures.py

```diff
@@ -1,118 +1,119 @@
-import RobotRaconteur as RR
-
-from .RobDef import register_service_types_from_resources
-from ..StdRobDef import RegisterStdRobDefServiceTypes
-
-class IntraTaskFixture:
-    """
-    A test fixture for intra-process testing using Robot Raconteur.
-
-    The IntraTestFixture class provides a convenient way to set up and tear down
-    the necessary components for intra-process testing using Robot Raconteur.
-    It initializes client and server nodes, registers transport, service types,
-    and provides methods to register services and connect to services.
-
-    To use this test fixture, create an instance of IntraTestFixture in your test
-    and call the necessary methods to set up the test environment. The fixture will
-    automatically clean up the resources when it goes out of scope.
-
-    :ivar client_node: The client node
-    :vartype client_node: RobotRaconteur.RobotRaconteurNode
-    :ivar server_node: The server node
-    :vartype server_node: RobotRaconteur.RobotRaconteurNode
-    :ivar client_transport: The client transport
-    :vartype client_transport: RobotRaconteur.IntraTransport
-    :ivar server_transport: The server transport
-    :vartype server_transport: RobotRaconteur.IntraTransport
-    """
-    def __init__(self):
-        self.client_node = RR.RobotRaconteurNode()
-        self.server_node = RR.RobotRaconteurNode()
-
-        self.client_node.SetNodeName("client_node")
-        self.server_node.SetNodeName("server_node")
-
-        self.client_node.Init()
-        self.server_node.Init()
-
-        self.client_transport = RR.IntraTransport(self.client_node)
-        self.server_transport = RR.IntraTransport(self.server_node)
-
-        self.client_node.RegisterTransport(self.client_transport)
-        self.server_node.RegisterTransport(self.server_transport)
-
-        self.client_transport.StartClient()
-        self.server_transport.StartServer()
-
-    def register_service_types_text(self, robdef_text):
-        """
-        Register service types from text
-
-        :param robdef_text: The service type text
-        :type robdef_text: str
-        """
-        #self.client_node.RegisterServiceTypes(robdef_text)
-        self.server_node.RegisterServiceTypes(robdef_text)
-
-    def register_service_types_from_resources(self, package, resources):
-        """
-        Register service types from resources
-
-        :param package: The package containing the resource
-        :type package: str
-        :param resources: The list of resource names
-        :type resources: list[str]
-        """
-
-        #register_service_types_from_resources(self.client_node, package, resources)
-        register_service_types_from_resources(self.server_node, package, resources)
-
-    def register_service(self, name, objtype, obj):
-        """
-        Register a service
-
-        :param name: The service name
-        :type name: str
-        :param objtype: The service object Robot Raconteur type
-        :type objtype: str
-        :param obj: The service object
-        :type obj: object
-        """
-        self.server_node.RegisterService(name, objtype, obj)
-
-    def register_standard_service_types(self):
-        """
-        Register standard service types
-        """
-        #RegisterStdRobDefServiceTypes(self.client_node)
-        RegisterStdRobDefServiceTypes(self.server_node)
-
-    def connect_service(self, url):
-        """
-        Connect to a service
-
-        :param url: The service URL
-        :type url: str
-        :return: The connected service
-        :rtype: object
-        """
-        return self.client_node.ConnectService(url)
-    
-    def shutdown(self):
-        """
-        Shutdown the fixture
-        """
-        if self.client_node is None:
-            return
-        self.client_node.Shutdown()
-        self.server_node.Shutdown()
-
-        self.client_node = None
-        self.server_node = None
-
-    def __enter__(self):
-        return self
-    
-    def __exit__(self, exc_type, exc_value, traceback):
-        self.shutdown()
-        
+import RobotRaconteur as RR
+
+from .RobDef import register_service_types_from_resources
+from ..StdRobDef import RegisterStdRobDefServiceTypes
+
+
+class IntraTaskFixture:
+    """
+    A test fixture for intra-process testing using Robot Raconteur.
+
+    The IntraTestFixture class provides a convenient way to set up and tear down
+    the necessary components for intra-process testing using Robot Raconteur.
+    It initializes client and server nodes, registers transport, service types,
+    and provides methods to register services and connect to services.
+
+    To use this test fixture, create an instance of IntraTestFixture in your test
+    and call the necessary methods to set up the test environment. The fixture will
+    automatically clean up the resources when it goes out of scope.
+
+    :ivar client_node: The client node
+    :vartype client_node: RobotRaconteur.RobotRaconteurNode
+    :ivar server_node: The server node
+    :vartype server_node: RobotRaconteur.RobotRaconteurNode
+    :ivar client_transport: The client transport
+    :vartype client_transport: RobotRaconteur.IntraTransport
+    :ivar server_transport: The server transport
+    :vartype server_transport: RobotRaconteur.IntraTransport
+    """
+
+    def __init__(self):
+        self.client_node = RR.RobotRaconteurNode()
+        self.server_node = RR.RobotRaconteurNode()
+
+        self.client_node.SetNodeName("client_node")
+        self.server_node.SetNodeName("server_node")
+
+        self.client_node.Init()
+        self.server_node.Init()
+
+        self.client_transport = RR.IntraTransport(self.client_node)
+        self.server_transport = RR.IntraTransport(self.server_node)
+
+        self.client_node.RegisterTransport(self.client_transport)
+        self.server_node.RegisterTransport(self.server_transport)
+
+        self.client_transport.StartClient()
+        self.server_transport.StartServer()
+
+    def register_service_types_text(self, robdef_text):
+        """
+        Register service types from text
+
+        :param robdef_text: The service type text
+        :type robdef_text: str
+        """
+        # self.client_node.RegisterServiceTypes(robdef_text)
+        self.server_node.RegisterServiceTypes(robdef_text)
+
+    def register_service_types_from_resources(self, package, resources):
+        """
+        Register service types from resources
+
+        :param package: The package containing the resource
+        :type package: str
+        :param resources: The list of resource names
+        :type resources: list[str]
+        """
+
+        # register_service_types_from_resources(self.client_node, package, resources)
+        register_service_types_from_resources(self.server_node, package, resources)
+
+    def register_service(self, name, objtype, obj):
+        """
+        Register a service
+
+        :param name: The service name
+        :type name: str
+        :param objtype: The service object Robot Raconteur type
+        :type objtype: str
+        :param obj: The service object
+        :type obj: object
+        """
+        return self.server_node.RegisterService(name, objtype, obj)
+
+    def register_standard_service_types(self):
+        """
+        Register standard service types
+        """
+        # RegisterStdRobDefServiceTypes(self.client_node)
+        RegisterStdRobDefServiceTypes(self.server_node)
+
+    def connect_service(self, url):
+        """
+        Connect to a service
+
+        :param url: The service URL
+        :type url: str
+        :return: The connected service
+        :rtype: object
+        """
+        return self.client_node.ConnectService(url)
+
+    def shutdown(self):
+        """
+        Shutdown the fixture
+        """
+        if self.client_node is None:
+            return
+        self.client_node.Shutdown()
+        self.server_node.Shutdown()
+
+        self.client_node = None
+        self.server_node = None
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        self.shutdown()
```

## RobotRaconteurCompanion/Util/UuidUtil.py

```diff
@@ -1,43 +1,44 @@
 import RobotRaconteur as RR
 RRN = RR.RobotRaconteurNode.s
 import numpy as np
 import uuid as py_uuid
 
+
 class UuidUtil(object):
     """
     Utility class for working with Robot Raconteur UUIDs
 
     :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
     :type node: RobotRaconteur.RobotRaconteurNode
     :param client_obj: (optional) The client object to use for finding types. Defaults to None
     :type client_obj: RobotRaconteur.ClientObject
     """
 
-    def __init__(self, node = None, client_obj = None):
+    def __init__(self, node=None, client_obj=None):
         if node is None:
             self._node = RRN
         else:
             self._node = node
         self._client_obj = client_obj
-        
+
         self._uuid_dt = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_obj)
 
     def UuidFromPyUuid(self, py_uuid):
         """
         Create a Robot Raconteur UUID from a Python UUID
 
         :param py_uuid: The Python UUID to convert
         :type py_uuid: uuid.UUID
         :return: The Robot Raconteur UUID
         :rtype: com.robotraconteur.uuid.UUID
         """
-        ret_bytes = np.frombuffer(py_uuid.bytes,dtype=np.uint8)
-        ret = np.zeros((1,),dtype=self._uuid_dt)
-        ret[0]["uuid_bytes"]=ret_bytes
+        ret_bytes = np.frombuffer(py_uuid.bytes, dtype=np.uint8)
+        ret = np.zeros((1,), dtype=self._uuid_dt)
+        ret[0]["uuid_bytes"] = ret_bytes
         return ret
 
     def UuidToPyUuid(self, uuid):
         """
         Create a Python UUID from a Robot Raconteur UUID
 
         :param uuid: The Robot Raconteur UUID to convert
@@ -54,24 +55,24 @@
 
         :return: The new UUID
         :rtype: com.robotraconteur.uuid.UUID
         """
         new_uuid = py_uuid.uuid4()
         return self.UuidFromPyUuid(new_uuid)
 
-    def ParseUuid(self,uuid_str):
+    def ParseUuid(self, uuid_str):
         """
         Parse a UUID string into a Robot Raconteur UUID
 
         :param uuid_str: The UUID string to parse
         :type uuid_str: str
         """
         return self.UuidFromPyUuid(py_uuid.UUID(uuid_str))
 
-    def UuidToString(self,uuid):
+    def UuidToString(self, uuid):
         """
         Convert a Robot Raconteur UUID to a string
 
         :param uuid: The Robot Raconteur UUID to convert
         :type uuid: com.robotraconteur.uuid.UUID
         :return: The UUID string
         :rtype: str
```

## Comparing `RobotRaconteurCompanion-0.3.0.dist-info/LICENSE.txt` & `RobotRaconteurCompanion-0.4.0.dist-info/LICENSE.txt`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -194,8 +194,8 @@
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
-   limitations under the License.
+   limitations under the License.
```

## Comparing `RobotRaconteurCompanion-0.3.0.dist-info/METADATA` & `RobotRaconteurCompanion-0.4.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 Metadata-Version: 2.1
 Name: RobotRaconteurCompanion
-Version: 0.3.0
+Version: 0.4.0
 Summary: Robot Raconteur Python Companion Library
 Home-page: https://github.com/robotraconteur/robotraconteur_companion_python
 Author: John Wason
 Author-email: wason@wasontech.com
 License-File: LICENSE.txt
-Requires-Dist: RobotRaconteur >=0.18.0
+Requires-Dist: RobotRaconteur >=1.1.1
 Requires-Dist: numpy
 Requires-Dist: PyYAML
 Requires-Dist: setuptools
 Requires-Dist: importlib-resources
 Requires-Dist: general-robotics-toolbox >=0.7.1
 Provides-Extra: test
 Requires-Dist: pytest ; extra == 'test'
```

## Comparing `RobotRaconteurCompanion-0.3.0.dist-info/RECORD` & `RobotRaconteurCompanion-0.4.0.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-RobotRaconteurCompanion/__init__.py,sha256=5pDj61pZm4eO6ehFpv51CcStsdcoFWeaiKmpwoAtjG4,355
-RobotRaconteurCompanion/InfoParser/__init__.py,sha256=1iUjworxm1fRBqGqspvdLS5Hw_dc2tsuKo2L9kvFi6U,13037
-RobotRaconteurCompanion/StdRobDef/__init__.py,sha256=dV-W4H2lFkTnwzgkhN6zE48CVSbhJOzNLlILF77ji5g,2454
+RobotRaconteurCompanion/__init__.py,sha256=OiJybkU1eUstXXWo2nBkEnZW-_W1OqWv9QWNZ5p6yHc,356
+RobotRaconteurCompanion/InfoParser/__init__.py,sha256=qUp6CagxoFl-Avu5xLAe7Fx4zR4NuzKogWGTSHov240,15114
+RobotRaconteurCompanion/StdRobDef/__init__.py,sha256=_Pa3WAOuG_B0lHgWieRkUUinTgJnrs40OdtZNsg0xow,2467
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef,sha256=tSpFycEMsweyCn_kDCu9estB8r4WHVMk2gqoZVxd-fc,182
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef,sha256=Upm7zm2LEvEXlIdzE7eKoOEionIuwK8aEpyYlwVGh1o,2197
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef,sha256=Hut-XwPMyUpQbbN9hvtofeLbMv7iXX8X4OD2zYowtks,373
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef,sha256=eqoWr20K_zXev3N0gauF0ez9LvQ3E5310DuasduYrTA,781
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef,sha256=ywZqPsoP3nUYss-g-TMhDcheeQTP59L3xkO9JpcFsmA,1005
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef,sha256=g36ZhChPtRr9t-_fjDANpm4T4MZj6hu0uDLBGAGR2ck,1042
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef,sha256=isHRA0onDOpM0WyGWgfXETSB27llwXbZiD86Th1c5lc,1415
@@ -42,26 +42,27 @@
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef,sha256=T-k20QUec1Yy88w1XCr5j9OCRRnVbBbvJgSV5M6HSkY,2952
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef,sha256=LqVKrzxdTNAGEnGoifn6kzFLYe17J4jpdHvj8Ag3rPk,5361
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef,sha256=p3XUaXU75dRX71hesSSlmwvjcd5Gfc57SijKP8xgaFQ,616
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef,sha256=NTetK8yAtz0C15wY6Ly7SIR-K28WaxQtRXLQnseYByE,4166
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef,sha256=AaDGpKtCt97MFIlrsnpnH6U0P0cATkGSyVanTNntcT0,2522
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef,sha256=JRiuyq4h292pzIxU7KRXz2bNOxb58pcm1xwXHSsxXnw,127
 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef,sha256=qU8KeGvSV3psmzeCaCoYYy43ueLPWTlMUicqHwkqcVA,97
-RobotRaconteurCompanion/Util/AttributesUtil.py,sha256=B_IIejK6wobQo_eoQF37z1n-MWbyw2OXR5WVo49PYoI,2456
-RobotRaconteurCompanion/Util/DateTimeUtil.py,sha256=kn37kE7G9VbH-81SuONl3GxvxtC7oGWeJzJF4Kcrm-I,5188
-RobotRaconteurCompanion/Util/GeometryUtil.py,sha256=mIq_m_MSVHvl2kz48qC65hrF4w0AY9P1IjZafo-46tA,31608
-RobotRaconteurCompanion/Util/IdentifierUtil.py,sha256=jluZ7-5-hpoXmOnBit3I2Iq_x-BZ0mUrsKUCVr63xAo,7229
-RobotRaconteurCompanion/Util/ImageUtil.py,sha256=-X7T16CHFw_BCUlaneC6J-jdwlsLFOkye8w6BVHRM0g,10396
-RobotRaconteurCompanion/Util/InfoFileLoader.py,sha256=lKheRuD3nDpKxixilbdOTRNRZczijR9yT28_jSKtQ4Y,4070
-RobotRaconteurCompanion/Util/LocalIdentifiersManager.py,sha256=LRniZERZpGaS3WaH3IYBs7vD_gM08hwi6fHaaMoSOKU,2553
-RobotRaconteurCompanion/Util/RobDef.py,sha256=6htOHriZPfVp-b7ybXku9neEO9Pj0_PZnLzSCEiCacU,2339
-RobotRaconteurCompanion/Util/RobotUtil.py,sha256=hqRx6eknVlHPTLtHHUm86KyiHIALW75BuKyIvq47UMk,5951
-RobotRaconteurCompanion/Util/RobustFunctionCaller.py,sha256=MOtFXjiiCavTCY-s0EYTiJop-8LoEK9DENyhWg6WvgI,4768
-RobotRaconteurCompanion/Util/SensorDataUtil.py,sha256=hetl60vn3ceybppP40moIedSHkKO-0xhiZAv2nkoB4Y,1834
-RobotRaconteurCompanion/Util/TaskGenerator.py,sha256=FHtR41Fcup0ea_ZkFM1yDqTDjGxIiIQAMycE_J0bJ2w,10309
-RobotRaconteurCompanion/Util/TestFixtures.py,sha256=ZVHt45mXf7Gwi3Q6CCWHwSG4ufhA_KTU4IGNm-yAgnw,4087
-RobotRaconteurCompanion/Util/UuidUtil.py,sha256=4xK7MwI8XuYYyBVqmlhgs3HFv-GmEGf1lgKs9PxhTRE,2473
-RobotRaconteurCompanion-0.3.0.dist-info/LICENSE.txt,sha256=qGxBeReM7Xcl1sVO7Ht_vdVDXh4zuXiYtEFIqk1pqHM,11354
-RobotRaconteurCompanion-0.3.0.dist-info/METADATA,sha256=XKLYmaKnqrgFz2qavIN6aLBQOvKU9ni9D9KqC0Yo160,543
-RobotRaconteurCompanion-0.3.0.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-RobotRaconteurCompanion-0.3.0.dist-info/top_level.txt,sha256=sTqNX_M_WXwgaIkdMUK-MsOwxqglJ42PnGGm02zuBZY,24
-RobotRaconteurCompanion-0.3.0.dist-info/RECORD,,
+RobotRaconteurCompanion/Util/AttributesUtil.py,sha256=vu3xdgla-bsi0NG2nfMB2STrkHnyOuOWhFwW6PGDR88,3105
+RobotRaconteurCompanion/Util/DateTimeUtil.py,sha256=Pe7b6NYQsKyQ3T119pDOgFet31n7ETeUkLw7Cj4YKjk,5194
+RobotRaconteurCompanion/Util/DeviceConnector.py,sha256=0XJ6pAnFm9VDarstaAg-ifZaVchx_JtV058svK7Lm-s,24642
+RobotRaconteurCompanion/Util/GeometryUtil.py,sha256=al0xtwYH03SOzcB889G3S-iKZNMzj6yQ-reUHIEu1pE,31726
+RobotRaconteurCompanion/Util/IdentifierUtil.py,sha256=vUD0O8-OPqgDSBM9_a1dbZWtCtQhOucmNE_UWcdom-k,7208
+RobotRaconteurCompanion/Util/ImageUtil.py,sha256=BqADXGdR1kwgDPSiFINfFedKTv8-b6gwb3QekXjR1hQ,10397
+RobotRaconteurCompanion/Util/InfoFileLoader.py,sha256=Aeuc4ylTLUsgnUSVXFkO2UTllDMAztKec5bCWp5FWCg,5001
+RobotRaconteurCompanion/Util/LocalIdentifiersManager.py,sha256=qJwm3XT3jZaiX_Bcb6dgAJgqnbQSLe0M44U-kH79rWk,2536
+RobotRaconteurCompanion/Util/RobDef.py,sha256=l_26adHqrXoeiaAK_MaARDl9ZuSNGewfE0v0sgR7MzY,2342
+RobotRaconteurCompanion/Util/RobotUtil.py,sha256=khp876sOF1pYGWILN-ZvynJPZlkZjlhi0CupkGu3cns,5922
+RobotRaconteurCompanion/Util/RobustFunctionCaller.py,sha256=7EDJ0qDDTSCQQ-5WySXG34oiaVuCw1y3-7fomegLS7w,4732
+RobotRaconteurCompanion/Util/SensorDataUtil.py,sha256=9gZOOD1qf08B9sMlXVCQ5QJW1-30O32Qkv-941tZDVA,1850
+RobotRaconteurCompanion/Util/TaskGenerator.py,sha256=39tTlqI81XMUMb-YeY-LRXHwnDBBK8hxWvAoxHDZ_ok,10035
+RobotRaconteurCompanion/Util/TestFixtures.py,sha256=6F4yUs3_ThBkBlD_y-iD239xmrEao1zdBEwEkK0NwLw,3966
+RobotRaconteurCompanion/Util/UuidUtil.py,sha256=j4qT6GbxDhqWVFCQWLQXa_kAhHuLfyubVhGw_eLDg_s,2468
+RobotRaconteurCompanion-0.4.0.dist-info/LICENSE.txt,sha256=OTyVZprkVDXGRHJb4ULGKi_62ooW_3A7yTbPVqVf4hE,11355
+RobotRaconteurCompanion-0.4.0.dist-info/METADATA,sha256=US5XABluPnynFBGHwaB5L6SX0HyKmCTV-Zex3i5UDDY,542
+RobotRaconteurCompanion-0.4.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+RobotRaconteurCompanion-0.4.0.dist-info/top_level.txt,sha256=sTqNX_M_WXwgaIkdMUK-MsOwxqglJ42PnGGm02zuBZY,24
+RobotRaconteurCompanion-0.4.0.dist-info/RECORD,,
```

