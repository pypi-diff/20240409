# Comparing `tmp/dito-2.8.0-py3-none-any.whl.zip` & `tmp/dito-2.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,86 +1,87 @@
-Zip file size: 402761 bytes, number of entries: 84
--rw-r--r--  2.0 unx      339 b- defN 22-Apr-06 07:55 dito/__init__.py
--rw-r--r--  2.0 unx     7001 b- defN 22-Apr-06 07:35 dito/analysis.py
--rw-r--r--  2.0 unx    18169 b- defN 22-Mar-03 20:26 dito/core.py
--rw-r--r--  2.0 unx    24999 b- defN 21-Dec-19 19:21 dito/data.py
--rw-r--r--  2.0 unx    11111 b- defN 21-Nov-04 19:04 dito/draw.py
--rw-r--r--  2.0 unx      129 b- defN 22-Mar-03 20:14 dito/exceptions.py
--rw-r--r--  2.0 unx     5335 b- defN 22-Mar-25 11:03 dito/highgui.py
--rw-r--r--  2.0 unx     3395 b- defN 21-Oct-20 21:31 dito/inspect.py
--rw-r--r--  2.0 unx     8359 b- defN 22-Apr-06 07:23 dito/io.py
--rw-r--r--  2.0 unx     1758 b- defN 21-Oct-20 00:22 dito/parallel.py
--rw-r--r--  2.0 unx    12184 b- defN 22-Mar-25 08:07 dito/processing.py
--rw-r--r--  2.0 unx    62839 b- defN 22-Apr-06 07:22 dito/tests.py
--rw-r--r--  2.0 unx     5569 b- defN 21-Oct-20 21:18 dito/utils.py
--rw-r--r--  2.0 unx    51145 b- defN 22-Feb-16 01:23 dito/visual.py
--rw-r--r--  2.0 unx       92 b- defN 20-Dec-16 14:49 dito/resources/colormaps/plot.png
--rw-r--r--  2.0 unx       92 b- defN 20-Dec-16 14:50 dito/resources/colormaps/plot2.png
--rw-r--r--  2.0 unx     1710 b- defN 21-Oct-19 20:40 dito/resources/colormaps/colorbrewer/LICENSE.txt
--rw-r--r--  2.0 unx      233 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/accent.png
--rw-r--r--  2.0 unx      189 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/blues.png
--rw-r--r--  2.0 unx      251 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/brbg.png
--rw-r--r--  2.0 unx      237 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/bugn.png
--rw-r--r--  2.0 unx      203 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/bupu.png
--rw-r--r--  2.0 unx    35144 b- defN 21-Oct-19 20:38 dito/resources/colormaps/colorbrewer/colorbrewer.json
--rw-r--r--  2.0 unx      228 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/dark2.png
--rw-r--r--  2.0 unx      218 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/gnbu.png
--rw-r--r--  2.0 unx      215 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/greens.png
--rw-r--r--  2.0 unx      113 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/greys.png
--rw-r--r--  2.0 unx      189 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/oranges.png
--rw-r--r--  2.0 unx      209 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/orrd.png
--rw-r--r--  2.0 unx      286 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/paired.png
--rw-r--r--  2.0 unx      232 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/pastel1.png
--rw-r--r--  2.0 unx      224 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/pastel2.png
--rw-r--r--  2.0 unx      248 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/piyg.png
--rw-r--r--  2.0 unx      239 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/prgn.png
--rw-r--r--  2.0 unx      197 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/pubu.png
--rw-r--r--  2.0 unx      222 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/pubugn.png
--rw-r--r--  2.0 unx      222 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/puor.png
--rw-r--r--  2.0 unx      265 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/purd.png
--rw-r--r--  2.0 unx      215 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/purples.png
--rw-r--r--  2.0 unx      239 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/rdbu.png
--rw-r--r--  2.0 unx      182 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/rdgy.png
--rw-r--r--  2.0 unx      227 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/rdpu.png
--rw-r--r--  2.0 unx      232 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/rdylbu.png
--rw-r--r--  2.0 unx      207 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/rdylgn.png
--rw-r--r--  2.0 unx      195 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/reds.png
--rw-r--r--  2.0 unx      265 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/set1.png
--rw-r--r--  2.0 unx      247 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/set2.png
--rw-r--r--  2.0 unx      272 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/set3.png
--rw-r--r--  2.0 unx      229 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/spectral.png
--rw-r--r--  2.0 unx      216 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/ylgn.png
--rw-r--r--  2.0 unx      239 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/ylgnbu.png
--rw-r--r--  2.0 unx      204 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/ylorbr.png
--rw-r--r--  2.0 unx      193 b- defN 21-Oct-19 21:03 dito/resources/colormaps/colorbrewer/ylorrd.png
--rw-r--r--  2.0 unx     4358 b- defN 21-May-07 16:20 dito/resources/fonts/scientifica/LICENSE.txt
--rw-r--r--  2.0 unx     1467 b- defN 21-May-07 21:47 dito/resources/fonts/scientifica/scientifica_df2.png
--rw-r--r--  2.0 unx     4046 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/10_df2.png
--rw-r--r--  2.0 unx     7755 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/15_df2.png
--rw-r--r--  2.0 unx    11762 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/20_df2.png
--rw-r--r--  2.0 unx    15667 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/25_df2.png
--rw-r--r--  2.0 unx    20385 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/30_df2.png
--rw-r--r--  2.0 unx    24424 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/35_df2.png
--rw-r--r--  2.0 unx    29567 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/40_df2.png
--rw-r--r--  2.0 unx    38502 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/50_df2.png
--rw-r--r--  2.0 unx    58458 b- defN 21-May-07 21:47 dito/resources/fonts/source_code_pro/70_df2.png
--rw-r--r--  2.0 unx     4578 b- defN 21-Apr-08 22:00 dito/resources/fonts/source_code_pro/LICENSE.txt
--rw-r--r--  2.0 unx     4386 b- defN 21-May-07 16:13 dito/resources/fonts/terminus/LICENSE.txt
--rw-r--r--  2.0 unx     1280 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u12_df2.png
--rw-r--r--  2.0 unx     1947 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u14_df2.png
--rw-r--r--  2.0 unx     1962 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u16_df2.png
--rw-r--r--  2.0 unx     2453 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u18_df2.png
--rw-r--r--  2.0 unx     2498 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u20_df2.png
--rw-r--r--  2.0 unx     3182 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u22_df2.png
--rw-r--r--  2.0 unx     3006 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u24_df2.png
--rw-r--r--  2.0 unx     4494 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u28_df2.png
--rw-r--r--  2.0 unx     4506 b- defN 21-May-07 21:47 dito/resources/fonts/terminus/ter-u32_df2.png
--rw-r--r--  2.0 unx    14218 b- defN 20-Dec-14 12:55 dito/resources/images/PM5544.png
--rw-r--r--  2.0 unx    68546 b- defN 21-Oct-27 21:19 dito/resources/images/USC_SIPI_4.1.07.png
--rwxr-xr-x  2.0 unx     2137 b- defN 22-Apr-06 08:01 dito-2.8.0.data/scripts/dito_images_to_video.py
--rwxr-xr-x  2.0 unx     1419 b- defN 22-Apr-06 08:01 dito-2.8.0.data/scripts/dito_pinfo.py
--rw-r--r--  2.0 unx     1061 b- defN 22-Apr-06 08:01 dito-2.8.0.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx      634 b- defN 22-Apr-06 08:01 dito-2.8.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Apr-06 08:01 dito-2.8.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 22-Apr-06 08:01 dito-2.8.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     8001 b- defN 22-Apr-06 08:01 dito-2.8.0.dist-info/RECORD
-84 files, 603948 bytes uncompressed, 389759 bytes compressed:  35.5%
+Zip file size: 405797 bytes, number of entries: 85
+-rw-r--r--  2.0 unx      372 b- defN 23-Apr-18 23:05 dito/__init__.py
+-rw-r--r--  2.0 unx     7001 b- defN 22-Dec-27 21:21 dito/analysis.py
+-rw-r--r--  2.0 unx     1573 b- defN 22-Dec-27 21:21 dito/conversion.py
+-rw-r--r--  2.0 unx    18169 b- defN 22-Dec-27 21:21 dito/core.py
+-rw-r--r--  2.0 unx    24995 b- defN 23-Apr-18 21:50 dito/data.py
+-rw-r--r--  2.0 unx    11111 b- defN 22-Dec-27 21:21 dito/draw.py
+-rw-r--r--  2.0 unx      172 b- defN 22-Dec-27 21:21 dito/exceptions.py
+-rw-r--r--  2.0 unx     5335 b- defN 22-Dec-27 21:21 dito/highgui.py
+-rw-r--r--  2.0 unx     4128 b- defN 23-Apr-18 19:46 dito/inspection.py
+-rw-r--r--  2.0 unx     8628 b- defN 23-Feb-10 10:42 dito/io.py
+-rw-r--r--  2.0 unx     1758 b- defN 22-Dec-27 21:21 dito/parallel.py
+-rw-r--r--  2.0 unx    16064 b- defN 23-Apr-18 21:12 dito/processing.py
+-rw-r--r--  2.0 unx    69703 b- defN 23-Apr-18 21:44 dito/tests.py
+-rw-r--r--  2.0 unx     5569 b- defN 22-Dec-27 21:21 dito/utils.py
+-rw-r--r--  2.0 unx    52651 b- defN 23-Apr-18 22:23 dito/visual.py
+-rw-r--r--  2.0 unx       92 b- defN 22-Dec-27 21:21 dito/resources/colormaps/plot.png
+-rw-r--r--  2.0 unx       92 b- defN 22-Dec-27 21:21 dito/resources/colormaps/plot2.png
+-rw-r--r--  2.0 unx     1710 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/LICENSE.txt
+-rw-r--r--  2.0 unx      233 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/accent.png
+-rw-r--r--  2.0 unx      189 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/blues.png
+-rw-r--r--  2.0 unx      251 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/brbg.png
+-rw-r--r--  2.0 unx      237 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/bugn.png
+-rw-r--r--  2.0 unx      203 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/bupu.png
+-rw-r--r--  2.0 unx    35144 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/colorbrewer.json
+-rw-r--r--  2.0 unx      228 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/dark2.png
+-rw-r--r--  2.0 unx      218 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/gnbu.png
+-rw-r--r--  2.0 unx      215 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/greens.png
+-rw-r--r--  2.0 unx      113 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/greys.png
+-rw-r--r--  2.0 unx      189 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/oranges.png
+-rw-r--r--  2.0 unx      209 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/orrd.png
+-rw-r--r--  2.0 unx      286 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/paired.png
+-rw-r--r--  2.0 unx      232 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/pastel1.png
+-rw-r--r--  2.0 unx      224 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/pastel2.png
+-rw-r--r--  2.0 unx      248 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/piyg.png
+-rw-r--r--  2.0 unx      239 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/prgn.png
+-rw-r--r--  2.0 unx      197 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/pubu.png
+-rw-r--r--  2.0 unx      222 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/pubugn.png
+-rw-r--r--  2.0 unx      222 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/puor.png
+-rw-r--r--  2.0 unx      265 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/purd.png
+-rw-r--r--  2.0 unx      215 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/purples.png
+-rw-r--r--  2.0 unx      239 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/rdbu.png
+-rw-r--r--  2.0 unx      182 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/rdgy.png
+-rw-r--r--  2.0 unx      227 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/rdpu.png
+-rw-r--r--  2.0 unx      232 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/rdylbu.png
+-rw-r--r--  2.0 unx      207 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/rdylgn.png
+-rw-r--r--  2.0 unx      195 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/reds.png
+-rw-r--r--  2.0 unx      265 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/set1.png
+-rw-r--r--  2.0 unx      247 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/set2.png
+-rw-r--r--  2.0 unx      272 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/set3.png
+-rw-r--r--  2.0 unx      229 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/spectral.png
+-rw-r--r--  2.0 unx      216 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/ylgn.png
+-rw-r--r--  2.0 unx      239 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/ylgnbu.png
+-rw-r--r--  2.0 unx      204 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/ylorbr.png
+-rw-r--r--  2.0 unx      193 b- defN 22-Dec-27 21:21 dito/resources/colormaps/colorbrewer/ylorrd.png
+-rw-r--r--  2.0 unx     4358 b- defN 22-Dec-27 21:21 dito/resources/fonts/scientifica/LICENSE.txt
+-rw-r--r--  2.0 unx     1467 b- defN 22-Dec-27 21:21 dito/resources/fonts/scientifica/scientifica_df2.png
+-rw-r--r--  2.0 unx     4046 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/10_df2.png
+-rw-r--r--  2.0 unx     7755 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/15_df2.png
+-rw-r--r--  2.0 unx    11762 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/20_df2.png
+-rw-r--r--  2.0 unx    15667 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/25_df2.png
+-rw-r--r--  2.0 unx    20385 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/30_df2.png
+-rw-r--r--  2.0 unx    24424 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/35_df2.png
+-rw-r--r--  2.0 unx    29567 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/40_df2.png
+-rw-r--r--  2.0 unx    38502 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/50_df2.png
+-rw-r--r--  2.0 unx    58458 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/70_df2.png
+-rw-r--r--  2.0 unx     4485 b- defN 22-Dec-27 21:21 dito/resources/fonts/source_code_pro/LICENSE.txt
+-rw-r--r--  2.0 unx     4386 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/LICENSE.txt
+-rw-r--r--  2.0 unx     1280 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u12_df2.png
+-rw-r--r--  2.0 unx     1947 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u14_df2.png
+-rw-r--r--  2.0 unx     1962 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u16_df2.png
+-rw-r--r--  2.0 unx     2453 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u18_df2.png
+-rw-r--r--  2.0 unx     2498 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u20_df2.png
+-rw-r--r--  2.0 unx     3182 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u22_df2.png
+-rw-r--r--  2.0 unx     3006 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u24_df2.png
+-rw-r--r--  2.0 unx     4494 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u28_df2.png
+-rw-r--r--  2.0 unx     4506 b- defN 22-Dec-27 21:21 dito/resources/fonts/terminus/ter-u32_df2.png
+-rw-r--r--  2.0 unx    14218 b- defN 22-Dec-27 21:21 dito/resources/images/PM5544.png
+-rw-r--r--  2.0 unx    68546 b- defN 22-Dec-27 21:21 dito/resources/images/USC_SIPI_4.1.07.png
+-rwxr-xr-x  2.0 unx     2137 b- defN 23-Apr-18 23:06 dito-2.9.0.data/scripts/dito_images_to_video.py
+-rwxr-xr-x  2.0 unx     1585 b- defN 23-Apr-18 23:06 dito-2.9.0.data/scripts/dito_pinfo.py
+-rw-r--r--  2.0 unx     1061 b- defN 23-Apr-18 23:06 dito-2.9.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx      637 b- defN 23-Apr-18 23:06 dito-2.9.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-18 23:06 dito-2.9.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Apr-18 23:06 dito-2.9.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     8079 b- defN 23-Apr-18 23:06 dito-2.9.0.dist-info/RECORD
+85 files, 618999 bytes uncompressed, 392677 bytes compressed:  36.6%
```

## zipnote {}

```diff
@@ -1,13 +1,16 @@
 Filename: dito/__init__.py
 Comment: 
 
 Filename: dito/analysis.py
 Comment: 
 
+Filename: dito/conversion.py
+Comment: 
+
 Filename: dito/core.py
 Comment: 
 
 Filename: dito/data.py
 Comment: 
 
 Filename: dito/draw.py
@@ -15,15 +18,15 @@
 
 Filename: dito/exceptions.py
 Comment: 
 
 Filename: dito/highgui.py
 Comment: 
 
-Filename: dito/inspect.py
+Filename: dito/inspection.py
 Comment: 
 
 Filename: dito/io.py
 Comment: 
 
 Filename: dito/parallel.py
 Comment: 
@@ -225,29 +228,29 @@
 
 Filename: dito/resources/images/PM5544.png
 Comment: 
 
 Filename: dito/resources/images/USC_SIPI_4.1.07.png
 Comment: 
 
-Filename: dito-2.8.0.data/scripts/dito_images_to_video.py
+Filename: dito-2.9.0.data/scripts/dito_images_to_video.py
 Comment: 
 
-Filename: dito-2.8.0.data/scripts/dito_pinfo.py
+Filename: dito-2.9.0.data/scripts/dito_pinfo.py
 Comment: 
 
-Filename: dito-2.8.0.dist-info/LICENSE.txt
+Filename: dito-2.9.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: dito-2.8.0.dist-info/METADATA
+Filename: dito-2.9.0.dist-info/METADATA
 Comment: 
 
-Filename: dito-2.8.0.dist-info/WHEEL
+Filename: dito-2.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: dito-2.8.0.dist-info/top_level.txt
+Filename: dito-2.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: dito-2.8.0.dist-info/RECORD
+Filename: dito-2.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dito/__init__.py

```diff
@@ -1,15 +1,16 @@
-__version__ = "2.8.0"
+__version__ = "2.9.0"
 
 
 from dito.analysis import *
+from dito.conversion import *
 from dito.core import *
 from dito.data import *
 from dito.draw import *
 from dito.exceptions import *
 from dito.highgui import *
-from dito.inspect import *
+from dito.inspection import *
 from dito.io import *
 from dito.parallel import *
 from dito.processing import *
 from dito.utils import *
 from dito.visual import *
```

## dito/data.py

```diff
@@ -93,15 +93,15 @@
 
 def constant_image(size=(512, 288), color=(0, 255, 0), dtype=np.uint8):
     """
     Returns an image where each color channel is constant (but the channel
     values may vary).
     """
     channel_count = len(color)
-    image = np.zeros(shape=(size[1], size[0]) + (channel_count,), dtype=dtype)
+    image = np.zeros(shape=(size[1], size[0], channel_count), dtype=dtype)
     for n_channel in range(channel_count):
         image[:, :, n_channel] = color[n_channel]
     if channel_count == 1:
         image = image[:, :, 0]
     return image
```

## dito/exceptions.py

```diff
@@ -1,4 +1,5 @@
 class DitoException(Exception): pass
 
+class ConversionError(DitoException): pass
 class InvalidImageShapeError(DitoException): pass
 class QkeyInterrupt(DitoException): pass
```

## dito/io.py

```diff
@@ -1,10 +1,11 @@
 import functools
 import glob
 import os.path
+import pathlib
 import tempfile
 import time
 import uuid
 
 import cv2
 import numpy as np
 
@@ -18,14 +19,17 @@
     If `color` is `None`, the image is loaded as-is. If `color` is `False`, a
     grayscale image is returned. If `color` is `True`, then a color image is
     returned, even if the original image is grayscale.
 
     The bit-depth (8 or 16 bit) of the image file will be preserved.
     """
 
+    if isinstance(filename, pathlib.Path):
+        filename = str(filename)
+
     # check if file exists
     if not os.path.exists(filename):
         raise FileNotFoundError("Image file '{}' does not exist".format(filename))
 
     # load image
     if filename.endswith(".npy"):
         # use NumPy
@@ -72,14 +76,17 @@
     """
     Save image `image` to file `filename`.
 
     If `mkdir` is `True`, the parent dir of the given filename is created
     before saving the image.
     """
 
+    if isinstance(filename, pathlib.Path):
+        filename = str(filename)
+
     if not isinstance(image, np.ndarray):
         raise RuntimeError("Invalid image (type '{}')".format(type(image).__name__))
 
     # create parent dir
     if mkdir:
         dito.utils.mkdir(dirname=os.path.dirname(filename))
 
@@ -176,14 +183,17 @@
 
     def __init__(self, filename, codec="MJPG", fps=30.0, color=True):
         self.filename = filename
         self.codec = codec
         self.fps = fps
         self.color = color
 
+        if isinstance(self.filename, pathlib.Path):
+            self.filename = str(self.filename)
+
         if (not isinstance(self.codec, str)) or (len(self.codec) != 4):
             raise ValueError("Argument 'codec' must be a string of length 4")
 
         self.frame_count = 0
         self.image_size = None
         self.writer = None
```

## dito/processing.py

```diff
@@ -9,14 +9,114 @@
 
 
 ##
 ## basic processing
 ##
 
 
+def clipped_diff(image1, image2, scale=None, offset=None, apply_abs=False):
+    """
+    Compute the clipped difference between two images.
+
+    The `image1` and `image2` inputs must have the same dtype. The function computes the element-wise difference
+    between `image1` and `image2`, and then applies an optional offset and scale factor to the difference values.
+    The resulting values are clipped to the original dtype range, to prevent overflow or underflow.
+
+    Parameters
+    ----------
+    image1 : numpy.ndarray
+        The first input image (minuend).
+    image2 : numpy.ndarray
+        The second input image (subtrahend).
+    scale : float, optional
+        The scale factor to apply to the difference values. If specified, the difference values are multiplied by
+        `scale` before any offset is applied. The default value is `None`, which means no scaling is applied.
+    offset : float, optional
+        The offset value to add to the difference values. If specified, the difference values are increased by
+        `offset` after any scaling is applied. The default value is `None`, which means no offset is applied.
+    apply_abs : bool, optional
+        If `True`, the absolute value of the difference image is computed before any scaling or offset is applied.
+        The default value is `False`.
+
+    Returns
+    -------
+    numpy.ndarray
+        The clipped difference image, with the same shape and dtype as the input images.
+    """
+
+    # assert equal dtypes
+    if image1.dtype != image2.dtype:
+        raise ValueError("Both images must have the same dtypes (but have '{}' and '{}')".format(image1.dtype, image2.dtype))
+    dtype = image1.dtype
+    dtype_range = dito.core.dtype_range(dtype=dtype)
+
+    # raw diff
+    diff = image1.astype(np.float32) - image2.astype(np.float32)
+
+    # apply offset, scale, and abs if specified
+    if scale is not None:
+        diff *= scale
+    if offset is not None:
+        diff += offset
+    if apply_abs:
+        diff = np.abs(diff)
+
+    # clip values outside of original range
+    diff = dito.clip(image=diff, lower=dtype_range[0], upper=dtype_range[1])
+
+    return diff.astype(dtype)
+
+
+def abs_diff(image1, image2):
+    """
+    Compute the absolute difference between two images.
+
+    The `image1` and `image2` inputs must have the same dtype. The function computes the element-wise absolute
+    difference between `image1` and `image2`, and then clips the resulting values to the original dtype range,
+    to prevent overflow or underflow (which might happen for signed integer dtypes).
+
+    Parameters
+    ----------
+    image1 : numpy.ndarray
+        The first input image (minuend).
+    image2 : numpy.ndarray
+        The second input image (subtrahend).
+
+    Returns
+    -------
+    numpy.ndarray
+        The absolute difference image, with the same shape and dtype as the input images.
+    """
+    return clipped_diff(image1=image1, image2=image2, scale=None, offset=None, apply_abs=True)
+
+
+def shifted_diff(image1, image2):
+    """
+    Compute the shifted difference between two images.
+
+    The `image1` and `image2` inputs must have the same dtype. The function computes the element-wise difference
+    between `image1` and `image2`, and then applies a scale and offset to the difference values to shift the result
+    back into the original dtype range such that there is no need for clipping
+
+    Parameters
+    ----------
+    image1 : numpy.ndarray
+        The first input image (minuend).
+    image2 : numpy.ndarray
+        The second input image (subtrahend).
+
+    Returns
+    -------
+    numpy.ndarray
+        The shifted difference image, with the same shape and dtype as the input images.
+    """
+    dtype_range = dito.core.dtype_range(dtype=image1.dtype)
+    return clipped_diff(image1=image1, image2=image2, scale=0.5, offset=0.5 * (dtype_range[0] + dtype_range[1]), apply_abs=False)
+
+
 def gaussian_blur(image, sigma):
     if sigma <= 0.0:
         return image
     return cv2.GaussianBlur(src=image, ksize=None, sigmaX=sigma)
 
 
 def median_blur(image, kernel_size):
@@ -226,15 +326,15 @@
     def shift(self, offset_x=None, offset_y=None):
         if offset_x is not None:
             self.points[:, 0] += offset_x
         if offset_y is not None:
             self.points[:, 1] += offset_y
 
     def draw(self, image, color, thickness=1, filled=True, antialias=False, offset=None):
-        cv2.drawContours(image=image, contours=[np.round(self.points).astype(np.int)], contourIdx=0, color=color, thickness=cv2.FILLED if filled else thickness, lineType=cv2.LINE_AA if antialias else cv2.LINE_8, offset=offset)
+        cv2.drawContours(image=image, contours=[np.round(self.points).astype(np.int32)], contourIdx=0, color=color, thickness=cv2.FILLED if filled else thickness, lineType=cv2.LINE_AA if antialias else cv2.LINE_8, offset=offset)
 
     def draw_standalone(self, color, thickness=1, filled=True, antialias=False, border=0):
         image = np.zeros(shape=(2 * border + self.get_height(), 2 * border + self.get_width()), dtype=np.uint8)
         self.draw(image=image, color=color, thickness=thickness, filled=filled, antialias=antialias, offset=(border - self.get_min_x(), border - self.get_min_y()))
         return image
 
 
@@ -326,15 +426,15 @@
         for (contour, color) in zip(self.contours, colors):
             contour.draw(image=image, color=color, **kwargs)
 
 
 class ContourFinder(ContourList):
     def __init__(self, image):
         self.image = image.copy()
-        if self.image.dtype == np.bool:
+        if self.image.dtype == bool:
             self.image = dito.core.convert(image=self.image, dtype=np.uint8)
         contours = self.find_contours(image=self.image)
         super().__init__(contours=contours)
 
     @staticmethod
     def find_contours(image):
         """
```

## dito/tests.py

```diff
@@ -1,8 +1,10 @@
+import collections
 import os.path
+import pathlib
 import unittest
 
 import cv2
 import numpy as np
 
 import dito
 
@@ -46,14 +48,32 @@
     def setUp(self):
         self.temp_dir = dito.get_temp_dir(prefix="dito.tests.")
 
     def tearDown(self):
         self.temp_dir.cleanup()
 
 
+class DiffTestCase(TestCase):
+    def setUp(self):
+        self.image1_bool = np.array([[False, True]], dtype=bool)
+        self.image2_bool = np.array([[True, False]], dtype=bool)
+
+        self.image1_int8 = np.array([[-128, 127]], dtype=np.int8)
+        self.image2_int8 = np.array([[127, -128]], dtype=np.int8)
+
+        self.image1_uint8 = np.array([[0, 255]], dtype=np.uint8)
+        self.image2_uint8 = np.array([[255, 0]], dtype=np.uint8)
+
+        self.image1_float32 = np.array([[0.0, 1.0]], dtype=np.float32)
+        self.image2_float32 = np.array([[1.0, 0.0]], dtype=np.float32)
+
+        self.image1_float64 = np.array([[0.0, 1.0]], dtype=np.float64)
+        self.image2_float64 = np.array([[1.0, 0.0]], dtype=np.float64)
+
+
 ####
 #%%% test cases
 ####
 
 
 class CachedImageLoader_Test(TempDirTestCase):
     def test_CachedImageLoader_init(self):
@@ -100,14 +120,41 @@
 
     def test_CachedImageLoader_raise(self):
         loader = dito.CachedImageLoader(max_count=4)
         filename = os.path.join(self.temp_dir.name, "__nonexistent__.png")
         self.assertRaises(FileNotFoundError, lambda: loader.load(filename=filename))
 
 
+class abs_diff_Tests(DiffTestCase):
+    def test_abs_diff_bool(self):
+        result = dito.abs_diff(image1=self.image1_bool, image2=self.image2_bool)
+        expected_result = np.array([[1, 1]], dtype=bool)
+        self.assertEqualImages(result, expected_result)
+
+    def test_abs_diff_int8(self):
+        result = dito.abs_diff(image1=self.image1_int8, image2=self.image2_int8)
+        expected_result = np.array([[127, 127]], dtype=np.int8)
+        self.assertEqualImages(result, expected_result)
+
+    def test_abs_diff_uint8(self):
+        result = dito.abs_diff(image1=self.image1_uint8, image2=self.image2_uint8)
+        expected_result = np.array([[255, 255]], dtype=np.uint8)
+        self.assertEqualImages(result, expected_result)
+
+    def test_abs_diff_float32(self):
+        result = dito.abs_diff(image1=self.image1_float32, image2=self.image2_float32)
+        expected_result = np.array([[1.0, 1.0]], dtype=np.float32)
+        self.assertEqualImages(result, expected_result)
+
+    def test_abs_diff_float64(self):
+        result = dito.abs_diff(image1=self.image1_float64, image2=self.image2_float64)
+        expected_result = np.array([[1.0, 1.0]], dtype=np.float64)
+        self.assertEqualImages(result, expected_result)
+
+
 class adaptive_round_Tests(TestCase):
     def test_adaptive_round_python_float_zero(self):
         number = 0.0
         self.assertIsInstance(dito.adaptive_round(number=number, digit_count=4), float)
         self.assertEqual(dito.adaptive_round(number=number, digit_count=1), 0.0)
         self.assertEqual(dito.adaptive_round(number=number, digit_count=6), 0.0)
 
@@ -243,14 +290,41 @@
     def test_clip_input_unchanged(self):
         image = np.array([[-2.0, -1.0, 0.0, 1.0, 2.0]], dtype=np.float32)
         image_copy = image.copy()
         image_clipped = dito.clip_01(image=image)
         self.assertEqualImages(image, image_copy)
 
 
+class clipped_diff_Tests(DiffTestCase):
+    def test_clipped_diff_bool(self):
+        result = dito.clipped_diff(image1=self.image1_bool, image2=self.image2_bool)
+        expected_result = np.array([[False, True]], dtype=bool)
+        self.assertEqualImages(result, expected_result)
+
+    def test_clipped_diff_int8(self):
+        result = dito.clipped_diff(image1=self.image1_int8, image2=self.image2_int8)
+        expected_result = np.array([[-128, 127]], dtype=np.int8)
+        self.assertEqualImages(result, expected_result)
+
+    def test_clipped_diff_uint8(self):
+        result = dito.clipped_diff(image1=self.image1_uint8, image2=self.image2_uint8)
+        expected_result = np.array([[0, 255]], dtype=np.uint8)
+        self.assertEqualImages(result, expected_result)
+
+    def test_clipped_diff_float32(self):
+        result = dito.clipped_diff(image1=self.image1_float32, image2=self.image2_float32)
+        expected_result = np.array([[0.0, 1.0]], dtype=np.float32)
+        self.assertEqualImages(result, expected_result)
+
+    def test_clipped_diff_float64(self):
+        result = dito.clipped_diff(image1=self.image1_float64, image2=self.image2_float64)
+        expected_result = np.array([[0.0, 1.0]], dtype=np.float64)
+        self.assertEqualImages(result, expected_result)
+
+
 class colorize_Tests(TestCase):
     def test_colorize_colormap(self):
         image = dito.xslope(height=32, width=256)
         self.assertTrue(dito.is_gray(image=image))
         image_colorized = dito.colorize(image=image, colormap=dito.get_colormap(name="jet"))
         self.assertTrue(dito.is_color(image=image_colorized))
 
@@ -464,15 +538,15 @@
         self.assertEqual(range_, (-2**15, 2**15 - 1))
     
     def test_dtype_range_int32(self):
         range_ = dito.dtype_range(dtype=np.int32)
         self.assertEqual(range_, (-2**31, 2**31 - 1))
     
     def test_dtype_range_float(self):
-        range_ = dito.dtype_range(dtype=np.float)
+        range_ = dito.dtype_range(dtype=float)
         self.assertEqual(range_, (0, 1.0))
     
     def test_dtype_range_float32(self):
         range_ = dito.dtype_range(dtype=np.float32)
         self.assertEqual(range_, (0, 1.0))
         
     def test_dtype_range_float64(self):
@@ -567,14 +641,61 @@
             [12345678900, "11.50 GiB"],
         ]
         for (byte_count, expected_result) in cases:
             result = dito.human_bytes(byte_count=byte_count)
             self.assertEqual(result, expected_result)
 
 
+class info_Tests(TestCase):
+    def setUp(self):
+        self.image = dito.pm5544()
+
+    def test_info__noargs(self):
+        info = dito.info(self.image)
+        self.assertIsInstance(info, collections.OrderedDict)
+        self.assertEqual(len(info.keys()), 6)
+        self.assertEqual(info["shape"], (576, 768, 3))
+        self.assertEqual(info["dtype"], np.uint8)
+
+    def test_info__extended(self):
+        info = dito.info(self.image, extended=True)
+        self.assertEqual(len(info.keys()), 10)
+        self.assertEqual(info["shape"], (576, 768, 3))
+        self.assertEqual(info["dtype"], np.uint8)
+        self.assertAlmostEqual(info["mean"], 121.3680261682581)
+        self.assertAlmostEqual(info["std"], 91.194048489528782)
+        self.assertEqual(info["min"], 0)
+        self.assertAlmostEqual(info["3rd quartile"], 191.0)
+        self.assertEqual(info["max"], 255)
+
+    def test_info__minimal(self):
+        info = dito.info(self.image, minimal=True)
+        self.assertEqual(len(info.keys()), 2)
+        self.assertEqual(info["shape"], (576, 768, 3))
+        self.assertEqual(info["dtype"], np.uint8)
+
+    def test_info__raise_on_extended_and_minimal(self):
+        self.assertRaises(ValueError, lambda: dito.info(self.image, extended=True, minimal=True))
+
+    def test_info__raise_on_non_image(self):
+        self.assertRaises(ValueError, lambda: dito.info(image=1))
+
+    def test_info__array_with_zero_axis_length(self):
+        image = np.zeros(shape=(64, 32, 0), dtype=np.uint8)
+        info = dito.info(image, extended=True)
+
+        self.assertEqual(info["size"], "0 bytes")
+        self.assertEqual(info["shape"], image.shape)
+        self.assertEqual(info["dtype"], image.dtype)
+
+        for (key, value) in info.items():
+            if key not in ("size", "shape", "dtype"):
+                self.assertTrue(np.isnan(value))
+
+
 class insert_Tests(TestCase):
     def setUp(self):
         self.target_image = dito.pm5544()
         self.source_image = dito.random_image(size=dito.size(image=self.target_image))
         self.source_mask = dito.convert(image=dito.random_image(size=dito.size(image=self.target_image), color=False), dtype=np.float32)
 
     def test_insert_raise_on_int(self):
@@ -781,14 +902,43 @@
     def test_is_gray_of_gray_image_with_color_channel(self):
         self.assertTrue(dito.is_gray(self.image[:, :, 0:1]))
 
     def test_is_gray_of_image_with_two_channels(self):
         self.assertFalse(dito.is_gray(self.image[:, :, 0:2]))
 
 
+class load_Tests(TestCase):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.image_filename = os.path.join(dito.RESOURCES_FILENAMES["image:PM5544"])
+        self.shape = (576, 768, 3)
+
+    def test_load_default(self):
+        image = dito.load(filename=self.image_filename)
+        self.assertNumpyShape(image, self.shape)
+        self.assertAlmostEqual(np.mean(image), 121.3680261682581)
+
+    def test_load_grayscale(self):
+        image = dito.load(filename=self.image_filename, color=False)
+        self.assertNumpyShape(image, self.shape[:2])
+
+    def test_load_and_decode_equal(self):
+        image_load = dito.load(filename=self.image_filename)
+        with open(self.image_filename, "rb") as f:
+            image_decode = dito.decode(b=f.read())
+        self.assertNumpyShape(image_load, self.shape)
+        self.assertNumpyShape(image_decode, self.shape)
+        self.assertTrue(np.all(image_load == image_decode))
+
+    def test_load_str_and_pathlib_equal(self):
+        image_str = dito.load(filename=str(self.image_filename))
+        image_pathlib = dito.load(filename=pathlib.Path(self.image_filename))
+        self.assertEqualImages(image_str, image_pathlib)
+
+
 class is_color_Tests(TestCase):
     def setUp(self):
         self.image = dito.pm5544()
 
     def test_is_color_of_color_image(self):
         self.assertTrue(dito.is_color(self.image))
 
@@ -1038,23 +1188,31 @@
         self.assertEqualImages(image_rotated_90_2x, image_rotated_180)
         self.assertEqualImages(image_rotated_270_2x, image_rotated_180)
 
 
 class save_Tests(TempDirTestCase):
     def _test_save_load(self, extension):
         image = dito.pm5544()
-        filename = os.path.join(self.temp_dir.name, "image.{}".format(extension))
-        dito.save(filename=filename, image=image)
-        image_loaded = dito.load(filename=filename)
+
+        filename_str = str(os.path.join(self.temp_dir.name, "image_str.{}".format(extension)))
+        dito.save(filename=filename_str, image=image)
+        image_str_loaded = dito.load(filename=filename_str)
+
+        filename_pathlib = pathlib.Path(os.path.join(self.temp_dir.name, "image_pathlib.{}".format(extension)))
+        dito.save(filename=filename_pathlib, image=image)
+        image_pathlib_loaded = dito.load(filename=filename_pathlib)
+
         if extension == "jpg":
             # JPG compression is lossy
-            self.assertEqualImageContainers(image, image_loaded)
+            self.assertEqualImageContainers(image, image_str_loaded)
+            self.assertEqualImageContainers(image, image_pathlib_loaded)
         else:
             # all other formats should be lossless
-            self.assertEqualImages(image, image_loaded)
+            self.assertEqualImages(image, image_str_loaded)
+            self.assertEqualImages(image, image_pathlib_loaded)
 
     def test_save_load_jpg(self):
         self._test_save_load(extension="jpg")
 
     def test_save_load_png(self):
         self._test_save_load(extension="png")
 
@@ -1069,14 +1227,41 @@
     def test_save_tmp_reload(self):
         image = dito.pm5544()
         filename = dito.save_tmp(image=image)
         image_loaded = dito.load(filename=filename)
         self.assertEqualImages(image, image_loaded)
 
 
+class shifted_diff_Tests(DiffTestCase):
+    def test_shifted_diff_bool(self):
+        result = dito.shifted_diff(image1=self.image1_bool, image2=self.image2_bool)
+        expected_result = np.array([[False, True]], dtype=bool)
+        self.assertEqualImages(result, expected_result)
+
+    def test_shifted_diff_int8(self):
+        result = dito.shifted_diff(image1=self.image1_int8, image2=self.image2_int8)
+        expected_result = np.array([[-128, 127]], dtype=np.int8)
+        self.assertEqualImages(result, expected_result)
+
+    def test_shifted_diff_uint8(self):
+        result = dito.shifted_diff(image1=self.image1_uint8, image2=self.image2_uint8)
+        expected_result = np.array([[0, 255]], dtype=np.uint8)
+        self.assertEqualImages(result, expected_result)
+
+    def test_shifted_diff_float32(self):
+        result = dito.shifted_diff(image1=self.image1_float32, image2=self.image2_float32)
+        expected_result = np.array([[0.0, 1.0]], dtype=np.float32)
+        self.assertEqualImages(result, expected_result)
+
+    def test_shifted_diff_float64(self):
+        result = dito.shifted_diff(image1=self.image1_float64, image2=self.image2_float64)
+        expected_result = np.array([[0.0, 1.0]], dtype=np.float64)
+        self.assertEqualImages(result, expected_result)
+
+
 class split_channels_Tests(TestCase):
     def test_split_channels_color_image(self):
         image = dito.pm5544()
         channel_images = dito.split_channels(image=image)
         self.assertEqual(len(channel_images), image.shape[2])
         for n_channel in range(3):
             self.assertEqualImages(image[:, :, n_channel], channel_images[n_channel])
@@ -1413,24 +1598,14 @@
     def test_resize_size(self):
         image = dito.pm5544()
         image2 = dito.resize(image, (384, 288))
         self.assertEqual(image2.shape, (288, 384, 3))
 
 
 class infos_Tests(TestCase):
-    def test_info(self):
-        image = dito.pm5544()
-        info = dito.info(image, extended=True)
-        self.assertEqual(info["shape"], (576, 768, 3))
-        self.assertAlmostEqual(info["mean"], 121.3680261682581)
-        self.assertAlmostEqual(info["std"], 91.194048489528782)
-        self.assertEqual(info["min"], 0)
-        self.assertAlmostEqual(info["3rd quartile"], 191.0)
-        self.assertEqual(info["max"], 255)
-        
     def test_hist_color(self):
         image = dito.pm5544()
         h = dito.hist(image, bin_count=256)
         self.assertAlmostEqual(h[0], 328389.0)
         self.assertAlmostEqual(h[6], 1512.0)
         self.assertAlmostEqual(h[86], 0.0)
         self.assertAlmostEqual(h[122], 330802.0)
@@ -1479,41 +1654,26 @@
 
 class io_Tests(TestCase):
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
         self.image_filename = os.path.join(dito.RESOURCES_FILENAMES["image:PM5544"])
         self.shape = (576, 768, 3)
     
-    def test_load_default(self):
-        image = dito.load(filename=self.image_filename)
-        self.assertNumpyShape(image, self.shape)
-        self.assertAlmostEqual(np.mean(image), 121.3680261682581)
-        
-    def test_load_grayscale(self):
-        image = dito.load(filename=self.image_filename, color=False)
-        self.assertNumpyShape(image, self.shape[:2])
-        
     def test_decode_default(self):
         with open(self.image_filename, "rb") as f:
             image = dito.decode(b=f.read())
         self.assertNumpyShape(image, self.shape)
         self.assertAlmostEqual(np.mean(image), 121.3680261682581)
         
     def test_decode_grayscale(self):
         with open(self.image_filename, "rb") as f:
             image = dito.decode(b=f.read(), color=False)
         self.assertNumpyShape(image, self.shape[:2])
         
-    def test_load_and_decode_equal(self):
-        image_load = dito.load(filename=self.image_filename)
-        with open(self.image_filename, "rb") as f:
-            image_decode = dito.decode(b=f.read())
-        self.assertNumpyShape(image_load, self.shape)    
-        self.assertNumpyShape(image_decode, self.shape)
-        self.assertTrue(np.all(image_load == image_decode))
+
 
 
 class transforms_Tests(TestCase):
     pass
 
         
 class utils_Tests(TestCase):
```

## dito/visual.py

```diff
@@ -1,10 +1,11 @@
 import collections
 import math
 import os.path
+import pathlib
 import warnings
 
 import cv2
 import numpy as np
 
 import dito.core
 import dito.data
@@ -429,14 +430,45 @@
     return target_image
 
 
 def overlay(target_image, source_image, source_mask=None):
     return insert(target_image=target_image, source_image=source_image, source_mask=source_mask)
 
 
+def overlay_constant(target_image, source_color, source_mask):
+    """
+    Overlay a constant color image onto a target image using a source mask.
+
+    The function creates a constant image with the specified color and blends it with the target image using the
+    specified source mask. The resulting image has the same shape and dtype as the target image.
+
+    Parameters
+    ----------
+    target_image : numpy.ndarray
+        The target image with shape `(height, width)` or `(height, width, channel_count)`.
+    source_color : tuple
+        The color of the constant image as a tuple of values for each channel. For `np.uint8` images, the values range
+        between 0 and 255, while for floats the range is between 0.0 and 1.0 (for more details, see
+        `dito.dtype_range()`).
+    source_mask : numpy.ndarray or float
+        A floating-point mask image with shape `(height, width)` or `(height, width, channel_count)` or a scalar float
+        value. For more information, see the documentation for the `dito.insert()` function.
+
+    Returns
+    -------
+    numpy.ndarray
+        The blended image with the same shape and dtype as the target image.
+    """
+    return insert(
+        target_image=target_image,
+        source_image=dito.data.constant_image(size=dito.core.size(target_image), color=source_color, dtype=target_image.dtype),
+        source_mask=source_mask,
+    )
+
+
 ####
 #%%% text
 ####
 
 
 class Font():
     # ANSI escape codes - see https://en.wikipedia.org/wiki/ANSI_escape_code
@@ -502,14 +534,16 @@
     def BACKGROUND_BGR(cls, b, g, r):
         return cls.COLOR_BGR(b=b, g=g, r=r, foreground=False)
 
 
 class MonospaceBitmapFont(Font):
     def __init__(self, filename):
         self.filename = filename
+        if isinstance(self.filename, pathlib.Path):
+            self.filename = str(self.filename)
         (self.char_width, self.char_height, self.char_images) = self.load_df2(filename=self.filename)
 
     @classmethod
     def init_from_name(cls, name):
         key = "font:{}".format(name)
         try:
             filename = dito.data.RESOURCES_FILENAMES[key]
```

## dito/resources/fonts/source_code_pro/LICENSE.txt

 * *Ordering differences only*

```diff
@@ -1,93 +1,93 @@
-Copyright 2010-2019 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.
-
-This Font Software is licensed under the SIL Open Font License, Version 1.1.
-
-This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL
-
-
------------------------------------------------------------
-SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
------------------------------------------------------------
-
-PREAMBLE
-The goals of the Open Font License (OFL) are to stimulate worldwide
-development of collaborative font projects, to support the font creation
-efforts of academic and linguistic communities, and to provide a free and
-open framework in which fonts may be shared and improved in partnership
-with others.
-
-The OFL allows the licensed fonts to be used, studied, modified and
-redistributed freely as long as they are not sold by themselves. The
-fonts, including any derivative works, can be bundled, embedded,
-redistributed and/or sold with any software provided that any reserved
-names are not used by derivative works. The fonts and derivatives,
-however, cannot be released under any other type of license. The
-requirement for fonts to remain under this license does not apply
-to any document created using the fonts or their derivatives.
-
-DEFINITIONS
-"Font Software" refers to the set of files released by the Copyright
-Holder(s) under this license and clearly marked as such. This may
-include source files, build scripts and documentation.
-
-"Reserved Font Name" refers to any names specified as such after the
-copyright statement(s).
-
-"Original Version" refers to the collection of Font Software components as
-distributed by the Copyright Holder(s).
-
-"Modified Version" refers to any derivative made by adding to, deleting,
-or substituting -- in part or in whole -- any of the components of the
-Original Version, by changing formats or by porting the Font Software to a
-new environment.
-
-"Author" refers to any designer, engineer, programmer, technical
-writer or other person who contributed to the Font Software.
-
-PERMISSION & CONDITIONS
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of the Font Software, to use, study, copy, merge, embed, modify,
-redistribute, and sell modified and unmodified copies of the Font
-Software, subject to the following conditions:
-
-1) Neither the Font Software nor any of its individual components,
-in Original or Modified Versions, may be sold by itself.
-
-2) Original or Modified Versions of the Font Software may be bundled,
-redistributed and/or sold with any software, provided that each copy
-contains the above copyright notice and this license. These can be
-included either as stand-alone text files, human-readable headers or
-in the appropriate machine-readable metadata fields within text or
-binary files as long as those fields can be easily viewed by the user.
-
-3) No Modified Version of the Font Software may use the Reserved Font
-Name(s) unless explicit written permission is granted by the corresponding
-Copyright Holder. This restriction only applies to the primary font name as
-presented to the users.
-
-4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
-Software shall not be used to promote, endorse or advertise any
-Modified Version, except to acknowledge the contribution(s) of the
-Copyright Holder(s) and the Author(s) or with their explicit written
-permission.
-
-5) The Font Software, modified or unmodified, in part or in whole,
-must be distributed entirely under this license, and must not be
-distributed under any other license. The requirement for fonts to
-remain under this license does not apply to any document created
-using the Font Software.
-
-TERMINATION
-This license becomes null and void if any of the above conditions are
-not met.
-
-DISCLAIMER
-THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
-OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
-COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
-DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
-OTHER DEALINGS IN THE FONT SOFTWARE.
+Copyright 2010-2019 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.
+
+This Font Software is licensed under the SIL Open Font License, Version 1.1.
+
+This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL
+
+
+-----------------------------------------------------------
+SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
+-----------------------------------------------------------
+
+PREAMBLE
+The goals of the Open Font License (OFL) are to stimulate worldwide
+development of collaborative font projects, to support the font creation
+efforts of academic and linguistic communities, and to provide a free and
+open framework in which fonts may be shared and improved in partnership
+with others.
+
+The OFL allows the licensed fonts to be used, studied, modified and
+redistributed freely as long as they are not sold by themselves. The
+fonts, including any derivative works, can be bundled, embedded,
+redistributed and/or sold with any software provided that any reserved
+names are not used by derivative works. The fonts and derivatives,
+however, cannot be released under any other type of license. The
+requirement for fonts to remain under this license does not apply
+to any document created using the fonts or their derivatives.
+
+DEFINITIONS
+"Font Software" refers to the set of files released by the Copyright
+Holder(s) under this license and clearly marked as such. This may
+include source files, build scripts and documentation.
+
+"Reserved Font Name" refers to any names specified as such after the
+copyright statement(s).
+
+"Original Version" refers to the collection of Font Software components as
+distributed by the Copyright Holder(s).
+
+"Modified Version" refers to any derivative made by adding to, deleting,
+or substituting -- in part or in whole -- any of the components of the
+Original Version, by changing formats or by porting the Font Software to a
+new environment.
+
+"Author" refers to any designer, engineer, programmer, technical
+writer or other person who contributed to the Font Software.
+
+PERMISSION & CONDITIONS
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of the Font Software, to use, study, copy, merge, embed, modify,
+redistribute, and sell modified and unmodified copies of the Font
+Software, subject to the following conditions:
+
+1) Neither the Font Software nor any of its individual components,
+in Original or Modified Versions, may be sold by itself.
+
+2) Original or Modified Versions of the Font Software may be bundled,
+redistributed and/or sold with any software, provided that each copy
+contains the above copyright notice and this license. These can be
+included either as stand-alone text files, human-readable headers or
+in the appropriate machine-readable metadata fields within text or
+binary files as long as those fields can be easily viewed by the user.
+
+3) No Modified Version of the Font Software may use the Reserved Font
+Name(s) unless explicit written permission is granted by the corresponding
+Copyright Holder. This restriction only applies to the primary font name as
+presented to the users.
+
+4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
+Software shall not be used to promote, endorse or advertise any
+Modified Version, except to acknowledge the contribution(s) of the
+Copyright Holder(s) and the Author(s) or with their explicit written
+permission.
+
+5) The Font Software, modified or unmodified, in part or in whole,
+must be distributed entirely under this license, and must not be
+distributed under any other license. The requirement for fonts to
+remain under this license does not apply to any document created
+using the Font Software.
+
+TERMINATION
+This license becomes null and void if any of the above conditions are
+not met.
+
+DISCLAIMER
+THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
+COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
+DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
+OTHER DEALINGS IN THE FONT SOFTWARE.
```

## Comparing `dito/inspect.py` & `dito/inspection.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,60 +1,72 @@
 import collections
+import pathlib
 
 import cv2
 import numpy as np
 
 import dito.core
 import dito.utils
 
 
-def info(image, extended=False):
+def info(image, extended=False, minimal=False):
     """
     Returns an ordered dictionary containing info about the given image.
     """
 
+    if not isinstance(image, np.ndarray):
+        raise ValueError("Argument 'image' must be of type 'numpy.ndimage', but is '{}'".format(type(image)))
+
+    if extended and minimal:
+        raise ValueError("Both arguments 'extended' and 'minimal' must not be true at the same time")
+
     result = collections.OrderedDict()
     if extended:
         result["size"] = dito.utils.human_bytes(byte_count=image.size * image.itemsize)
+
+    # these are the only stats shown when 'minimal' is true
     result["shape"] = image.shape
     result["dtype"] = image.dtype
-    result["mean"] = np.mean(image)
-    result["std"] = np.std(image)
-    result["min"] = np.min(image)
+
+    if not minimal:
+        result["mean"] = np.mean(image) if image.size > 0 else np.nan
+        result["std"] = np.std(image) if image.size > 0 else np.nan
+        result["min"] = np.min(image) if image.size > 0 else np.nan
     if extended:
-        result["1st quartile"] = np.percentile(image, 25.0)
-        result["median"] = np.median(image)
-        result["3rd quartile"] = np.percentile(image, 75.0)
-    result["max"] = np.max(image)
+        result["1st quartile"] = np.percentile(image, 25.0) if image.size > 0 else np.nan
+        result["median"] = np.median(image) if image.size > 0 else np.nan
+        result["3rd quartile"] = np.percentile(image, 75.0) if image.size > 0 else np.nan
+    if not minimal:
+        result["max"] = np.max(image) if image.size > 0 else np.nan
     return result
 
 
-def pinfo(*args, extended_=False, file_=None, **kwargs):
+def pinfo(*args, extended_=False, minimal_=False, file_=None, **kwargs):
     """
     Prints info about the given images.
     """
 
     # merge args and kwargs into one dictionary
     all_kwargs = collections.OrderedDict()
     for (n_image, image) in enumerate(args):
-        if isinstance(image, str):
-            # if `image` is a filename (str), use the filename as key
-            all_kwargs[image] = image
+        if isinstance(image, str) or isinstance(image, pathlib.Path):
+            # if `image` is a filename (str or pathlib.Path), use the filename as key
+            all_kwargs[str(image)] = image
         else:
             # otherwise, use the position of the image in the argument list as key
             all_kwargs["{}".format(n_image)] = image
     all_kwargs.update(kwargs)
 
     header = None
     rows = []
     for (image_name, image) in all_kwargs.items():
         if isinstance(image, str):
             # `image` is a filename -> load it first
             image = dito.io.load(filename=image)
-        image_info = info(image=image, extended=extended_)
+        image_info = info(image=image, extended=extended_, minimal=minimal_)
         if header is None:
             header = ("Image",) + tuple(image_info.keys())
             rows.append(header)
         row = [image_name] + list(image_info.values())
 
         # round float values to keep the table columns from exploding
         for (n_col, col) in enumerate(row):
```

## Comparing `dito-2.8.0.data/scripts/dito_images_to_video.py` & `dito-2.9.0.data/scripts/dito_images_to_video.py`

 * *Files identical despite different names*

## Comparing `dito-2.8.0.data/scripts/dito_pinfo.py` & `dito-2.9.0.data/scripts/dito_pinfo.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,16 +7,17 @@
 
 import dito
 
 
 def get_args():
     parser = argparse.ArgumentParser(description="Print basic information for the images with the given filenames.", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
     parser.add_argument("-d", "--debug", action="store_true", help="If set, show full stack trace for errors.")
-    parser.add_argument("-e", "--extended", action="store_true", help="If set, show more information.")
-    parser.add_argument("-i", "--image-filenames", type=str, nargs="+", help="Input image filenames. Patterns are allowed.")
+    parser.add_argument("-e", "--extended", action="store_true", help="If set, show extended information (e.g., quartiles).")
+    parser.add_argument("-m", "--minimal", action="store_true", help="If set, show minimal information (shape and dtype only).")
+    parser.add_argument("image_filenames", type=str, nargs="+", help="Input image filenames. Patterns are allowed.")
     args = parser.parse_args()
     return args
 
 
 def main():
     args = get_args()
 
@@ -27,15 +28,15 @@
     for image_filename in args.image_filenames:
         filenames += glob.glob(os.path.expanduser(image_filename))
     filenames = sorted(filenames)
     file_count = len(filenames)
     if file_count == 0:
         raise FileNotFoundError("Found no images with the filenames(s) {}".format(args.image_filenames))
 
-    dito.pinfo(*filenames, extended_=args.extended)
+    dito.pinfo(*filenames, extended_=args.extended, minimal_=args.minimal)
 
 
 if __name__ == "__main__":
     try:
         main()
     except Exception as e:
         args = get_args()
```

## Comparing `dito-2.8.0.dist-info/LICENSE.txt` & `dito-2.9.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `dito-2.8.0.dist-info/METADATA` & `dito-2.9.0.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 Metadata-Version: 2.1
 Name: dito
-Version: 2.8.0
+Version: 2.9.0
 Summary: Yet another toolbox for the daily work with OpenCV under Python
 Home-page: https://github.com/dhaase-de/dito
 Author: Daniel Haase
-Author-email: UNKNOWN
 License: UNKNOWN
 Platform: UNKNOWN
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Utilities
+License-File: LICENSE.txt
 
 UNKNOWN
 
-
```

## Comparing `dito-2.8.0.dist-info/RECORD` & `dito-2.9.0.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-dito/__init__.py,sha256=sbE5ZN2P6H3yjRhV-Gsi5F2hKD8fVpk4Q4IaQl3ziIE,339
+dito/__init__.py,sha256=NcnDAh2WMVF34aGgDIbRNbkzWCpidwYWhwZp2k0IgSo,372
 dito/analysis.py,sha256=80SCjDqBP2QG-WVk09ND9yw4C7mlkSnqAIypnwYtCow,7001
+dito/conversion.py,sha256=aZ-kvnk51HSyVSHvhBAQjYT100MtqnRT5LAHidsUGLk,1573
 dito/core.py,sha256=-C-ioPRwF8kukb_uuGIGJMR6yTOCnRoxNFOK-vsBIVo,18169
-dito/data.py,sha256=RKwDhd--T142_yrIdm-7z0Y5mlXsRVeZtWwB63QmXwA,24999
+dito/data.py,sha256=6hww-2McPFIju_MdGA9ijPlf1ju87xd-OtU8LSXk5-w,24995
 dito/draw.py,sha256=CAsx4j59uOIm1ZHzPE2XxISsW0J0AKyhkTq24bJUwLE,11111
-dito/exceptions.py,sha256=JCwD0LVOcruulixkZHimt8Lh4nTjykCa4FT7qG5urek,129
+dito/exceptions.py,sha256=edkPdgV7RLHTNxv983y_Fwj1S47cewjJA-ylYNGzmeU,172
 dito/highgui.py,sha256=OcFbwUjrSIWLGAWoS1Ctgn-MbpftEzuNdAPcHKHvXJ4,5335
-dito/inspect.py,sha256=x4cfE-DjWdj017e0LxcqgYD8MGQDEWhqazQTagJDQjk,3395
-dito/io.py,sha256=-MUEOlVaaQE2pD401B8BpS4vwwTUxAHz1Aiel2oVyqs,8359
+dito/inspection.py,sha256=HkMAzipYkCqsGn5A5_uWqO1i7PijJKAAmCjLEDbdxHo,4128
+dito/io.py,sha256=bS7gE3YezPKIqPaFasIl-o_AswIobKipNSuQdca9JQs,8628
 dito/parallel.py,sha256=7Cu-ymNzc-Y-U5ZHj46FDNa_7tWosLUGnukuoVl1wLw,1758
-dito/processing.py,sha256=jtayIqRgRjpNBr8rgLvGZmIEhYgghAtSVjIVzZBFrUo,12184
-dito/tests.py,sha256=xU87iMMB9DLG1ecthR-KOM8kQvU4g7_3kXsFyF33Jqs,62839
+dito/processing.py,sha256=AANrC6hReUnCNlBlES5w3IXV3STAARdzAiaD9JX5OSA,16064
+dito/tests.py,sha256=P_Z4qQ_s_mCaQFsanLTX7OH2me1lF9Zsszhm1jR2f6U,69703
 dito/utils.py,sha256=tciSWRUQ23QXystxx6xTmpJDbNW48BgvO5WIlBxAjIk,5569
-dito/visual.py,sha256=g-_Vq4iR6qQSMKjkR7RljMCdpCmjisO7RSYaajGiOyk,51145
+dito/visual.py,sha256=9eC9OQnwVuPWlKJpP1Jxq7bYQ0tFIANWzUPMrgyhiXw,52651
 dito/resources/colormaps/plot.png,sha256=n9Qi9Bb3q75R0ih_NdZRXCzR3EI2jzr8MU51LLQbh6I,92
 dito/resources/colormaps/plot2.png,sha256=n9Qi9Bb3q75R0ih_NdZRXCzR3EI2jzr8MU51LLQbh6I,92
 dito/resources/colormaps/colorbrewer/LICENSE.txt,sha256=q6iBkzmZvjVJshcYMqEanfrVdCQwGd-VwGfM89R7lkk,1710
 dito/resources/colormaps/colorbrewer/accent.png,sha256=apaDBoxWpUn_JbLVNmStpHugssW8t5Bap5MMKS2kG-4,233
 dito/resources/colormaps/colorbrewer/blues.png,sha256=cxsXOeJd0VYFqETgEvlyJiszrBqdzQQSwBVNlPcIZk8,189
 dito/resources/colormaps/colorbrewer/brbg.png,sha256=EcpCC6l-VIdNpr82tJQgIUu_TtIaBhMGgiU1ouc5_no,251
 dito/resources/colormaps/colorbrewer/bugn.png,sha256=WtuiBjYAe538Ja9I_opNBkZyfdrILqdlbgF6jCpzQjQ,237
@@ -58,27 +59,27 @@
 dito/resources/fonts/source_code_pro/20_df2.png,sha256=Y1mCAwND-xU-NyDQAeUiyN2PIiNe3yTziy-YZH2pcEA,11762
 dito/resources/fonts/source_code_pro/25_df2.png,sha256=DZ1Xf4GxQlVpY0ACGV-RmzkRaIoCpWnrNRwc6QuSDCo,15667
 dito/resources/fonts/source_code_pro/30_df2.png,sha256=mOBwLWDjQp-4swm6zl8eLQVizjjxsexy6hZx59jqdqA,20385
 dito/resources/fonts/source_code_pro/35_df2.png,sha256=EBWP2pMIETbhmBYba7QYg4tV7SC2PXsIXYSV46PUo90,24424
 dito/resources/fonts/source_code_pro/40_df2.png,sha256=Unhx3vUx7XFPzJEplvtNlm9PwiPS5hNLAn9br2FCY4E,29567
 dito/resources/fonts/source_code_pro/50_df2.png,sha256=zUhM5nqdrX8qxF9KPqDqbbcCr1lmL0W9x05Nvr-gTd4,38502
 dito/resources/fonts/source_code_pro/70_df2.png,sha256=6yhUgmTqCuiAALAux2W2bJxNtoRiBL8_p_OW1MNhdNk,58458
-dito/resources/fonts/source_code_pro/LICENSE.txt,sha256=tMeu2t6aiYM8FOHsjrW9fp_-zljq4NW4AOAMpCq9QYs,4578
+dito/resources/fonts/source_code_pro/LICENSE.txt,sha256=LhTuZeVdvMfWY0fNfHahChoYrEndeYmis4OLR5Z290Y,4485
 dito/resources/fonts/terminus/LICENSE.txt,sha256=KeUSYGkvyjDFHDyBxaoSIFz6ob5xgL9efIGS50Xngwg,4386
 dito/resources/fonts/terminus/ter-u12_df2.png,sha256=g3FLIEaghiLpodDyjGbFdTkWZss-rCkPleNs92maNhs,1280
 dito/resources/fonts/terminus/ter-u14_df2.png,sha256=gfFz85x82XhEgLGxhZcwXgIqyv5fzsLQmSjHm_jQ-ZQ,1947
 dito/resources/fonts/terminus/ter-u16_df2.png,sha256=KY2WZAYtkC7t-k0XAhx84BEROmwHwI8tAUBWDJFxb9g,1962
 dito/resources/fonts/terminus/ter-u18_df2.png,sha256=4UC1BAr-fZnRzCNYdseDs66V1h8G-jOIp-lZk6nZ-X4,2453
 dito/resources/fonts/terminus/ter-u20_df2.png,sha256=Y-rPfse4pfMJPBTcllKa2RrbuPhcB8kpyi--v6AJoJ4,2498
 dito/resources/fonts/terminus/ter-u22_df2.png,sha256=usGc6ovfypjkqLA_2d0mX8tfWq0ctfY9xLD-pygFIq4,3182
 dito/resources/fonts/terminus/ter-u24_df2.png,sha256=VxUxo-MmyyGir6Z0xDaYFegPQXpFAxxuSVzW2Omp48M,3006
 dito/resources/fonts/terminus/ter-u28_df2.png,sha256=zwK1VpTpp0SFS2Ux6cc2k4AzxgUZ6eE5IGXtG9ap5k4,4494
 dito/resources/fonts/terminus/ter-u32_df2.png,sha256=g6kQvmsr9lf_WZ7Il7G9SiNxcwIyPYOtx891YJRZC6A,4506
 dito/resources/images/PM5544.png,sha256=DEf2R0W6FhGyKiM7yUIlS7GTrrsX58SLxxyro-fbjwE,14218
 dito/resources/images/USC_SIPI_4.1.07.png,sha256=v-81tCnrlu9Iu8Y1SVSXfhrZnxWc4ejH71mJnZ1_sEw,68546
-dito-2.8.0.data/scripts/dito_images_to_video.py,sha256=7o9Xt1mukjN0M3dyQU54XK16pT5p3cP56iyc2-YLiQE,2137
-dito-2.8.0.data/scripts/dito_pinfo.py,sha256=jqqtdztuuGliCxaf9T7HqFkpdfjSQqlPSPltrEoqaOQ,1419
-dito-2.8.0.dist-info/LICENSE.txt,sha256=pU-var4fWrVjvM6o_bXoYxXpnMU9zJOCi9LtEbojL18,1061
-dito-2.8.0.dist-info/METADATA,sha256=E4ac-IiAy3HrNeIT-28vad-CuIsrhjUVWVqXvZSlRzg,634
-dito-2.8.0.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-dito-2.8.0.dist-info/top_level.txt,sha256=H-c60HLE8f_5HFsgQ9LnSJUPd6Yek_lGkO46r8uhs68,5
-dito-2.8.0.dist-info/RECORD,,
+dito-2.9.0.data/scripts/dito_images_to_video.py,sha256=7o9Xt1mukjN0M3dyQU54XK16pT5p3cP56iyc2-YLiQE,2137
+dito-2.9.0.data/scripts/dito_pinfo.py,sha256=MLE98FnKlsxCzbgnYFIkrkKB5fSrJKZtpNXlnGPBLoY,1585
+dito-2.9.0.dist-info/LICENSE.txt,sha256=pU-var4fWrVjvM6o_bXoYxXpnMU9zJOCi9LtEbojL18,1061
+dito-2.9.0.dist-info/METADATA,sha256=gq-iRS71Xfo31wP3yemYQzuNC1zTLjI761-SRUaZtBU,637
+dito-2.9.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+dito-2.9.0.dist-info/top_level.txt,sha256=H-c60HLE8f_5HFsgQ9LnSJUPd6Yek_lGkO46r8uhs68,5
+dito-2.9.0.dist-info/RECORD,,
```

