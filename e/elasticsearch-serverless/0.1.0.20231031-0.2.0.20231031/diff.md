# Comparing `tmp/elasticsearch_serverless-0.1.0.20231031.tar.gz` & `tmp/elasticsearch_serverless-0.2.0.20231031.tar.gz`

## Comparing `elasticsearch_serverless-0.1.0.20231031.tar` & `elasticsearch_serverless-0.2.0.20231031.tar`

### file list

```diff
@@ -1,108 +1,74 @@
--rw-r--r--   0        0        0       95 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/CHANGELOG.md
--rw-r--r--   0        0        0     1285 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/CONTRIBUTING.md
--rw-r--r--   0        0        0       41 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/setup.cfg
--rw-r--r--   0        0        0     6790 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/Makefile
--rw-r--r--   0        0        0     2952 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/api.rst
--rw-r--r--   0        0        0     7368 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/async.rst
--rw-r--r--   0        0        0     1673 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/conf.py
--rw-r--r--   0        0        0      788 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/exceptions.rst
--rw-r--r--   0        0        0     3555 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/helpers.rst
--rw-r--r--   0        0        0     3799 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/docs/sphinx/index.rst
--rw-r--r--   0        0        0     3085 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/__init__.py
--rw-r--r--   0        0        0     1419 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_utils.py
--rw-r--r--   0        0        0      822 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_version.py
--rw-r--r--   0        0        0     4837 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/client.py
--rw-r--r--   0        0        0     2657 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/compat.py
--rw-r--r--   0        0        0     4025 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/exceptions.py
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/py.typed
--rw-r--r--   0        0        0     6723 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/serializer.py
--rw-r--r--   0        0        0      787 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/__init__.py
--rw-r--r--   0        0        0    22362 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/helpers.py
--rw-r--r--   0        0        0   206729 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/__init__.py
--rw-r--r--   0        0        0    10639 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/_base.py
--rw-r--r--   0        0        0    28603 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/async_search.py
--rw-r--r--   0        0        0     6807 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/autoscaling.py
--rw-r--r--   0        0        0    63792 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/cat.py
--rw-r--r--   0        0        0    32716 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ccr.py
--rw-r--r--   0        0        0    14617 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/cluster.py
--rw-r--r--   0        0        0     6514 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/dangling_indices.py
--rw-r--r--   0        0        0     8767 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/enrich.py
--rw-r--r--   0        0        0    12551 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/eql.py
--rw-r--r--   0        0        0     3315 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/features.py
--rw-r--r--   0        0        0    30481 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/fleet.py
--rw-r--r--   0        0        0     4330 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/graph.py
--rw-r--r--   0        0        0    21709 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ilm.py
--rw-r--r--   0        0        0   129486 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/indices.py
--rw-r--r--   0        0        0    13023 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ingest.py
--rw-r--r--   0        0        0     2870 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/license.py
--rw-r--r--   0        0        0     5411 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/logstash.py
--rw-r--r--   0        0        0     4872 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/migration.py
--rw-r--r--   0        0        0   159388 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ml.py
--rw-r--r--   0        0        0     3423 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/monitoring.py
--rw-r--r--   0        0        0    21647 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/nodes.py
--rw-r--r--   0        0        0     6917 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/query_ruleset.py
--rw-r--r--   0        0        0    18687 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/rollup.py
--rw-r--r--   0        0        0    13286 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/search_application.py
--rw-r--r--   0        0        0    10966 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/searchable_snapshots.py
--rw-r--r--   0        0        0    22347 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/security.py
--rw-r--r--   0        0        0    10600 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/shutdown.py
--rw-r--r--   0        0        0    14782 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/slm.py
--rw-r--r--   0        0        0    34071 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/snapshot.py
--rw-r--r--   0        0        0    16023 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/sql.py
--rw-r--r--   0        0        0     2149 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ssl.py
--rw-r--r--   0        0        0    12316 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/synonyms.py
--rw-r--r--   0        0        0     2849 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/tasks.py
--rw-r--r--   0        0        0     8827 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/text_structure.py
--rw-r--r--   0        0        0    32031 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/transform.py
--rw-r--r--   0        0        0     1297 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/utils.py
--rw-r--r--   0        0        0    23663 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/watcher.py
--rw-r--r--   0        0        0     4303 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/xpack.py
--rw-r--r--   0        0        0      787 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/__init__.py
--rw-r--r--   0        0        0   206194 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/__init__.py
--rw-r--r--   0        0        0    10600 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/_base.py
--rw-r--r--   0        0        0    28555 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/async_search.py
--rw-r--r--   0        0        0     6759 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/autoscaling.py
--rw-r--r--   0        0        0    63672 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/cat.py
--rw-r--r--   0        0        0    32560 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ccr.py
--rw-r--r--   0        0        0    14557 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/cluster.py
--rw-r--r--   0        0        0     6478 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/dangling_indices.py
--rw-r--r--   0        0        0     8707 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/enrich.py
--rw-r--r--   0        0        0    12503 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/eql.py
--rw-r--r--   0        0        0     3291 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/features.py
--rw-r--r--   0        0        0    30445 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/fleet.py
--rw-r--r--   0        0        0     4318 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/graph.py
--rw-r--r--   0        0        0    21577 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ilm.py
--rw-r--r--   0        0        0   129054 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/indices.py
--rw-r--r--   0        0        0    12963 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ingest.py
--rw-r--r--   0        0        0     2858 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/license.py
--rw-r--r--   0        0        0     5375 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/logstash.py
--rw-r--r--   0        0        0     4836 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/migration.py
--rw-r--r--   0        0        0   158776 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ml.py
--rw-r--r--   0        0        0     3411 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/monitoring.py
--rw-r--r--   0        0        0    21563 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/nodes.py
--rw-r--r--   0        0        0     6869 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/query_ruleset.py
--rw-r--r--   0        0        0    18591 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/rollup.py
--rw-r--r--   0        0        0    13190 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/search_application.py
--rw-r--r--   0        0        0    10918 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/searchable_snapshots.py
--rw-r--r--   0        0        0    22263 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/security.py
--rw-r--r--   0        0        0    10564 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/shutdown.py
--rw-r--r--   0        0        0    14674 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/slm.py
--rw-r--r--   0        0        0    33939 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/snapshot.py
--rw-r--r--   0        0        0    15951 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/sql.py
--rw-r--r--   0        0        0     2137 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ssl.py
--rw-r--r--   0        0        0    12232 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/synonyms.py
--rw-r--r--   0        0        0     2837 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/tasks.py
--rw-r--r--   0        0        0     8815 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/text_structure.py
--rw-r--r--   0        0        0    31911 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/transform.py
--rw-r--r--   0        0        0    14840 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/utils.py
--rw-r--r--   0        0        0    23531 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/watcher.py
--rw-r--r--   0        0        0     4279 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/xpack.py
--rw-r--r--   0        0        0     1470 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/helpers/__init__.py
--rw-r--r--   0        0        0    30926 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/helpers/actions.py
--rw-r--r--   0        0        0     1213 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/helpers/errors.py
--rw-r--r--   0        0        0     2170 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/.gitignore
--rw-r--r--   0        0        0    10143 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/LICENSE
--rw-r--r--   0        0        0       73 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/NOTICE
--rw-r--r--   0        0        0     3153 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/README.rst
--rw-r--r--   0        0        0     2675 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/pyproject.toml
--rw-r--r--   0        0        0     5800 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.1.0.20231031/PKG-INFO
+-rw-r--r--   0        0        0       95 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/CHANGELOG.md
+-rw-r--r--   0        0        0     1285 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/CONTRIBUTING.md
+-rw-r--r--   0        0        0       41 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/setup.cfg
+-rw-r--r--   0        0        0     6790 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/Makefile
+-rw-r--r--   0        0        0     1722 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/api.rst
+-rw-r--r--   0        0        0     7368 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/async.rst
+-rw-r--r--   0        0        0     1673 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/conf.py
+-rw-r--r--   0        0        0      788 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/exceptions.rst
+-rw-r--r--   0        0        0     3555 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/helpers.rst
+-rw-r--r--   0        0        0     3799 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/docs/sphinx/index.rst
+-rw-r--r--   0        0        0     3085 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/__init__.py
+-rw-r--r--   0        0        0     1419 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_utils.py
+-rw-r--r--   0        0        0      822 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_version.py
+-rw-r--r--   0        0        0     3046 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/client.py
+-rw-r--r--   0        0        0     2657 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/compat.py
+-rw-r--r--   0        0        0     4025 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/exceptions.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/py.typed
+-rw-r--r--   0        0        0     6723 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/serializer.py
+-rw-r--r--   0        0        0      787 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/__init__.py
+-rw-r--r--   0        0        0    22336 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/helpers.py
+-rw-r--r--   0        0        0   206235 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/__init__.py
+-rw-r--r--   0        0        0     9862 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/_base.py
+-rw-r--r--   0        0        0    28420 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/async_search.py
+-rw-r--r--   0        0        0    54613 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/cat.py
+-rw-r--r--   0        0        0    14247 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/cluster.py
+-rw-r--r--   0        0        0     8671 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/enrich.py
+-rw-r--r--   0        0        0    12420 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/eql.py
+-rw-r--r--   0        0        0     4379 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/graph.py
+-rw-r--r--   0        0        0   123120 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/indices.py
+-rw-r--r--   0        0        0    10016 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/inference.py
+-rw-r--r--   0        0        0    12944 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/ingest.py
+-rw-r--r--   0        0        0     2825 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/license.py
+-rw-r--r--   0        0        0     5490 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/logstash.py
+-rw-r--r--   0        0        0   164753 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/ml.py
+-rw-r--r--   0        0        0     6826 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/query_ruleset.py
+-rw-r--r--   0        0        0    13371 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/search_application.py
+-rw-r--r--   0        0        0    25058 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/security.py
+-rw-r--r--   0        0        0    16817 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/sql.py
+-rw-r--r--   0        0        0    12217 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/synonyms.py
+-rw-r--r--   0        0        0     2804 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/tasks.py
+-rw-r--r--   0        0        0    33115 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/transform.py
+-rw-r--r--   0        0        0     1297 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/utils.py
+-rw-r--r--   0        0        0      787 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/__init__.py
+-rw-r--r--   0        0        0   205700 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/__init__.py
+-rw-r--r--   0        0        0     9823 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/_base.py
+-rw-r--r--   0        0        0    28372 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/async_search.py
+-rw-r--r--   0        0        0    54493 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/cat.py
+-rw-r--r--   0        0        0    14187 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/cluster.py
+-rw-r--r--   0        0        0     8611 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/enrich.py
+-rw-r--r--   0        0        0    12372 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/eql.py
+-rw-r--r--   0        0        0     4367 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/graph.py
+-rw-r--r--   0        0        0   122688 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/indices.py
+-rw-r--r--   0        0        0     9968 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/inference.py
+-rw-r--r--   0        0        0    12884 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/ingest.py
+-rw-r--r--   0        0        0     2813 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/license.py
+-rw-r--r--   0        0        0     5454 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/logstash.py
+-rw-r--r--   0        0        0   164141 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/ml.py
+-rw-r--r--   0        0        0     6778 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/query_ruleset.py
+-rw-r--r--   0        0        0    13275 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/search_application.py
+-rw-r--r--   0        0        0    24974 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/security.py
+-rw-r--r--   0        0        0    16745 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/sql.py
+-rw-r--r--   0        0        0    12133 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/synonyms.py
+-rw-r--r--   0        0        0     2792 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/tasks.py
+-rw-r--r--   0        0        0    32995 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/transform.py
+-rw-r--r--   0        0        0    16363 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/utils.py
+-rw-r--r--   0        0        0     1470 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/helpers/__init__.py
+-rw-r--r--   0        0        0    30856 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/helpers/actions.py
+-rw-r--r--   0        0        0     1213 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/helpers/errors.py
+-rw-r--r--   0        0        0     2210 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/.gitignore
+-rw-r--r--   0        0        0    10143 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/LICENSE
+-rw-r--r--   0        0        0       73 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/NOTICE
+-rw-r--r--   0        0        0     3153 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/README.rst
+-rw-r--r--   0        0        0     2753 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/pyproject.toml
+-rw-r--r--   0        0        0     5804 2020-02-02 00:00:00.000000 elasticsearch_serverless-0.2.0.20231031/PKG-INFO
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/CONTRIBUTING.md` & `elasticsearch_serverless-0.2.0.20231031/CONTRIBUTING.md`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/docs/sphinx/Makefile` & `elasticsearch_serverless-0.2.0.20231031/docs/sphinx/Makefile`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/docs/sphinx/async.rst` & `elasticsearch_serverless-0.2.0.20231031/docs/sphinx/async.rst`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/docs/sphinx/conf.py` & `elasticsearch_serverless-0.2.0.20231031/docs/sphinx/conf.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/docs/sphinx/exceptions.rst` & `elasticsearch_serverless-0.2.0.20231031/docs/sphinx/exceptions.rst`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/docs/sphinx/helpers.rst` & `elasticsearch_serverless-0.2.0.20231031/docs/sphinx/helpers.rst`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/docs/sphinx/index.rst` & `elasticsearch_serverless-0.2.0.20231031/docs/sphinx/index.rst`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/__init__.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/__init__.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_utils.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_utils.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_version.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,9 +10,7 @@
 #
 #  Unless required by applicable law or agreed to in writing,
 #  software distributed under the License is distributed on an
 #  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 #  KIND, either express or implied.  See the License for the
 #  specific language governing permissions and limitations
 #  under the License.
-
-__versionstr__ = "0.1.0.20231031"
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/compat.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/compat.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/exceptions.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/exceptions.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/serializer.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/serializer.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/__init__.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/__init__.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/helpers.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/helpers.py`

 * *Files 1% similar despite different names*

```diff
@@ -441,15 +441,15 @@
         resp = await client.search(**search_kwargs)
 
     # Try the old deprecated way if we fail immediately on parameters.
     except TypeError:
         search_kwargs = kwargs.copy()
         search_kwargs["scroll"] = scroll
         search_kwargs["size"] = size
-        resp = await client.search(body=query, **search_kwargs)  # type: ignore[call-arg]
+        resp = await client.search(body=query, **search_kwargs)
 
     scroll_id: Optional[str] = resp.get("_scroll_id")
     scroll_transport_kwargs = pop_transport_kwargs(scroll_kwargs)
     if scroll_transport_kwargs:
         scroll_client = client.options(**scroll_transport_kwargs)
     else:
         scroll_client = client
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/__init__.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,81 +17,64 @@
 
 
 import logging
 import typing as t
 import warnings
 
 from elastic_transport import (
-    AsyncTransport,
     BaseNode,
     BinaryApiResponse,
     HeadApiResponse,
     NodePool,
     ObjectApiResponse,
     Serializer,
+    Transport,
 )
 from elastic_transport.client_utils import DEFAULT, DefaultType
 
 from ...exceptions import ApiError, TransportError
 from ...serializer import DEFAULT_SERIALIZERS
 from ._base import BaseClient, resolve_auth_headers
 from .async_search import AsyncSearchClient
-from .autoscaling import AutoscalingClient
 from .cat import CatClient
-from .ccr import CcrClient
 from .cluster import ClusterClient
-from .dangling_indices import DanglingIndicesClient
 from .enrich import EnrichClient
 from .eql import EqlClient
-from .features import FeaturesClient
-from .fleet import FleetClient
 from .graph import GraphClient
-from .ilm import IlmClient
 from .indices import IndicesClient
+from .inference import InferenceClient
 from .ingest import IngestClient
 from .license import LicenseClient
 from .logstash import LogstashClient
-from .migration import MigrationClient
 from .ml import MlClient
-from .monitoring import MonitoringClient
-from .nodes import NodesClient
 from .query_ruleset import QueryRulesetClient
-from .rollup import RollupClient
 from .search_application import SearchApplicationClient
-from .searchable_snapshots import SearchableSnapshotsClient
 from .security import SecurityClient
-from .shutdown import ShutdownClient
-from .slm import SlmClient
-from .snapshot import SnapshotClient
 from .sql import SqlClient
-from .ssl import SslClient
 from .synonyms import SynonymsClient
 from .tasks import TasksClient
-from .text_structure import TextStructureClient
 from .transform import TransformClient
 from .utils import (
     _TYPE_HOST,
     CLIENT_META_SERVICE,
     SKIP_IN_PATH,
     _quote,
     _rewrite_parameters,
     client_node_config,
     is_requests_http_auth,
     is_requests_node_class,
 )
-from .watcher import WatcherClient
-from .xpack import XPackClient
 
 logger = logging.getLogger("elasticsearch")
 
 
-SelfType = t.TypeVar("SelfType", bound="AsyncElasticsearch")
+SelfType = t.TypeVar("SelfType", bound="Elasticsearch")
 
 
-class AsyncElasticsearch(BaseClient):
+class Elasticsearch(BaseClient):
     """
     Elasticsearch low-level client. Provides a straightforward mapping from
     Python to Elasticsearch REST APIs.
 
     The client instance has additional attributes to update APIs in different
     namespaces such as ``async_search``, ``indices``, ``security``, and more:
 
@@ -142,15 +125,15 @@
         client_key: t.Union[DefaultType, str] = DEFAULT,
         ssl_assert_hostname: t.Union[DefaultType, str] = DEFAULT,
         ssl_assert_fingerprint: t.Union[DefaultType, str] = DEFAULT,
         ssl_version: t.Union[DefaultType, int] = DEFAULT,
         ssl_context: t.Union[DefaultType, t.Any] = DEFAULT,
         ssl_show_warn: t.Union[DefaultType, bool] = DEFAULT,
         # Transport
-        transport_class: t.Type[AsyncTransport] = AsyncTransport,
+        transport_class: t.Type[Transport] = Transport,
         request_timeout: t.Union[DefaultType, None, float] = DEFAULT,
         node_class: t.Union[DefaultType, t.Type[BaseNode]] = DEFAULT,
         node_pool_class: t.Union[DefaultType, t.Type[NodePool]] = DEFAULT,
         dead_node_backoff_factor: t.Union[DefaultType, float] = DEFAULT,
         max_dead_node_backoff: t.Union[DefaultType, float] = DEFAULT,
         serializer: t.Optional[Serializer] = None,
         serializers: t.Union[DefaultType, t.Mapping[str, Serializer]] = DEFAULT,
@@ -158,15 +141,15 @@
         max_retries: t.Union[DefaultType, int] = DEFAULT,
         retry_on_status: t.Union[DefaultType, int, t.Collection[int]] = DEFAULT,
         retry_on_timeout: t.Union[DefaultType, bool] = DEFAULT,
         meta_header: t.Union[DefaultType, bool] = DEFAULT,
         timeout: t.Union[DefaultType, None, float] = DEFAULT,
         http_auth: t.Union[DefaultType, t.Any] = DEFAULT,
         # Internal use only
-        _transport: t.Optional[AsyncTransport] = None,
+        _transport: t.Optional[Transport] = None,
     ) -> None:
         if host is not None and hosts is not None:
             raise ValueError("Can't specify both 'host' and 'hosts'")
 
         if hosts is not None:
             if len(hosts) > 1:
                 raise ValueError("Can't specify more than one host in 'hosts'")
@@ -290,73 +273,56 @@
             api_key=api_key,
             basic_auth=basic_auth,
             bearer_auth=bearer_auth,
         )
 
         # namespaced clients for compatibility with API names
         self.async_search = AsyncSearchClient(self)
-        self.autoscaling = AutoscalingClient(self)
         self.cat = CatClient(self)
         self.cluster = ClusterClient(self)
-        self.fleet = FleetClient(self)
-        self.features = FeaturesClient(self)
         self.indices = IndicesClient(self)
+        self.inference = InferenceClient(self)
         self.ingest = IngestClient(self)
-        self.nodes = NodesClient(self)
-        self.snapshot = SnapshotClient(self)
         self.tasks = TasksClient(self)
 
-        self.xpack = XPackClient(self)
-        self.ccr = CcrClient(self)
-        self.dangling_indices = DanglingIndicesClient(self)
         self.enrich = EnrichClient(self)
         self.eql = EqlClient(self)
         self.graph = GraphClient(self)
-        self.ilm = IlmClient(self)
         self.license = LicenseClient(self)
         self.logstash = LogstashClient(self)
-        self.migration = MigrationClient(self)
         self.ml = MlClient(self)
-        self.monitoring = MonitoringClient(self)
         self.query_ruleset = QueryRulesetClient(self)
-        self.rollup = RollupClient(self)
         self.search_application = SearchApplicationClient(self)
-        self.searchable_snapshots = SearchableSnapshotsClient(self)
         self.security = SecurityClient(self)
-        self.slm = SlmClient(self)
-        self.shutdown = ShutdownClient(self)
         self.sql = SqlClient(self)
-        self.ssl = SslClient(self)
         self.synonyms = SynonymsClient(self)
-        self.text_structure = TextStructureClient(self)
         self.transform = TransformClient(self)
-        self.watcher = WatcherClient(self)
 
     def __repr__(self) -> str:
         try:
             # get a list of all connections
             nodes = [node.base_url for node in self.transport.node_pool.all()]
             # truncate to 5 if there are too many
             if len(nodes) > 5:
                 nodes = nodes[:5] + ["..."]
             return f"<{self.__class__.__name__}({nodes})>"
         except Exception:
             # probably operating on custom transport and connection_pool, ignore
             return super().__repr__()
 
-    async def __aenter__(self) -> "AsyncElasticsearch":
+    def __enter__(self) -> "Elasticsearch":
         try:
             # All this to avoid a Mypy error when using unasync.
-            await getattr(self.transport, "_async_call")()
+            getattr(self.transport, "_async_call")()
         except AttributeError:
             pass
         return self
 
-    async def __aexit__(self, *_: t.Any) -> None:
-        await self.close()
+    def __exit__(self, *_: t.Any) -> None:
+        self.close()
 
     def options(
         self: SelfType,
         *,
         opaque_id: t.Union[DefaultType, str] = DEFAULT,
         api_key: t.Union[DefaultType, str, t.Tuple[str, str]] = DEFAULT,
         basic_auth: t.Union[DefaultType, str, t.Tuple[str, str]] = DEFAULT,
@@ -419,20 +385,20 @@
                 raise TypeError("'retry_on_timeout' must be of type 'bool'")
             client._retry_on_timeout = retry_on_timeout
         else:
             client._retry_on_timeout = self._retry_on_timeout
 
         return client
 
-    async def close(self) -> None:
+    def close(self) -> None:
         """Closes the Transport and all internal connections"""
-        await self.transport.close()
+        self.transport.close()
 
     @_rewrite_parameters()
-    async def ping(
+    def ping(
         self,
         *,
         error_trace: t.Optional[bool] = None,
         filter_path: t.Optional[t.Union[t.List[str], str]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> bool:
@@ -454,59 +420,48 @@
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         try:
-            await self.perform_request(
-                "HEAD", __path, params=__query, headers=__headers
-            )
+            self.perform_request("HEAD", __path, params=__query, headers=__headers)
             return True
         except (ApiError, TransportError):
             return False
 
     # AUTO-GENERATED-API-DEFINITIONS #
 
     @_rewrite_parameters(
         body_name="operations",
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def bulk(
+    def bulk(
         self,
         *,
-        operations: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        operations: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         index: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pipeline: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         require_alias: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to perform multiple index/update/delete operations in a single request.
@@ -535,16 +490,20 @@
             the response.
         :param timeout: Period each action waits for the following operations: automatic
             index creation, dynamic mapping updates, waiting for active shards.
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to all or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
-        if operations is None:
-            raise ValueError("Empty value passed for parameter 'operations'")
+        if operations is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'operations' and 'body', one of them should be set."
+            )
+        elif operations is not None and body is not None:
+            raise ValueError("Cannot set both 'operations' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_bulk"
         else:
             __path = "/_bulk"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
@@ -568,158 +527,145 @@
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
-        __body = operations
+        __body = operations if operations is not None else body
         __headers = {
             "accept": "application/json",
             "content-type": "application/x-ndjson",
         }
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("scroll_id",),
     )
-    async def clear_scroll(
+    def clear_scroll(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        scroll_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        scroll_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Explicitly clears the search context for a scroll.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-scroll-api.html>`_
 
         :param scroll_id: Scroll IDs to clear. To clear all scroll IDs, use `_all`.
         """
         __path = "/_search/scroll"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if scroll_id is not None:
-            __body["scroll_id"] = scroll_id
+        if not __body:
+            if scroll_id is not None:
+                __body["scroll_id"] = scroll_id
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("id",),
     )
-    async def close_point_in_time(
+    def close_point_in_time(
         self,
         *,
-        id: str,
+        id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Close a point in time
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/point-in-time-api.html>`_
 
         :param id: The ID of the point-in-time.
         """
-        if id is None:
+        if id is None and body is None:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = "/_pit"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if id is not None:
-            __body["id"] = id
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if id is not None:
+                __body["id"] = id
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("query",),
     )
-    async def count(
+    def count(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         min_score: t.Optional[float] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         routing: t.Optional[str] = None,
         terminate_after: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns number of documents matching a query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -760,15 +706,15 @@
             Elasticsearch collects documents before sorting.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_count"
         else:
             __path = "/_count"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if default_operator is not None:
@@ -793,42 +739,42 @@
             __query["min_score"] = min_score
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if routing is not None:
             __query["routing"] = routing
         if terminate_after is not None:
             __query["terminate_after"] = terminate_after
         if not __body:
+            if query is not None:
+                __body["query"] = query
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="document",
     )
-    async def create(
+    def create(
         self,
         *,
         index: str,
         id: str,
-        document: t.Mapping[str, t.Any],
+        document: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pipeline: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         routing: t.Optional[str] = None,
@@ -874,16 +820,20 @@
             before proceeding with the operation. Set to `all` or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if document is None:
-            raise ValueError("Empty value passed for parameter 'document'")
+        if document is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'document' and 'body', one of them should be set."
+            )
+        elif document is not None and body is not None:
+            raise ValueError("Cannot set both 'document' and 'body'")
         __path = f"/{_quote(index)}/_create/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
@@ -900,30 +850,28 @@
             __query["timeout"] = timeout
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
-        __body = document
+        __body = document if document is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def delete(
+    def delete(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_primary_term: t.Optional[int] = None,
         if_seq_no: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
@@ -989,54 +937,42 @@
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("max_docs", "query", "slice"),
         parameter_aliases={"from": "from_"},
     )
-    async def delete_by_query(
+    def delete_by_query(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         conflicts: t.Optional[t.Union["t.Literal['abort', 'proceed']", str]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         max_docs: t.Optional[int] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
@@ -1052,23 +988,24 @@
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         slices: t.Optional[t.Union[int, t.Union["t.Literal['auto']", str]]] = None,
-        sort: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        sort: t.Optional[t.Sequence[str]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[bool] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
         wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes documents matching the provided query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -1134,15 +1071,15 @@
         :param wait_for_completion: If `true`, the request blocks until the operation
             is complete.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_delete_by_query"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
@@ -1172,24 +1109,20 @@
             __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if lenient is not None:
             __query["lenient"] = lenient
-        if max_docs is not None:
-            __body["max_docs"] = max_docs
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if refresh is not None:
             __query["refresh"] = refresh
         if request_cache is not None:
             __query["request_cache"] = request_cache
         if requests_per_second is not None:
             __query["requests_per_second"] = requests_per_second
         if routing is not None:
@@ -1198,16 +1131,14 @@
             __query["scroll"] = scroll
         if scroll_size is not None:
             __query["scroll_size"] = scroll_size
         if search_timeout is not None:
             __query["search_timeout"] = search_timeout
         if search_type is not None:
             __query["search_type"] = search_type
-        if slice is not None:
-            __body["slice"] = slice
         if slices is not None:
             __query["slices"] = slices
         if sort is not None:
             __query["sort"] = sort
         if stats is not None:
             __query["stats"] = stats
         if terminate_after is not None:
@@ -1216,28 +1147,33 @@
             __query["timeout"] = timeout
         if version is not None:
             __query["version"] = version
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
+        if not __body:
+            if max_docs is not None:
+                __body["max_docs"] = max_docs
+            if query is not None:
+                __body["query"] = query
+            if slice is not None:
+                __body["slice"] = slice
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def delete_script(
+    def delete_script(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -1266,52 +1202,42 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def exists(
+    def exists(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a document exists in an index.
@@ -1372,49 +1298,41 @@
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def exists_source(
+    def exists_source(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a document source exists in an index.
@@ -1470,58 +1388,49 @@
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("query",),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def explain(
+    def explain(
         self,
         *,
         index: str,
         id: str,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns information about why a specific matches (or doesn't match) a query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html>`_
 
         :param index: Index names used to limit the request. Only a single index name
@@ -1552,15 +1461,15 @@
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/{_quote(index)}/_explain/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
@@ -1575,76 +1484,65 @@
             __query["lenient"] = lenient
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if routing is not None:
             __query["routing"] = routing
         if source is not None:
             __query["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if not __body:
+            if query is not None:
+                __body["query"] = query
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("fields", "index_filter", "runtime_mappings"),
     )
-    async def field_caps(
+    def field_caps(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         filters: t.Optional[str] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
+        include_empty_fields: t.Optional[bool] = None,
         include_unmapped: t.Optional[bool] = None,
         index_filter: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
-        types: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        types: t.Optional[t.Sequence[str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the information about the capabilities of fields among multiple indices.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases used
@@ -1660,14 +1558,15 @@
             expressions match hidden data streams. Supports comma-separated values, such
             as `open,hidden`.
         :param fields: List of fields to retrieve capabilities for. Wildcard (`*`) expressions
             are supported.
         :param filters: An optional set of filters: can include +metadata,-metadata,-nested,-multifield,-parent
         :param ignore_unavailable: If `true`, missing or closed indices are not included
             in the response.
+        :param include_empty_fields: If false, empty fields are not included in the response.
         :param include_unmapped: If true, unmapped fields are included in the response.
         :param index_filter: Allows to filter indices if the provided query rewrites
             to match_none on every shard.
         :param runtime_mappings: Defines ad-hoc runtime fields in the request similar
             to the way it is done in search requests. These fields exist only as part
             of the query and take precedence over fields defined with the same name in
             the index mappings.
@@ -1675,96 +1574,94 @@
             list
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_field_caps"
         else:
             __path = "/_field_caps"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if filters is not None:
             __query["filters"] = filters
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
+        if include_empty_fields is not None:
+            __query["include_empty_fields"] = include_empty_fields
         if include_unmapped is not None:
             __query["include_unmapped"] = include_unmapped
-        if index_filter is not None:
-            __body["index_filter"] = index_filter
         if pretty is not None:
             __query["pretty"] = pretty
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
         if types is not None:
             __query["types"] = types
         if not __body:
+            if fields is not None:
+                __body["fields"] = fields
+            if index_filter is not None:
+                __body["index_filter"] = index_filter
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def get(
+    def get(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force_synthetic_source: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns a document.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html>`_
 
         :param index: Name of the index that contains the document.
         :param id: Unique identifier of the document.
+        :param force_synthetic_source: Should this request force synthetic _source? Use
+            this to test if the mapping supports synthetic _source and to get a sense
+            of the worst case performance. Fetches with this enabled will be slower the
+            enabling synthetic source natively in the index.
         :param preference: Specifies the node or shard the operation should be performed
             on. Random by default.
         :param realtime: If `true`, the request is real-time as opposed to near-real-time.
         :param refresh: If true, Elasticsearch refreshes the affected shards to make
             this operation visible to search. If false, do nothing with refreshes.
         :param routing: Target the specified primary shard.
         :param source: True or false to return the _source field or not, or a list of
@@ -1787,14 +1684,16 @@
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/{_quote(index)}/_doc/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if force_synthetic_source is not None:
+            __query["force_synthetic_source"] = force_synthetic_source
         if human is not None:
             __query["human"] = human
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if realtime is not None:
@@ -1812,27 +1711,25 @@
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_script(
+    def get_script(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -1854,52 +1751,42 @@
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def get_source(
+    def get_source(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the source of a document.
@@ -1957,31 +1844,30 @@
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         body_name="document",
     )
-    async def index(
+    def index(
         self,
         *,
         index: str,
-        document: t.Mapping[str, t.Any],
+        document: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_primary_term: t.Optional[int] = None,
         if_seq_no: t.Optional[int] = None,
         op_type: t.Optional[t.Union["t.Literal['create', 'index']", str]] = None,
         pipeline: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
@@ -2034,16 +1920,20 @@
         :param version_type: Specific version type: `external`, `external_gte`.
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to all or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
-        if document is None:
-            raise ValueError("Empty value passed for parameter 'document'")
+        if document is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'document' and 'body', one of them should be set."
+            )
+        elif document is not None and body is not None:
+            raise ValueError("Cannot set both 'document' and 'body'")
         if index not in SKIP_IN_PATH and id not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_doc/{_quote(id)}"
             __method = "PUT"
         elif index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_doc"
             __method = "POST"
         else:
@@ -2075,28 +1965,26 @@
             __query["timeout"] = timeout
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
-        __body = document
+        __body = document if document is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             __method, __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def info(
+    def info(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns basic information about the cluster.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/index.html>`_
@@ -2108,66 +1996,60 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "ids"),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def mget(
+    def mget(
         self,
         *,
         index: t.Optional[str] = None,
-        docs: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force_synthetic_source: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        ids: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        ids: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to get multiple documents in one request.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html>`_
 
         :param index: Name of the index to retrieve documents from when `ids` are specified,
             or when a document in the `docs` array does not specify an index.
         :param docs: The documents you want to retrieve. Required if no index is specified
             in the request URI.
+        :param force_synthetic_source: Should this request force synthetic _source? Use
+            this to test if the mapping supports synthetic _source and to get a sense
+            of the worst case performance. Fetches with this enabled will be slower the
+            enabling synthetic source natively in the index.
         :param ids: The IDs of the documents you want to retrieve. Allowed when the index
             is specified in the request URI.
         :param preference: Specifies the node or shard the operation should be performed
             on. Random by default.
         :param realtime: If `true`, the request is real-time as opposed to near-real-time.
         :param refresh: If `true`, the request refreshes relevant shards before retrieving
             documents.
@@ -2185,26 +2067,24 @@
         :param stored_fields: If `true`, retrieves the document fields stored in the
             index rather than the document `_source`.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_mget"
         else:
             __path = "/_mget"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if force_synthetic_source is not None:
+            __query["force_synthetic_source"] = force_synthetic_source
         if human is not None:
             __query["human"] = human
-        if ids is not None:
-            __body["ids"] = ids
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if realtime is not None:
             __query["realtime"] = realtime
         if refresh is not None:
@@ -2215,53 +2095,45 @@
             __query["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
+        if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if ids is not None:
+                __body["ids"] = ids
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="searches",
     )
-    async def msearch(
+    def msearch(
         self,
         *,
-        searches: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        searches: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         max_concurrent_searches: t.Optional[int] = None,
         max_concurrent_shard_requests: t.Optional[int] = None,
         pre_filter_shard_size: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
@@ -2309,16 +2181,20 @@
         :param routing: Custom routing value used to route search operations to a specific
             shard.
         :param search_type: Indicates whether global term and document frequencies should
             be used when scoring returned documents.
         :param typed_keys: Specifies whether aggregation and suggester names should be
             prefixed by their respective types in the response.
         """
-        if searches is None:
-            raise ValueError("Empty value passed for parameter 'searches'")
+        if searches is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'searches' and 'body', one of them should be set."
+            )
+        elif searches is not None and body is not None:
+            raise ValueError("Cannot set both 'searches' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_msearch"
         else:
             __path = "/_msearch"
         __query: t.Dict[str, t.Any] = {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
@@ -2348,38 +2224,35 @@
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
         if search_type is not None:
             __query["search_type"] = search_type
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        __body = searches
+        __body = searches if searches is not None else body
         __headers = {
             "accept": "application/json",
             "content-type": "application/x-ndjson",
         }
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="search_templates",
     )
-    async def msearch_template(
+    def msearch_template(
         self,
         *,
-        search_templates: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        search_templates: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_concurrent_searches: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
@@ -2401,16 +2274,20 @@
         :param rest_total_hits_as_int: If `true`, the response returns `hits.total` as
             an integer. If `false`, it returns `hits.total` as an object.
         :param search_type: The type of the search operation. Available options: `query_then_fetch`,
             `dfs_query_then_fetch`.
         :param typed_keys: If `true`, the response prefixes aggregation and suggester
             names with their respective types.
         """
-        if search_templates is None:
-            raise ValueError("Empty value passed for parameter 'search_templates'")
+        if search_templates is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'search_templates' and 'body', one of them should be set."
+            )
+        elif search_templates is not None and body is not None:
+            raise ValueError("Cannot set both 'search_templates' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_msearch/template"
         else:
             __path = "/_msearch/template"
         __query: t.Dict[str, t.Any] = {}
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
@@ -2426,55 +2303,50 @@
             __query["pretty"] = pretty
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if search_type is not None:
             __query["search_type"] = search_type
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        __body = search_templates
+        __body = search_templates if search_templates is not None else body
         __headers = {
             "accept": "application/json",
             "content-type": "application/x-ndjson",
         }
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "ids"),
     )
-    async def mtermvectors(
+    def mtermvectors(
         self,
         *,
         index: t.Optional[str] = None,
-        docs: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
         field_statistics: t.Optional[bool] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ids: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        ids: t.Optional[t.Sequence[str]] = None,
         offsets: t.Optional[bool] = None,
         payloads: t.Optional[bool] = None,
         positions: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         term_statistics: t.Optional[bool] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns multiple termvectors in one request.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html>`_
 
         :param index: Name of the index that contains the documents.
@@ -2498,30 +2370,26 @@
         :param version: If `true`, returns the document version as part of a hit.
         :param version_type: Specific version type.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_mtermvectors"
         else:
             __path = "/_mtermvectors"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if field_statistics is not None:
             __query["field_statistics"] = field_statistics
         if fields is not None:
             __query["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ids is not None:
-            __body["ids"] = ids
         if offsets is not None:
             __query["offsets"] = offsets
         if payloads is not None:
             __query["payloads"] = payloads
         if positions is not None:
             __query["positions"] = positions
         if preference is not None:
@@ -2535,50 +2403,43 @@
         if term_statistics is not None:
             __query["term_statistics"] = term_statistics
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if ids is not None:
+                __body["ids"] = ids
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def open_point_in_time(
+    def open_point_in_time(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         keep_alive: t.Union["t.Literal[-1]", "t.Literal[0]", str],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -2620,37 +2481,36 @@
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if routing is not None:
             __query["routing"] = routing
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("script",),
     )
-    async def put_script(
+    def put_script(
         self,
         *,
         id: str,
-        script: t.Mapping[str, t.Any],
+        script: t.Optional[t.Mapping[str, t.Any]] = None,
         context: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a script.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html>`_
 
         :param id: Identifier for the stored script or search template. Must be unique
@@ -2664,81 +2524,69 @@
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if script is None:
+        if script is None and body is None:
             raise ValueError("Empty value passed for parameter 'script'")
         if id not in SKIP_IN_PATH and context not in SKIP_IN_PATH:
             __path = f"/_scripts/{_quote(id)}/{_quote(context)}"
         elif id not in SKIP_IN_PATH:
             __path = f"/_scripts/{_quote(id)}"
         else:
             raise ValueError("Couldn't find a path for the given parameters")
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if script is not None:
-            __body["script"] = script
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if script is not None:
+                __body["script"] = script
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("requests", "metric"),
     )
-    async def rank_eval(
+    def rank_eval(
         self,
         *,
-        requests: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        requests: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         metric: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         search_type: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to evaluate the quality of ranked search results over a set of typical
         search queries
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-rank-eval.html>`_
 
@@ -2756,60 +2604,59 @@
         :param expand_wildcards: Whether to expand wildcard expression to concrete indices
             that are open, closed or both.
         :param ignore_unavailable: If `true`, missing or closed indices are not included
             in the response.
         :param metric: Definition of the evaluation metric to calculate.
         :param search_type: Search operation type
         """
-        if requests is None:
+        if requests is None and body is None:
             raise ValueError("Empty value passed for parameter 'requests'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_rank_eval"
         else:
             __path = "/_rank_eval"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if requests is not None:
-            __body["requests"] = requests
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if metric is not None:
-            __body["metric"] = metric
         if pretty is not None:
             __query["pretty"] = pretty
         if search_type is not None:
             __query["search_type"] = search_type
+        if not __body:
+            if requests is not None:
+                __body["requests"] = requests
+            if metric is not None:
+                __body["metric"] = metric
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("dest", "source", "conflicts", "max_docs", "script", "size"),
     )
-    async def reindex(
+    def reindex(
         self,
         *,
-        dest: t.Mapping[str, t.Any],
-        source: t.Mapping[str, t.Any],
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
         conflicts: t.Optional[t.Union["t.Literal['abort', 'proceed']", str]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_docs: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         requests_per_second: t.Optional[float] = None,
         require_alias: t.Optional[bool] = None,
         script: t.Optional[t.Mapping[str, t.Any]] = None,
@@ -2817,14 +2664,15 @@
         size: t.Optional[int] = None,
         slices: t.Optional[t.Union[int, t.Union["t.Literal['auto']", str]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
         wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to copy documents from one index to another, optionally filtering the
         source documents by a query, changing the destination index settings, or fetching
         the documents from a remote cluster.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html>`_
@@ -2849,79 +2697,79 @@
             mapping updates, and waiting for active shards.
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to `all` or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         :param wait_for_completion: If `true`, the request blocks until the operation
             is complete.
         """
-        if dest is None:
+        if dest is None and body is None:
             raise ValueError("Empty value passed for parameter 'dest'")
-        if source is None:
+        if source is None and body is None:
             raise ValueError("Empty value passed for parameter 'source'")
         __path = "/_reindex"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if dest is not None:
-            __body["dest"] = dest
-        if source is not None:
-            __body["source"] = source
-        if conflicts is not None:
-            __body["conflicts"] = conflicts
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if max_docs is not None:
-            __body["max_docs"] = max_docs
         if pretty is not None:
             __query["pretty"] = pretty
         if refresh is not None:
             __query["refresh"] = refresh
         if requests_per_second is not None:
             __query["requests_per_second"] = requests_per_second
         if require_alias is not None:
             __query["require_alias"] = require_alias
-        if script is not None:
-            __body["script"] = script
         if scroll is not None:
             __query["scroll"] = scroll
-        if size is not None:
-            __body["size"] = size
         if slices is not None:
             __query["slices"] = slices
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
+        if not __body:
+            if dest is not None:
+                __body["dest"] = dest
+            if source is not None:
+                __body["source"] = source
+            if conflicts is not None:
+                __body["conflicts"] = conflicts
+            if max_docs is not None:
+                __body["max_docs"] = max_docs
+            if script is not None:
+                __body["script"] = script
+            if size is not None:
+                __body["size"] = size
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("file", "params", "source"),
         ignore_deprecated_options={"params"},
     )
-    async def render_search_template(
+    def render_search_template(
         self,
         *,
         id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         file: t.Optional[str] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         params: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         source: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to use the Mustache language to pre-render a search definition.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/render-search-template-api.html>`_
 
         :param id: ID of the search template to render. If no `source` is specified,
@@ -2934,213 +2782,227 @@
             If no `id` or `<templated-id>` is specified, this parameter is required.
         """
         if id not in SKIP_IN_PATH:
             __path = f"/_render/template/{_quote(id)}"
         else:
             __path = "/_render/template"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if file is not None:
-            __body["file"] = file
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if params is not None:
-            __body["params"] = params
         if pretty is not None:
             __query["pretty"] = pretty
-        if source is not None:
-            __body["source"] = source
+        if not __body:
+            if file is not None:
+                __body["file"] = file
+            if params is not None:
+                __body["params"] = params
+            if source is not None:
+                __body["source"] = source
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("context", "context_setup", "script"),
     )
-    async def scripts_painless_execute(
+    def scripts_painless_execute(
         self,
         *,
         context: t.Optional[str] = None,
         context_setup: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         script: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows an arbitrary script to be executed and a result to be returned
 
         `<https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html>`_
 
         :param context: The context that the script should run in.
         :param context_setup: Additional parameters for the `context`.
         :param script: The Painless script to execute.
         """
         __path = "/_scripts/painless/_execute"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if context is not None:
-            __body["context"] = context
-        if context_setup is not None:
-            __body["context_setup"] = context_setup
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if script is not None:
-            __body["script"] = script
+        if not __body:
+            if context is not None:
+                __body["context"] = context
+            if context_setup is not None:
+                __body["context_setup"] = context_setup
+            if script is not None:
+                __body["script"] = script
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("scroll_id", "scroll"),
     )
-    async def scroll(
+    def scroll(
         self,
         *,
-        scroll_id: str,
+        scroll_id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to retrieve a large numbers of results from a single search request.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll>`_
 
         :param scroll_id: Scroll ID of the search.
         :param rest_total_hits_as_int: If true, the API response’s hit.total property
             is returned as an integer. If false, the API response’s hit.total property
             is returned as an object.
         :param scroll: Period to retain the search context for scrolling.
         """
-        if scroll_id is None:
+        if scroll_id is None and body is None:
             raise ValueError("Empty value passed for parameter 'scroll_id'")
         __path = "/_search/scroll"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if scroll_id is not None:
-            __body["scroll_id"] = scroll_id
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
-        if scroll is not None:
-            __body["scroll"] = scroll
+        if not __body:
+            if scroll_id is not None:
+                __body["scroll_id"] = scroll_id
+            if scroll is not None:
+                __body["scroll"] = scroll
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "aggs",
+            "collapse",
+            "docvalue_fields",
+            "explain",
+            "ext",
+            "fields",
+            "from_",
+            "highlight",
+            "indices_boost",
+            "knn",
+            "min_score",
+            "pit",
+            "post_filter",
+            "profile",
+            "query",
+            "rank",
+            "rescore",
+            "runtime_mappings",
+            "script_fields",
+            "search_after",
+            "seq_no_primary_term",
+            "size",
+            "slice",
+            "sort",
+            "source",
+            "stats",
+            "stored_fields",
+            "suggest",
+            "terminate_after",
+            "timeout",
+            "track_scores",
+            "track_total_hits",
+            "version",
+        ),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
             "from": "from_",
         },
     )
-    async def search(
+    def search(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         allow_partial_search_results: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         batched_reduce_size: t.Optional[int] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         collapse: t.Optional[t.Mapping[str, t.Any]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
-        docvalue_fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docvalue_fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
         ext: t.Optional[t.Mapping[str, t.Any]] = None,
-        fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force_synthetic_source: t.Optional[bool] = None,
         from_: t.Optional[int] = None,
         highlight: t.Optional[t.Mapping[str, t.Any]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indices_boost: t.Optional[
-            t.Union[t.List[t.Mapping[str, float]], t.Tuple[t.Mapping[str, float], ...]]
-        ] = None,
+        indices_boost: t.Optional[t.Sequence[t.Mapping[str, float]]] = None,
         knn: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         lenient: t.Optional[bool] = None,
         max_concurrent_shard_requests: t.Optional[int] = None,
         min_compatible_shard_node: t.Optional[str] = None,
         min_score: t.Optional[float] = None,
         pit: t.Optional[t.Mapping[str, t.Any]] = None,
         post_filter: t.Optional[t.Mapping[str, t.Any]] = None,
@@ -3149,71 +3011,55 @@
         pretty: t.Optional[bool] = None,
         profile: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         rank: t.Optional[t.Mapping[str, t.Any]] = None,
         request_cache: t.Optional[bool] = None,
         rescore: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         search_after: t.Optional[
-            t.Union[
-                t.List[t.Union[None, bool, float, int, str, t.Any]],
-                t.Tuple[t.Union[None, bool, float, int, str, t.Any], ...],
-            ]
+            t.Sequence[t.Union[None, bool, float, int, str, t.Any]]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         seq_no_primary_term: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
         source: t.Optional[t.Union[bool, t.Mapping[str, t.Any]]] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         suggest: t.Optional[t.Mapping[str, t.Any]] = None,
         suggest_field: t.Optional[str] = None,
         suggest_mode: t.Optional[
             t.Union["t.Literal['always', 'missing', 'popular']", str]
         ] = None,
         suggest_size: t.Optional[int] = None,
         suggest_text: t.Optional[str] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[str] = None,
         track_scores: t.Optional[bool] = None,
         track_total_hits: t.Optional[t.Union[bool, int]] = None,
         typed_keys: t.Optional[bool] = None,
         version: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns results matching a query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -3257,14 +3103,18 @@
             as `open,hidden`.
         :param explain: If true, returns detailed information about score computation
             as part of a hit.
         :param ext: Configuration of search extensions defined by Elasticsearch plugins.
         :param fields: Array of wildcard (`*`) patterns. The request returns values for
             field names matching these patterns in the `hits.fields` property of the
             response.
+        :param force_synthetic_source: Should this request force synthetic _source? Use
+            this to test if the mapping supports synthetic _source and to get a sense
+            of the worst case performance. Fetches with this enabled will be slower the
+            enabling synthetic source natively in the index.
         :param from_: Starting document offset. Needs to be non-negative. By default,
             you cannot page through more than 10,000 hits using the `from` and `size`
             parameters. To page through more hits, use the `search_after` parameter.
         :param highlight: Specifies the highlighter to use for retrieving highlighted
             snippets from one or more fields in your search results.
         :param ignore_throttled: If `true`, concrete, expanded or aliased indices will
             be ignored when frozen.
@@ -3398,213 +3248,225 @@
             by their respective types in the response.
         :param version: If true, returns document version as part of a hit.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_search"
         else:
             __path = "/_search"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
             )
         ):
             __query["sort"] = sort
             sort = None
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
-        if aggs is not None:
-            __body["aggs"] = aggs
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if allow_partial_search_results is not None:
             __query["allow_partial_search_results"] = allow_partial_search_results
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if batched_reduce_size is not None:
             __query["batched_reduce_size"] = batched_reduce_size
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
-        if collapse is not None:
-            __body["collapse"] = collapse
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
             __query["df"] = df
-        if docvalue_fields is not None:
-            __body["docvalue_fields"] = docvalue_fields
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if explain is not None:
-            __body["explain"] = explain
-        if ext is not None:
-            __body["ext"] = ext
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_ is not None:
-            __body["from"] = from_
-        if highlight is not None:
-            __body["highlight"] = highlight
+        if force_synthetic_source is not None:
+            __query["force_synthetic_source"] = force_synthetic_source
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indices_boost is not None:
-            __body["indices_boost"] = indices_boost
-        if knn is not None:
-            __body["knn"] = knn
         if lenient is not None:
             __query["lenient"] = lenient
         if max_concurrent_shard_requests is not None:
             __query["max_concurrent_shard_requests"] = max_concurrent_shard_requests
         if min_compatible_shard_node is not None:
             __query["min_compatible_shard_node"] = min_compatible_shard_node
-        if min_score is not None:
-            __body["min_score"] = min_score
-        if pit is not None:
-            __body["pit"] = pit
-        if post_filter is not None:
-            __body["post_filter"] = post_filter
         if pre_filter_shard_size is not None:
             __query["pre_filter_shard_size"] = pre_filter_shard_size
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if profile is not None:
-            __body["profile"] = profile
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
-        if rank is not None:
-            __body["rank"] = rank
         if request_cache is not None:
             __query["request_cache"] = request_cache
-        if rescore is not None:
-            __body["rescore"] = rescore
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
         if scroll is not None:
             __query["scroll"] = scroll
-        if search_after is not None:
-            __body["search_after"] = search_after
         if search_type is not None:
             __query["search_type"] = search_type
-        if seq_no_primary_term is not None:
-            __body["seq_no_primary_term"] = seq_no_primary_term
-        if size is not None:
-            __body["size"] = size
-        if slice is not None:
-            __body["slice"] = slice
-        if sort is not None:
-            __body["sort"] = sort
-        if source is not None:
-            __body["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
-        if stats is not None:
-            __body["stats"] = stats
-        if stored_fields is not None:
-            __body["stored_fields"] = stored_fields
-        if suggest is not None:
-            __body["suggest"] = suggest
         if suggest_field is not None:
             __query["suggest_field"] = suggest_field
         if suggest_mode is not None:
             __query["suggest_mode"] = suggest_mode
         if suggest_size is not None:
             __query["suggest_size"] = suggest_size
         if suggest_text is not None:
             __query["suggest_text"] = suggest_text
-        if terminate_after is not None:
-            __body["terminate_after"] = terminate_after
-        if timeout is not None:
-            __body["timeout"] = timeout
-        if track_scores is not None:
-            __body["track_scores"] = track_scores
-        if track_total_hits is not None:
-            __body["track_total_hits"] = track_total_hits
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if collapse is not None:
+                __body["collapse"] = collapse
+            if docvalue_fields is not None:
+                __body["docvalue_fields"] = docvalue_fields
+            if explain is not None:
+                __body["explain"] = explain
+            if ext is not None:
+                __body["ext"] = ext
+            if fields is not None:
+                __body["fields"] = fields
+            if from_ is not None:
+                __body["from"] = from_
+            if highlight is not None:
+                __body["highlight"] = highlight
+            if indices_boost is not None:
+                __body["indices_boost"] = indices_boost
+            if knn is not None:
+                __body["knn"] = knn
+            if min_score is not None:
+                __body["min_score"] = min_score
+            if pit is not None:
+                __body["pit"] = pit
+            if post_filter is not None:
+                __body["post_filter"] = post_filter
+            if profile is not None:
+                __body["profile"] = profile
+            if query is not None:
+                __body["query"] = query
+            if rank is not None:
+                __body["rank"] = rank
+            if rescore is not None:
+                __body["rescore"] = rescore
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if seq_no_primary_term is not None:
+                __body["seq_no_primary_term"] = seq_no_primary_term
+            if size is not None:
+                __body["size"] = size
+            if slice is not None:
+                __body["slice"] = slice
+            if sort is not None:
+                __body["sort"] = sort
+            if source is not None:
+                __body["_source"] = source
+            if stats is not None:
+                __body["stats"] = stats
+            if stored_fields is not None:
+                __body["stored_fields"] = stored_fields
+            if suggest is not None:
+                __body["suggest"] = suggest
+            if terminate_after is not None:
+                __body["terminate_after"] = terminate_after
+            if timeout is not None:
+                __body["timeout"] = timeout
+            if track_scores is not None:
+                __body["track_scores"] = track_scores
+            if track_total_hits is not None:
+                __body["track_total_hits"] = track_total_hits
+            if version is not None:
+                __body["version"] = version
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggs",
+            "buffer",
+            "exact_bounds",
+            "extent",
+            "fields",
+            "grid_agg",
+            "grid_precision",
+            "grid_type",
+            "query",
+            "runtime_mappings",
+            "size",
+            "sort",
+            "track_total_hits",
+            "with_labels",
+        ),
     )
-    async def search_mvt(
+    def search_mvt(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         field: str,
         zoom: int,
         x: int,
         y: int,
         aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         buffer: t.Optional[int] = None,
         error_trace: t.Optional[bool] = None,
         exact_bounds: t.Optional[bool] = None,
         extent: t.Optional[int] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         grid_agg: t.Optional[t.Union["t.Literal['geohex', 'geotile']", str]] = None,
         grid_precision: t.Optional[int] = None,
         grid_type: t.Optional[
             t.Union["t.Literal['centroid', 'grid', 'point']", str]
         ] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         size: t.Optional[int] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
         track_total_hits: t.Optional[t.Union[bool, int]] = None,
         with_labels: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> BinaryApiResponse:
         """
         Searches a vector tile for geospatial values. Returns results as a binary Mapbox
         vector tile.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-vector-tile-api.html>`_
 
@@ -3658,105 +3520,94 @@
         if zoom in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'zoom'")
         if x in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'x'")
         if y in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'y'")
         __path = f"/{_quote(index)}/_mvt/{_quote(field)}/{_quote(zoom)}/{_quote(x)}/{_quote(y)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
             )
         ):
             __query["sort"] = sort
             sort = None
-        if aggs is not None:
-            __body["aggs"] = aggs
-        if buffer is not None:
-            __body["buffer"] = buffer
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if exact_bounds is not None:
-            __body["exact_bounds"] = exact_bounds
-        if extent is not None:
-            __body["extent"] = extent
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if grid_agg is not None:
-            __body["grid_agg"] = grid_agg
-        if grid_precision is not None:
-            __body["grid_precision"] = grid_precision
-        if grid_type is not None:
-            __body["grid_type"] = grid_type
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if size is not None:
-            __body["size"] = size
-        if sort is not None:
-            __body["sort"] = sort
-        if track_total_hits is not None:
-            __body["track_total_hits"] = track_total_hits
-        if with_labels is not None:
-            __body["with_labels"] = with_labels
+        if not __body:
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if buffer is not None:
+                __body["buffer"] = buffer
+            if exact_bounds is not None:
+                __body["exact_bounds"] = exact_bounds
+            if extent is not None:
+                __body["extent"] = extent
+            if fields is not None:
+                __body["fields"] = fields
+            if grid_agg is not None:
+                __body["grid_agg"] = grid_agg
+            if grid_precision is not None:
+                __body["grid_precision"] = grid_precision
+            if grid_type is not None:
+                __body["grid_type"] = grid_type
+            if query is not None:
+                __body["query"] = query
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if size is not None:
+                __body["size"] = size
+            if sort is not None:
+                __body["sort"] = sort
+            if track_total_hits is not None:
+                __body["track_total_hits"] = track_total_hits
+            if with_labels is not None:
+                __body["with_labels"] = with_labels
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/vnd.mapbox-vector-tile"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("explain", "id", "params", "profile", "source"),
         ignore_deprecated_options={"params"},
     )
-    async def search_template(
+    def search_template(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         id: t.Optional[str] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         params: t.Optional[t.Mapping[str, t.Any]] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
@@ -3765,14 +3616,15 @@
         routing: t.Optional[str] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         source: t.Optional[str] = None,
         typed_keys: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to use the Mustache language to pre-render a search definition.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -3814,80 +3666,88 @@
             names with their respective types.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_search/template"
         else:
             __path = "/_search/template"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if explain is not None:
-            __body["explain"] = explain
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if id is not None:
-            __body["id"] = id
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if params is not None:
-            __body["params"] = params
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if profile is not None:
-            __body["profile"] = profile
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
         if scroll is not None:
             __query["scroll"] = scroll
         if search_type is not None:
             __query["search_type"] = search_type
-        if source is not None:
-            __body["source"] = source
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
+        if not __body:
+            if explain is not None:
+                __body["explain"] = explain
+            if id is not None:
+                __body["id"] = id
+            if params is not None:
+                __body["params"] = params
+            if profile is not None:
+                __body["profile"] = profile
+            if source is not None:
+                __body["source"] = source
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "field",
+            "case_insensitive",
+            "index_filter",
+            "search_after",
+            "size",
+            "string",
+            "timeout",
+        ),
     )
-    async def terms_enum(
+    def terms_enum(
         self,
         *,
         index: str,
-        field: str,
+        field: t.Optional[str] = None,
         case_insensitive: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         index_filter: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         search_after: t.Optional[str] = None,
         size: t.Optional[int] = None,
         string: t.Optional[str] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         The terms enum API can be used to discover terms in the index that begin with
         the provided string. It is designed for low-latency look-ups used in auto-complete
         scenarios.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-terms-enum.html>`_
@@ -3907,82 +3767,80 @@
             as the search_after parameter for a subsequent request.
         :param timeout: The maximum length of time to spend collecting results. Defaults
             to "1s" (one second). If the timeout is exceeded the complete flag set to
             false in the response and the results may be partial or empty.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
-        if field is None:
+        if field is None and body is None:
             raise ValueError("Empty value passed for parameter 'field'")
         __path = f"/{_quote(index)}/_terms_enum"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if field is not None:
-            __body["field"] = field
-        if case_insensitive is not None:
-            __body["case_insensitive"] = case_insensitive
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index_filter is not None:
-            __body["index_filter"] = index_filter
         if pretty is not None:
             __query["pretty"] = pretty
-        if search_after is not None:
-            __body["search_after"] = search_after
-        if size is not None:
-            __body["size"] = size
-        if string is not None:
-            __body["string"] = string
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if field is not None:
+                __body["field"] = field
+            if case_insensitive is not None:
+                __body["case_insensitive"] = case_insensitive
+            if index_filter is not None:
+                __body["index_filter"] = index_filter
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if size is not None:
+                __body["size"] = size
+            if string is not None:
+                __body["string"] = string
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("doc", "filter", "per_field_analyzer"),
     )
-    async def termvectors(
+    def termvectors(
         self,
         *,
         index: str,
         id: t.Optional[str] = None,
         doc: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         field_statistics: t.Optional[bool] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         filter: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         offsets: t.Optional[bool] = None,
         payloads: t.Optional[bool] = None,
         per_field_analyzer: t.Optional[t.Mapping[str, str]] = None,
         positions: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         term_statistics: t.Optional[bool] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns information and statistics about terms in the fields of a particular
         document.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html>`_
 
@@ -4013,36 +3871,30 @@
             raise ValueError("Empty value passed for parameter 'index'")
         if index not in SKIP_IN_PATH and id not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_termvectors/{_quote(id)}"
         elif index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_termvectors"
         else:
             raise ValueError("Couldn't find a path for the given parameters")
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if doc is not None:
-            __body["doc"] = doc
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if field_statistics is not None:
             __query["field_statistics"] = field_statistics
         if fields is not None:
             __query["fields"] = fields
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if offsets is not None:
             __query["offsets"] = offsets
         if payloads is not None:
             __query["payloads"] = payloads
-        if per_field_analyzer is not None:
-            __body["per_field_analyzer"] = per_field_analyzer
         if positions is not None:
             __query["positions"] = positions
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if realtime is not None:
@@ -4052,67 +3904,77 @@
         if term_statistics is not None:
             __query["term_statistics"] = term_statistics
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if not __body:
+            if doc is not None:
+                __body["doc"] = doc
+            if filter is not None:
+                __body["filter"] = filter
+            if per_field_analyzer is not None:
+                __body["per_field_analyzer"] = per_field_analyzer
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "detect_noop",
+            "doc",
+            "doc_as_upsert",
+            "script",
+            "scripted_upsert",
+            "source",
+            "upsert",
+        ),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    async def update(
+    def update(
         self,
         *,
         index: str,
         id: str,
         detect_noop: t.Optional[bool] = None,
         doc: t.Optional[t.Mapping[str, t.Any]] = None,
         doc_as_upsert: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_primary_term: t.Optional[int] = None,
         if_seq_no: t.Optional[int] = None,
         lang: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         require_alias: t.Optional[bool] = None,
         retry_on_conflict: t.Optional[int] = None,
         routing: t.Optional[str] = None,
         script: t.Optional[t.Mapping[str, t.Any]] = None,
         scripted_upsert: t.Optional[bool] = None,
         source: t.Optional[t.Union[bool, t.Mapping[str, t.Any]]] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         upsert: t.Optional[t.Mapping[str, t.Any]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates a document with a script or partial document.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html>`_
 
         :param index: The name of the index
@@ -4152,22 +4014,16 @@
             to 1 meaning the primary shard.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/{_quote(index)}/_update/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if detect_noop is not None:
-            __body["detect_noop"] = detect_noop
-        if doc is not None:
-            __body["doc"] = doc
-        if doc_as_upsert is not None:
-            __body["doc_as_upsert"] = doc_as_upsert
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if if_primary_term is not None:
@@ -4182,71 +4038,66 @@
             __query["refresh"] = refresh
         if require_alias is not None:
             __query["require_alias"] = require_alias
         if retry_on_conflict is not None:
             __query["retry_on_conflict"] = retry_on_conflict
         if routing is not None:
             __query["routing"] = routing
-        if script is not None:
-            __body["script"] = script
-        if scripted_upsert is not None:
-            __body["scripted_upsert"] = scripted_upsert
-        if source is not None:
-            __body["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if timeout is not None:
             __query["timeout"] = timeout
-        if upsert is not None:
-            __body["upsert"] = upsert
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
+        if not __body:
+            if detect_noop is not None:
+                __body["detect_noop"] = detect_noop
+            if doc is not None:
+                __body["doc"] = doc
+            if doc_as_upsert is not None:
+                __body["doc_as_upsert"] = doc_as_upsert
+            if script is not None:
+                __body["script"] = script
+            if scripted_upsert is not None:
+                __body["scripted_upsert"] = scripted_upsert
+            if source is not None:
+                __body["_source"] = source
+            if upsert is not None:
+                __body["upsert"] = upsert
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("conflicts", "max_docs", "query", "script", "slice"),
         parameter_aliases={"from": "from_"},
     )
-    async def update_by_query(
+    def update_by_query(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         conflicts: t.Optional[t.Union["t.Literal['abort', 'proceed']", str]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         max_docs: t.Optional[int] = None,
         pipeline: t.Optional[str] = None,
         preference: t.Optional[str] = None,
@@ -4263,28 +4114,30 @@
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         slices: t.Optional[t.Union[int, t.Union["t.Literal['auto']", str]]] = None,
-        sort: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        sort: t.Optional[t.Sequence[str]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[bool] = None,
         version_type: t.Optional[bool] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
         wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Performs an update on every document in the index without changing the source,
-        for example to pick up a mapping change.
+        Updates documents that match the specified query. If no query is specified, performs
+        an update on every document in the index without changing the source, for example
+        to pick up a mapping change.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
             Supports wildcards (`*`). To search all data streams or indices, omit this
             parameter or use `*` or `_all`.
         :param allow_no_indices: If `false`, the request returns an error if any wildcard
@@ -4354,15 +4207,15 @@
         :param wait_for_completion: If `true`, the request blocks until the operation
             is complete.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_update_by_query"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
@@ -4372,16 +4225,14 @@
             sort = None
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
-        if conflicts is not None:
-            __body["conflicts"] = conflicts
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
             __query["df"] = df
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
@@ -4392,44 +4243,36 @@
             __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if lenient is not None:
             __query["lenient"] = lenient
-        if max_docs is not None:
-            __body["max_docs"] = max_docs
         if pipeline is not None:
             __query["pipeline"] = pipeline
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
         if refresh is not None:
             __query["refresh"] = refresh
         if request_cache is not None:
             __query["request_cache"] = request_cache
         if requests_per_second is not None:
             __query["requests_per_second"] = requests_per_second
         if routing is not None:
             __query["routing"] = routing
-        if script is not None:
-            __body["script"] = script
         if scroll is not None:
             __query["scroll"] = scroll
         if scroll_size is not None:
             __query["scroll_size"] = scroll_size
         if search_timeout is not None:
             __query["search_timeout"] = search_timeout
         if search_type is not None:
             __query["search_type"] = search_type
-        if slice is not None:
-            __body["slice"] = slice
         if slices is not None:
             __query["slices"] = slices
         if sort is not None:
             __query["sort"] = sort
         if stats is not None:
             __query["stats"] = stats
         if terminate_after is not None:
@@ -4441,14 +4284,25 @@
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
         if not __body:
+            if conflicts is not None:
+                __body["conflicts"] = conflicts
+            if max_docs is not None:
+                __body["max_docs"] = max_docs
+            if query is not None:
+                __body["query"] = query
+            if script is not None:
+                __body["script"] = script
+            if slice is not None:
+                __body["slice"] = slice
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/_base.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/_base.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,37 +17,34 @@
 
 import re
 import warnings
 from typing import Any, Collection, Iterable, Mapping, Optional, Tuple, Union
 
 from elastic_transport import (
     ApiResponse,
-    AsyncTransport,
     BinaryApiResponse,
     HeadApiResponse,
     HttpHeaders,
     ListApiResponse,
     ObjectApiResponse,
     TextApiResponse,
+    Transport,
 )
 from elastic_transport.client_utils import DEFAULT, DefaultType
 
 from ...compat import warn_stacklevel
 from ...exceptions import (
     HTTP_EXCEPTIONS,
     ApiError,
     ElasticsearchWarning,
     UnsupportedProductError,
 )
 from .utils import _base64_auth_header, _quote_query
 
 _WARNING_RE = re.compile(r"\"([^\"]*)\"")
-_COMPAT_MIMETYPE_TEMPLATE = "application/vnd.elasticsearch+%s; compatible-with=8"
-_COMPAT_MIMETYPE_RE = re.compile(r"application/(json|x-ndjson|vnd\.mapbox-vector-tile)")
-_COMPAT_MIMETYPE_SUB = _COMPAT_MIMETYPE_TEMPLATE % (r"\g<1>",)
 
 
 def resolve_auth_headers(
     headers: Optional[Mapping[str, str]],
     http_auth: Union[DefaultType, None, Tuple[str, str], str] = DEFAULT,
     api_key: Union[DefaultType, None, Tuple[str, str], str] = DEFAULT,
     basic_auth: Union[DefaultType, None, Tuple[str, str], str] = DEFAULT,
@@ -104,73 +101,60 @@
         if headers and headers.get("authorization", None) is not None:
             raise ValueError(
                 "Can't set 'Authorization' HTTP header with other authentication options"
             )
         if resolved_api_key:
             headers["authorization"] = f"ApiKey {_base64_auth_header(resolved_api_key)}"
         if resolved_basic_auth:
-            headers[
-                "authorization"
-            ] = f"Basic {_base64_auth_header(resolved_basic_auth)}"
+            headers["authorization"] = (
+                f"Basic {_base64_auth_header(resolved_basic_auth)}"
+            )
         if resolved_bearer_auth:
             headers["authorization"] = f"Bearer {resolved_bearer_auth}"
 
     return headers
 
 
 class BaseClient:
-    def __init__(self, _transport: AsyncTransport) -> None:
+    def __init__(self, _transport: Transport) -> None:
         self._transport = _transport
         self._client_meta: Union[DefaultType, Tuple[Tuple[str, str], ...]] = DEFAULT
         self._headers = HttpHeaders()
         self._request_timeout: Union[DefaultType, Optional[float]] = DEFAULT
         self._ignore_status: Union[DefaultType, Collection[int]] = DEFAULT
         self._max_retries: Union[DefaultType, int] = DEFAULT
         self._retry_on_timeout: Union[DefaultType, bool] = DEFAULT
         self._retry_on_status: Union[DefaultType, Collection[int]] = DEFAULT
         self._verified_elasticsearch = False
 
     @property
-    def transport(self) -> AsyncTransport:
+    def transport(self) -> Transport:
         return self._transport
 
-    async def perform_request(
+    def perform_request(
         self,
         method: str,
         path: str,
         *,
         params: Optional[Mapping[str, Any]] = None,
         headers: Optional[Mapping[str, str]] = None,
         body: Optional[Any] = None,
     ) -> ApiResponse[Any]:
         if headers:
             request_headers = self._headers.copy()
             request_headers.update(headers)
         else:
             request_headers = self._headers
 
-        def mimetype_header_to_compat(header: str) -> None:
-            # Converts all parts of a Accept/Content-Type headers
-            # from application/X -> application/vnd.elasticsearch+X
-            nonlocal request_headers
-            mimetype = request_headers.get(header, None)
-            if mimetype:
-                request_headers[header] = _COMPAT_MIMETYPE_RE.sub(
-                    _COMPAT_MIMETYPE_SUB, mimetype
-                )
-
-        mimetype_header_to_compat("Accept")
-        mimetype_header_to_compat("Content-Type")
-
         if params:
             target = f"{path}?{_quote_query(params)}"
         else:
             target = path
 
-        meta, resp_body = await self.transport.perform_request(
+        meta, resp_body = self.transport.perform_request(
             method,
             target,
             headers=request_headers,
             body=body,
             request_timeout=self._request_timeout,
             max_retries=self._max_retries,
             retry_on_status=self._retry_on_status,
@@ -255,21 +239,21 @@
 
 
 class NamespacedClient(BaseClient):
     def __init__(self, client: "BaseClient") -> None:
         self._client = client
         super().__init__(self._client.transport)
 
-    async def perform_request(
+    def perform_request(
         self,
         method: str,
         path: str,
         *,
         params: Optional[Mapping[str, Any]] = None,
         headers: Optional[Mapping[str, str]] = None,
         body: Optional[Any] = None,
     ) -> ApiResponse[Any]:
         # Use the internal clients .perform_request() implementation
         # so we take advantage of their transport options.
-        return await self._client.perform_request(
+        return self._client.perform_request(
             method, path, params=params, headers=headers, body=body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/async_search.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/async_search.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class AsyncSearchClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete(
+    def delete(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an async search by ID. If the search is still running, the search request
         will be cancelled. Otherwise, the saved search results are deleted.
 
@@ -53,27 +52,25 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get(
+    def get(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         pretty: t.Optional[bool] = None,
         typed_keys: t.Optional[bool] = None,
         wait_for_completion_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
@@ -115,27 +112,25 @@
         if pretty is not None:
             __query["pretty"] = pretty
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
         if wait_for_completion_timeout is not None:
             __query["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def status(
+    def status(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves the status of a previously submitted async search request given its
         ID.
 
@@ -152,89 +147,100 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "aggs",
+            "collapse",
+            "docvalue_fields",
+            "explain",
+            "ext",
+            "fields",
+            "from_",
+            "highlight",
+            "indices_boost",
+            "knn",
+            "min_score",
+            "pit",
+            "post_filter",
+            "profile",
+            "query",
+            "rescore",
+            "runtime_mappings",
+            "script_fields",
+            "search_after",
+            "seq_no_primary_term",
+            "size",
+            "slice",
+            "sort",
+            "source",
+            "stats",
+            "stored_fields",
+            "suggest",
+            "terminate_after",
+            "timeout",
+            "track_scores",
+            "track_total_hits",
+            "version",
+        ),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
             "from": "from_",
         },
     )
-    async def submit(
+    def submit(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         allow_partial_search_results: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         batched_reduce_size: t.Optional[int] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         collapse: t.Optional[t.Mapping[str, t.Any]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
-        docvalue_fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docvalue_fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
         ext: t.Optional[t.Mapping[str, t.Any]] = None,
-        fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         highlight: t.Optional[t.Mapping[str, t.Any]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indices_boost: t.Optional[
-            t.Union[t.List[t.Mapping[str, float]], t.Tuple[t.Mapping[str, float], ...]]
-        ] = None,
+        indices_boost: t.Optional[t.Sequence[t.Mapping[str, float]]] = None,
         keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         keep_on_completion: t.Optional[bool] = None,
         knn: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         lenient: t.Optional[bool] = None,
         max_concurrent_shard_requests: t.Optional[int] = None,
         min_compatible_shard_node: t.Optional[str] = None,
         min_score: t.Optional[float] = None,
         pit: t.Optional[t.Mapping[str, t.Any]] = None,
         post_filter: t.Optional[t.Mapping[str, t.Any]] = None,
@@ -242,58 +248,41 @@
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         profile: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         request_cache: t.Optional[bool] = None,
         rescore: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         search_after: t.Optional[
-            t.Union[
-                t.List[t.Union[None, bool, float, int, str, t.Any]],
-                t.Tuple[t.Union[None, bool, float, int, str, t.Any], ...],
-            ]
+            t.Sequence[t.Union[None, bool, float, int, str, t.Any]]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         seq_no_primary_term: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
         source: t.Optional[t.Union[bool, t.Mapping[str, t.Any]]] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         suggest: t.Optional[t.Mapping[str, t.Any]] = None,
         suggest_field: t.Optional[str] = None,
         suggest_mode: t.Optional[
             t.Union["t.Literal['always', 'missing', 'popular']", str]
         ] = None,
         suggest_size: t.Optional[int] = None,
         suggest_text: t.Optional[str] = None,
@@ -302,14 +291,15 @@
         track_scores: t.Optional[bool] = None,
         track_total_hits: t.Optional[t.Union[bool, int]] = None,
         typed_keys: t.Optional[bool] = None,
         version: t.Optional[bool] = None,
         wait_for_completion_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Executes a search request asynchronously.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/async-search.html>`_
 
         :param index: A comma-separated list of index names to search; use `_all` or
@@ -438,166 +428,167 @@
             up to a certain timeout. When the async search completes within the timeout,
             the response won’t include the ID as the results are not stored in the cluster.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_async_search"
         else:
             __path = "/_async_search"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
             )
         ):
             __query["sort"] = sort
             sort = None
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
-        if aggs is not None:
-            __body["aggs"] = aggs
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if allow_partial_search_results is not None:
             __query["allow_partial_search_results"] = allow_partial_search_results
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if batched_reduce_size is not None:
             __query["batched_reduce_size"] = batched_reduce_size
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
-        if collapse is not None:
-            __body["collapse"] = collapse
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
             __query["df"] = df
-        if docvalue_fields is not None:
-            __body["docvalue_fields"] = docvalue_fields
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if explain is not None:
-            __body["explain"] = explain
-        if ext is not None:
-            __body["ext"] = ext
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_ is not None:
-            __body["from"] = from_
-        if highlight is not None:
-            __body["highlight"] = highlight
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indices_boost is not None:
-            __body["indices_boost"] = indices_boost
         if keep_alive is not None:
             __query["keep_alive"] = keep_alive
         if keep_on_completion is not None:
             __query["keep_on_completion"] = keep_on_completion
-        if knn is not None:
-            __body["knn"] = knn
         if lenient is not None:
             __query["lenient"] = lenient
         if max_concurrent_shard_requests is not None:
             __query["max_concurrent_shard_requests"] = max_concurrent_shard_requests
         if min_compatible_shard_node is not None:
             __query["min_compatible_shard_node"] = min_compatible_shard_node
-        if min_score is not None:
-            __body["min_score"] = min_score
-        if pit is not None:
-            __body["pit"] = pit
-        if post_filter is not None:
-            __body["post_filter"] = post_filter
         if pre_filter_shard_size is not None:
             __query["pre_filter_shard_size"] = pre_filter_shard_size
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if profile is not None:
-            __body["profile"] = profile
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if request_cache is not None:
             __query["request_cache"] = request_cache
-        if rescore is not None:
-            __body["rescore"] = rescore
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
         if scroll is not None:
             __query["scroll"] = scroll
-        if search_after is not None:
-            __body["search_after"] = search_after
         if search_type is not None:
             __query["search_type"] = search_type
-        if seq_no_primary_term is not None:
-            __body["seq_no_primary_term"] = seq_no_primary_term
-        if size is not None:
-            __body["size"] = size
-        if slice is not None:
-            __body["slice"] = slice
-        if sort is not None:
-            __body["sort"] = sort
-        if source is not None:
-            __body["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
-        if stats is not None:
-            __body["stats"] = stats
-        if stored_fields is not None:
-            __body["stored_fields"] = stored_fields
-        if suggest is not None:
-            __body["suggest"] = suggest
         if suggest_field is not None:
             __query["suggest_field"] = suggest_field
         if suggest_mode is not None:
             __query["suggest_mode"] = suggest_mode
         if suggest_size is not None:
             __query["suggest_size"] = suggest_size
         if suggest_text is not None:
             __query["suggest_text"] = suggest_text
-        if terminate_after is not None:
-            __body["terminate_after"] = terminate_after
-        if timeout is not None:
-            __body["timeout"] = timeout
-        if track_scores is not None:
-            __body["track_scores"] = track_scores
-        if track_total_hits is not None:
-            __body["track_total_hits"] = track_total_hits
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        if version is not None:
-            __body["version"] = version
         if wait_for_completion_timeout is not None:
             __query["wait_for_completion_timeout"] = wait_for_completion_timeout
         if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if collapse is not None:
+                __body["collapse"] = collapse
+            if docvalue_fields is not None:
+                __body["docvalue_fields"] = docvalue_fields
+            if explain is not None:
+                __body["explain"] = explain
+            if ext is not None:
+                __body["ext"] = ext
+            if fields is not None:
+                __body["fields"] = fields
+            if from_ is not None:
+                __body["from"] = from_
+            if highlight is not None:
+                __body["highlight"] = highlight
+            if indices_boost is not None:
+                __body["indices_boost"] = indices_boost
+            if knn is not None:
+                __body["knn"] = knn
+            if min_score is not None:
+                __body["min_score"] = min_score
+            if pit is not None:
+                __body["pit"] = pit
+            if post_filter is not None:
+                __body["post_filter"] = post_filter
+            if profile is not None:
+                __body["profile"] = profile
+            if query is not None:
+                __body["query"] = query
+            if rescore is not None:
+                __body["rescore"] = rescore
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if seq_no_primary_term is not None:
+                __body["seq_no_primary_term"] = seq_no_primary_term
+            if size is not None:
+                __body["size"] = size
+            if slice is not None:
+                __body["slice"] = slice
+            if sort is not None:
+                __body["sort"] = sort
+            if source is not None:
+                __body["_source"] = source
+            if stats is not None:
+                __body["stats"] = stats
+            if stored_fields is not None:
+                __body["stored_fields"] = stored_fields
+            if suggest is not None:
+                __body["suggest"] = suggest
+            if terminate_after is not None:
+                __body["terminate_after"] = terminate_after
+            if timeout is not None:
+                __body["timeout"] = timeout
+            if track_scores is not None:
+                __body["track_scores"] = track_scores
+            if track_total_hits is not None:
+                __body["track_total_hits"] = track_total_hits
+            if version is not None:
+                __body["version"] = version
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/autoscaling.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/enrich.py`

 * *Files 20% similar despite different names*

```diff
@@ -19,38 +19,36 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class AutoscalingClient(NamespacedClient):
+class EnrichClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete_autoscaling_policy(
+    async def delete_policy(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes an autoscaling policy. Designed for indirect use by ECE/ESS and ECK.
-        Direct use is not supported.
+        Deletes an existing enrich policy and its enrich index.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-delete-autoscaling-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-enrich-policy-api.html>`_
 
-        :param name: the name of the autoscaling policy
+        :param name: Enrich policy to delete.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_autoscaling/policy/{_quote(name)}"
+        __path = f"/_enrich/policy/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
@@ -58,68 +56,74 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_autoscaling_capacity(
+    async def execute_policy(
         self,
         *,
+        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Gets the current autoscaling capacity based on the configured autoscaling policy.
-        Designed for indirect use by ECE/ESS and ECK. Direct use is not supported.
+        Creates the enrich index for an existing enrich policy.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/execute-enrich-policy-api.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-get-autoscaling-capacity.html>`_
+        :param name: Enrich policy to execute.
+        :param wait_for_completion: If `true`, the request blocks other enrich policy
+            execution requests until complete.
         """
-        __path = "/_autoscaling/capacity"
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_enrich/policy/{_quote(name)}/_execute"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if wait_for_completion is not None:
+            __query["wait_for_completion"] = wait_for_completion
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+            "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_autoscaling_policy(
+    async def get_policy(
         self,
         *,
-        name: str,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieves an autoscaling policy. Designed for indirect use by ECE/ESS and ECK.
-        Direct use is not supported.
+        Gets information about an enrich policy.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-get-autoscaling-capacity.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-enrich-policy-api.html>`_
 
-        :param name: the name of the autoscaling policy
+        :param name: Comma-separated list of enrich policy names used to limit the request.
+            To return information for all enrich policies, omit this parameter.
         """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_autoscaling/policy/{_quote(name)}"
+        if name not in SKIP_IN_PATH:
+            __path = f"/_enrich/policy/{_quote(name)}"
+        else:
+            __path = "/_enrich/policy"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
@@ -127,49 +131,88 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_name="policy",
+        body_fields=("geo_match", "match", "range"),
     )
-    async def put_autoscaling_policy(
+    async def put_policy(
         self,
         *,
         name: str,
-        policy: t.Mapping[str, t.Any],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        geo_match: t.Optional[t.Mapping[str, t.Any]] = None,
         human: t.Optional[bool] = None,
+        match: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        range: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates a new autoscaling policy. Designed for indirect use by ECE/ESS and ECK.
-        Direct use is not supported.
+        Creates a new enrich policy.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-put-autoscaling-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-enrich-policy-api.html>`_
 
-        :param name: the name of the autoscaling policy
-        :param policy:
+        :param name: Name of the enrich policy to create or update.
+        :param geo_match: Matches enrich data to incoming documents based on a `geo_shape`
+            query.
+        :param match: Matches enrich data to incoming documents based on a `term` query.
+        :param range: Matches a number, date, or IP address in incoming documents to
+            a range in the enrich index based on a `term` query.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
-        if policy is None:
-            raise ValueError("Empty value passed for parameter 'policy'")
-        __path = f"/_autoscaling/policy/{_quote(name)}"
+        __path = f"/_enrich/policy/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = policy
+        if not __body:
+            if geo_match is not None:
+                __body["geo_match"] = geo_match
+            if match is not None:
+                __body["match"] = match
+            if range is not None:
+                __body["range"] = range
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
+
+    @_rewrite_parameters()
+    async def stats(
+        self,
+        *,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        human: t.Optional[bool] = None,
+        pretty: t.Optional[bool] = None,
+    ) -> ObjectApiResponse[t.Any]:
+        """
+        Gets enrich coordinator statistics and information about enrich policies that
+        are currently executing.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/enrich-stats-api.html>`_
+        """
+        __path = "/_enrich/_stats"
+        __query: t.Dict[str, t.Any] = {}
+        if error_trace is not None:
+            __query["error_trace"] = error_trace
+        if filter_path is not None:
+            __query["filter_path"] = filter_path
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        __headers = {"accept": "application/json"}
+        return await self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
+        )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/cat.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/cat.py`

 * *Files 11% similar despite different names*

```diff
@@ -20,51 +20,40 @@
 from elastic_transport import ObjectApiResponse, TextApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class CatClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def aliases(
         self,
         *,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Shows information about currently configured aliases to indices including filter
         and routing infos.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html>`_
@@ -124,27 +113,25 @@
 
     @_rewrite_parameters()
     async def component_templates(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Returns information about existing component_templates templates.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-component-templates.html>`_
 
@@ -197,29 +184,27 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def count(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Provides quick access to the document count of the entire cluster, or individual
         indices.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html>`_
@@ -275,27 +260,25 @@
         )
 
     @_rewrite_parameters()
     async def help(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> TextApiResponse:
         """
         Returns help for the Cat APIs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html>`_
 
@@ -343,53 +326,41 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def indices(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         health: t.Optional[t.Union["t.Literal['green', 'red', 'yellow']", str]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         include_unloaded_segments: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         pri: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Returns information about indices: number of primaries and replicas, document
@@ -473,69 +444,49 @@
         *,
         id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         time: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Gets configuration and usage information about data frame analytics jobs.
@@ -602,69 +553,49 @@
     @_rewrite_parameters()
     async def ml_datafeeds(
         self,
         *,
         datafeed_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
@@ -739,69 +670,49 @@
         *,
         job_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
@@ -880,70 +791,50 @@
         *,
         model_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         from_: t.Optional[int] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         size: t.Optional[int] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Gets configuration and usage information about inference trained models.
@@ -1020,70 +911,50 @@
     )
     async def transforms(
         self,
         *,
         transform_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         from_: t.Optional[int] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         size: t.Optional[int] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/cluster.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/cluster.py`

 * *Files 4% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import HeadApiResponse, ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class ClusterClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def delete_component_template(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -74,19 +73,17 @@
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def exists_component_template(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
@@ -127,17 +124,15 @@
 
     @_rewrite_parameters()
     async def get_component_template(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
@@ -186,37 +181,25 @@
         )
 
     @_rewrite_parameters()
     async def info(
         self,
         *,
         target: t.Union[
-            t.Union[
-                "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']", str
+            t.Sequence[
+                t.Union[
+                    "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']", str
+                ]
             ],
             t.Union[
-                t.List[
-                    t.Union[
-                        "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']",
-                        str,
-                    ]
-                ],
-                t.Tuple[
-                    t.Union[
-                        "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']",
-                        str,
-                    ],
-                    ...,
-                ],
+                "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']", str
             ],
         ],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns different information about the cluster.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-info.html>`_
@@ -238,35 +221,34 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("template", "allow_auto_create", "meta", "version"),
         parameter_aliases={"_meta": "meta"},
     )
     async def put_component_template(
         self,
         *,
         name: str,
-        template: t.Mapping[str, t.Any],
+        template: t.Optional[t.Mapping[str, t.Any]] = None,
         allow_auto_create: t.Optional[bool] = None,
         create: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a component template
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
 
         :param name: Name of the component template to create. Elasticsearch includes
@@ -296,36 +278,37 @@
             To unset `_meta`, replace the template without specifying this information.
         :param version: Version number used to manage component templates externally.
             This number isn't automatically generated or incremented by Elasticsearch.
             To unset a version, replace the template without specifying a version.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
-        if template is None:
+        if template is None and body is None:
             raise ValueError("Empty value passed for parameter 'template'")
         __path = f"/_component_template/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if template is not None:
-            __body["template"] = template
-        if allow_auto_create is not None:
-            __body["allow_auto_create"] = allow_auto_create
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if template is not None:
+                __body["template"] = template
+            if allow_auto_create is not None:
+                __body["allow_auto_create"] = allow_auto_create
+            if meta is not None:
+                __body["_meta"] = meta
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/dangling_indices.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/logstash.py`

 * *Files 26% similar despite different names*

```diff
@@ -19,144 +19,123 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class DanglingIndicesClient(NamespacedClient):
+class LogstashClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete_dangling_index(
+    def delete_pipeline(
         self,
         *,
-        index_uuid: str,
-        accept_data_loss: bool,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes the specified dangling index
+        Deletes Logstash Pipelines used by Central Management
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-gateway-dangling-indices.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/logstash-api-delete-pipeline.html>`_
 
-        :param index_uuid: The UUID of the dangling index
-        :param accept_data_loss: Must be set to true in order to delete the dangling
-            index
-        :param master_timeout: Specify timeout for connection to master
-        :param timeout: Explicit operation timeout
-        """
-        if index_uuid in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index_uuid'")
-        if accept_data_loss is None:
-            raise ValueError("Empty value passed for parameter 'accept_data_loss'")
-        __path = f"/_dangling/{_quote(index_uuid)}"
+        :param id: Identifier for the pipeline.
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_logstash/pipeline/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        if accept_data_loss is not None:
-            __query["accept_data_loss"] = accept_data_loss
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def import_dangling_index(
+    def get_pipeline(
         self,
         *,
-        index_uuid: str,
-        accept_data_loss: bool,
+        id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Imports the specified dangling index
+        Retrieves Logstash Pipelines used by Central Management
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-gateway-dangling-indices.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/logstash-api-get-pipeline.html>`_
 
-        :param index_uuid: The UUID of the dangling index
-        :param accept_data_loss: Must be set to true in order to import the dangling
-            index
-        :param master_timeout: Specify timeout for connection to master
-        :param timeout: Explicit operation timeout
-        """
-        if index_uuid in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index_uuid'")
-        if accept_data_loss is None:
-            raise ValueError("Empty value passed for parameter 'accept_data_loss'")
-        __path = f"/_dangling/{_quote(index_uuid)}"
+        :param id: Comma-separated list of pipeline identifiers.
+        """
+        if id not in SKIP_IN_PATH:
+            __path = f"/_logstash/pipeline/{_quote(id)}"
+        else:
+            __path = "/_logstash/pipeline"
         __query: t.Dict[str, t.Any] = {}
-        if accept_data_loss is not None:
-            __query["accept_data_loss"] = accept_data_loss
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    async def list_dangling_indices(
+    @_rewrite_parameters(
+        body_name="pipeline",
+    )
+    def put_pipeline(
         self,
         *,
+        id: str,
+        pipeline: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns all dangling indices.
+        Adds and updates Logstash Pipelines used for Central Management
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/logstash-api-put-pipeline.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-gateway-dangling-indices.html>`_
+        :param id: Identifier for the pipeline.
+        :param pipeline:
         """
-        __path = "/_dangling"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        if pipeline is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'pipeline' and 'body', one of them should be set."
+            )
+        elif pipeline is not None and body is not None:
+            raise ValueError("Cannot set both 'pipeline' and 'body'")
+        __path = f"/_logstash/pipeline/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        __body = pipeline if pipeline is not None else body
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/enrich.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/enrich.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class EnrichClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete_policy(
+    def delete_policy(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing enrich policy and its enrich index.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-enrich-policy-api.html>`_
@@ -52,27 +51,25 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def execute_policy(
+    def execute_policy(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates the enrich index for an existing enrich policy.
 
@@ -93,27 +90,25 @@
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_policy(
+    def get_policy(
         self,
         *,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Gets information about an enrich policy.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-enrich-policy-api.html>`_
@@ -131,34 +126,33 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("geo_match", "match", "range"),
     )
-    async def put_policy(
+    def put_policy(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         geo_match: t.Optional[t.Mapping[str, t.Any]] = None,
         human: t.Optional[bool] = None,
         match: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         range: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a new enrich policy.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-enrich-policy-api.html>`_
 
         :param name: Name of the enrich policy to create or update.
@@ -168,42 +162,41 @@
         :param range: Matches a number, date, or IP address in incoming documents to
             a range in the enrich index based on a `term` query.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_enrich/policy/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if geo_match is not None:
-            __body["geo_match"] = geo_match
         if human is not None:
             __query["human"] = human
-        if match is not None:
-            __body["match"] = match
         if pretty is not None:
             __query["pretty"] = pretty
-        if range is not None:
-            __body["range"] = range
+        if not __body:
+            if geo_match is not None:
+                __body["geo_match"] = geo_match
+            if match is not None:
+                __body["match"] = match
+            if range is not None:
+                __body["range"] = range
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def stats(
+    def stats(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Gets enrich coordinator statistics and information about enrich policies that
         are currently executing.
 
@@ -216,10 +209,10 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/eql.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/eql.py`

 * *Files 8% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class EqlClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete(
+    def delete(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an async EQL search by ID. If the search is still running, the search
         request will be cancelled. Otherwise, the saved search results are deleted.
 
@@ -55,38 +54,36 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get(
+    def get(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         pretty: t.Optional[bool] = None,
         wait_for_completion_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns async results from previously executed Event Query Language (EQL) search
 
-        `< https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-eql-search-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-eql-search-api.html>`_
 
         :param id: Identifier for the search.
         :param keep_alive: Period for which the search and its results are stored on
             the cluster. Defaults to the keep_alive value set by the search’s EQL search
             API request.
         :param wait_for_completion_timeout: Timeout duration to wait for the request
             to finish. Defaults to no timeout, meaning the request waits for complete
@@ -105,35 +102,33 @@
         if keep_alive is not None:
             __query["keep_alive"] = keep_alive
         if pretty is not None:
             __query["pretty"] = pretty
         if wait_for_completion_timeout is not None:
             __query["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_status(
+    def get_status(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the status of a previously submitted async or stored Event Query Language
         (EQL) search
 
-        `< https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-eql-status-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-eql-status-api.html>`_
 
         :param id: Identifier for the search.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/_eql/search/status/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
@@ -142,81 +137,75 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "query",
+            "case_sensitive",
+            "event_category_field",
+            "fetch_size",
+            "fields",
+            "filter",
+            "keep_alive",
+            "keep_on_completion",
+            "result_position",
+            "runtime_mappings",
+            "size",
+            "tiebreaker_field",
+            "timestamp_field",
+            "wait_for_completion_timeout",
+        ),
     )
-    async def search(
+    def search(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        query: str,
+        index: t.Union[str, t.Sequence[str]],
+        query: t.Optional[str] = None,
         allow_no_indices: t.Optional[bool] = None,
         case_sensitive: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         event_category_field: t.Optional[str] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         fetch_size: t.Optional[int] = None,
         fields: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         filter: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         keep_on_completion: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         result_position: t.Optional[t.Union["t.Literal['head', 'tail']", str]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         size: t.Optional[int] = None,
         tiebreaker_field: t.Optional[str] = None,
         timestamp_field: t.Optional[str] = None,
         wait_for_completion_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns results matching a query expressed in Event Query Language (EQL)
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/eql-search-api.html>`_
 
         :param index: The name of the index to scope the operation
@@ -243,58 +232,59 @@
         :param tiebreaker_field: Field used to sort hits with the same timestamp in ascending
             order
         :param timestamp_field: Field containing event timestamp. Default "@timestamp"
         :param wait_for_completion_timeout:
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
-        if query is None:
+        if query is None and body is None:
             raise ValueError("Empty value passed for parameter 'query'")
         __path = f"/{_quote(index)}/_eql/search"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if query is not None:
-            __body["query"] = query
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if case_sensitive is not None:
-            __body["case_sensitive"] = case_sensitive
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if event_category_field is not None:
-            __body["event_category_field"] = event_category_field
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if fetch_size is not None:
-            __body["fetch_size"] = fetch_size
-        if fields is not None:
-            __body["fields"] = fields
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if keep_alive is not None:
-            __body["keep_alive"] = keep_alive
-        if keep_on_completion is not None:
-            __body["keep_on_completion"] = keep_on_completion
         if pretty is not None:
             __query["pretty"] = pretty
-        if result_position is not None:
-            __body["result_position"] = result_position
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if size is not None:
-            __body["size"] = size
-        if tiebreaker_field is not None:
-            __body["tiebreaker_field"] = tiebreaker_field
-        if timestamp_field is not None:
-            __body["timestamp_field"] = timestamp_field
-        if wait_for_completion_timeout is not None:
-            __body["wait_for_completion_timeout"] = wait_for_completion_timeout
+        if not __body:
+            if query is not None:
+                __body["query"] = query
+            if case_sensitive is not None:
+                __body["case_sensitive"] = case_sensitive
+            if event_category_field is not None:
+                __body["event_category_field"] = event_category_field
+            if fetch_size is not None:
+                __body["fetch_size"] = fetch_size
+            if fields is not None:
+                __body["fields"] = fields
+            if filter is not None:
+                __body["filter"] = filter
+            if keep_alive is not None:
+                __body["keep_alive"] = keep_alive
+            if keep_on_completion is not None:
+                __body["keep_on_completion"] = keep_on_completion
+            if result_position is not None:
+                __body["result_position"] = result_position
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if size is not None:
+                __body["size"] = size
+            if tiebreaker_field is not None:
+                __body["tiebreaker_field"] = tiebreaker_field
+            if timestamp_field is not None:
+                __body["timestamp_field"] = timestamp_field
+            if wait_for_completion_timeout is not None:
+                __body["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/features.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/license.py`

 * *Files 12% similar despite different names*

```diff
@@ -19,70 +19,50 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import _rewrite_parameters
 
 
-class FeaturesClient(NamespacedClient):
-    @_rewrite_parameters()
-    async def get_features(
-        self,
-        *,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Gets a list of features which can be included in snapshots using the feature_states
-        field when creating a snapshot
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/get-features-api.html>`_
-        """
-        __path = "/_features"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
+class LicenseClient(NamespacedClient):
 
     @_rewrite_parameters()
-    async def reset_features(
+    async def get(
         self,
         *,
+        accept_enterprise: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Resets the internal state of features, usually by deleting system indices
+        Retrieves licensing information for the cluster
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-license.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        :param accept_enterprise: If `true`, this parameter returns enterprise for Enterprise
+            license types. If `false`, this parameter returns platinum for both platinum
+            and enterprise license types. This behavior is maintained for backwards compatibility.
+            This parameter is deprecated and will always be set to true in 8.x.
+        :param local: Specifies whether to retrieve local information. The default value
+            is `false`, which means the information is retrieved from the master node.
         """
-        __path = "/_features/_reset"
+        __path = "/_license"
         __query: t.Dict[str, t.Any] = {}
+        if accept_enterprise is not None:
+            __query["accept_enterprise"] = accept_enterprise
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
+        if local is not None:
+            __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+            "GET", __path, params=__query, headers=__headers
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/fleet.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/async_search.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,283 +19,228 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class FleetClient(NamespacedClient):
+class AsyncSearchClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def global_checkpoints(
+    async def delete(
         self,
         *,
-        index: str,
-        checkpoints: t.Optional[t.Union[t.List[int], t.Tuple[int, ...]]] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        wait_for_advance: t.Optional[bool] = None,
-        wait_for_index: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns the current global checkpoints for an index. This API is design for internal
-        use by the fleet server project.
+        Deletes an async search by ID. If the search is still running, the search request
+        will be cancelled. Otherwise, the saved search results are deleted.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/get-global-checkpoints.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/async-search.html>`_
 
-        :param index: A single index or index alias that resolves to a single index.
-        :param checkpoints: A comma separated list of previous global checkpoints. When
-            used in combination with `wait_for_advance`, the API will only return once
-            the global checkpoints advances past the checkpoints. Providing an empty
-            list will cause Elasticsearch to immediately return the current global checkpoints.
-        :param timeout: Period to wait for a global checkpoints to advance past `checkpoints`.
-        :param wait_for_advance: A boolean value which controls whether to wait (until
-            the timeout) for the global checkpoints to advance past the provided `checkpoints`.
-        :param wait_for_index: A boolean value which controls whether to wait (until
-            the timeout) for the target index to exist and all primary shards be active.
-            Can only be true when `wait_for_advance` is true.
+        :param id: A unique identifier for the async search.
         """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_fleet/global_checkpoints"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_async_search/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        if checkpoints is not None:
-            __query["checkpoints"] = checkpoints
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if wait_for_advance is not None:
-            __query["wait_for_advance"] = wait_for_advance
-        if wait_for_index is not None:
-            __query["wait_for_index"] = wait_for_index
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+            "DELETE", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters(
-        body_name="searches",
-    )
-    async def msearch(
+    @_rewrite_parameters()
+    async def get(
         self,
         *,
-        searches: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[str] = None,
-        allow_no_indices: t.Optional[bool] = None,
-        allow_partial_search_results: t.Optional[bool] = None,
-        ccs_minimize_roundtrips: t.Optional[bool] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        expand_wildcards: t.Optional[
-            t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
-                ],
-            ]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ignore_throttled: t.Optional[bool] = None,
-        ignore_unavailable: t.Optional[bool] = None,
-        max_concurrent_searches: t.Optional[int] = None,
-        max_concurrent_shard_requests: t.Optional[int] = None,
-        pre_filter_shard_size: t.Optional[int] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         pretty: t.Optional[bool] = None,
-        rest_total_hits_as_int: t.Optional[bool] = None,
-        search_type: t.Optional[
-            t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
-        ] = None,
         typed_keys: t.Optional[bool] = None,
-        wait_for_checkpoints: t.Optional[
-            t.Union[t.List[int], t.Tuple[int, ...]]
+        wait_for_completion_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Multi Search API where the search will only be executed after specified checkpoints
-        are available due to a refresh. This API is designed for internal use by the
-        fleet server project.
-
-        :param searches:
-        :param index: A single target to search. If the target is an index alias, it
-            must resolve to a single index.
-        :param allow_no_indices: If false, the request returns an error if any wildcard
-            expression, index alias, or _all value targets only missing or closed indices.
-            This behavior applies even if the request targets other open indices. For
-            example, a request targeting foo*,bar* returns an error if an index starts
-            with foo but no index starts with bar.
-        :param allow_partial_search_results: If true, returns partial results if there
-            are shard request timeouts or [shard failures](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#shard-failures).
-            If false, returns an error with no partial results. Defaults to the configured
-            cluster setting `search.default_allow_partial_results` which is true by default.
-        :param ccs_minimize_roundtrips: If true, network roundtrips between the coordinating
-            node and remote clusters are minimized for cross-cluster search requests.
-        :param expand_wildcards: Type of index that wildcard expressions can match. If
-            the request can target data streams, this argument determines whether wildcard
-            expressions match hidden data streams.
-        :param ignore_throttled: If true, concrete, expanded or aliased indices are ignored
-            when frozen.
-        :param ignore_unavailable: If true, missing or closed indices are not included
-            in the response.
-        :param max_concurrent_searches: Maximum number of concurrent searches the multi
-            search API can execute.
-        :param max_concurrent_shard_requests: Maximum number of concurrent shard requests
-            that each sub-search request executes per node.
-        :param pre_filter_shard_size: Defines a threshold that enforces a pre-filter
-            roundtrip to prefilter search shards based on query rewriting if the number
-            of shards the search request expands to exceeds the threshold. This filter
-            roundtrip can limit the number of shards significantly if for instance a
-            shard can not match any documents based on its rewrite method i.e., if date
-            filters are mandatory to match but the shard bounds and the query are disjoint.
-        :param rest_total_hits_as_int: If true, hits.total are returned as an integer
-            in the response. Defaults to false, which returns an object.
-        :param search_type: Indicates whether global term and document frequencies should
-            be used when scoring returned documents.
-        :param typed_keys: Specifies whether aggregation and suggester names should be
-            prefixed by their respective types in the response.
-        :param wait_for_checkpoints: A comma separated list of checkpoints. When configured,
-            the search API will only be executed on a shard after the relevant checkpoint
-            has become visible for search. Defaults to an empty list which will cause
-            Elasticsearch to immediately execute the search.
+        Retrieves the results of a previously submitted async search request given its
+        ID.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/async-search.html>`_
+
+        :param id: A unique identifier for the async search.
+        :param keep_alive: Specifies how long the async search should be available in
+            the cluster. When not specified, the `keep_alive` set with the corresponding
+            submit async request will be used. Otherwise, it is possible to override
+            the value and extend the validity of the request. When this period expires,
+            the search, if still running, is cancelled. If the search is completed, its
+            saved results are deleted.
+        :param typed_keys: Specify whether aggregation and suggester names should be
+            prefixed by their respective types in the response
+        :param wait_for_completion_timeout: Specifies to wait for the search to be completed
+            up until the provided timeout. Final results will be returned if available
+            before the timeout expires, otherwise the currently available results will
+            be returned once the timeout expires. By default no timeout is set meaning
+            that the currently available results will be returned without any additional
+            wait.
         """
-        if searches is None:
-            raise ValueError("Empty value passed for parameter 'searches'")
-        if index not in SKIP_IN_PATH:
-            __path = f"/{_quote(index)}/_fleet/_fleet_msearch"
-        else:
-            __path = "/_fleet/_fleet_msearch"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_async_search/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_indices is not None:
-            __query["allow_no_indices"] = allow_no_indices
-        if allow_partial_search_results is not None:
-            __query["allow_partial_search_results"] = allow_partial_search_results
-        if ccs_minimize_roundtrips is not None:
-            __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if expand_wildcards is not None:
-            __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ignore_throttled is not None:
-            __query["ignore_throttled"] = ignore_throttled
-        if ignore_unavailable is not None:
-            __query["ignore_unavailable"] = ignore_unavailable
-        if max_concurrent_searches is not None:
-            __query["max_concurrent_searches"] = max_concurrent_searches
-        if max_concurrent_shard_requests is not None:
-            __query["max_concurrent_shard_requests"] = max_concurrent_shard_requests
-        if pre_filter_shard_size is not None:
-            __query["pre_filter_shard_size"] = pre_filter_shard_size
+        if keep_alive is not None:
+            __query["keep_alive"] = keep_alive
         if pretty is not None:
             __query["pretty"] = pretty
-        if rest_total_hits_as_int is not None:
-            __query["rest_total_hits_as_int"] = rest_total_hits_as_int
-        if search_type is not None:
-            __query["search_type"] = search_type
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        if wait_for_checkpoints is not None:
-            __query["wait_for_checkpoints"] = wait_for_checkpoints
-        __body = searches
-        __headers = {
-            "accept": "application/json",
-            "content-type": "application/x-ndjson",
-        }
+        if wait_for_completion_timeout is not None:
+            __query["wait_for_completion_timeout"] = wait_for_completion_timeout
+        __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+            "GET", __path, params=__query, headers=__headers
+        )
+
+    @_rewrite_parameters()
+    async def status(
+        self,
+        *,
+        id: str,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        human: t.Optional[bool] = None,
+        pretty: t.Optional[bool] = None,
+    ) -> ObjectApiResponse[t.Any]:
+        """
+        Retrieves the status of a previously submitted async search request given its
+        ID.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/async-search.html>`_
+
+        :param id: A unique identifier for the async search.
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_async_search/status/{_quote(id)}"
+        __query: t.Dict[str, t.Any] = {}
+        if error_trace is not None:
+            __query["error_trace"] = error_trace
+        if filter_path is not None:
+            __query["filter_path"] = filter_path
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        __headers = {"accept": "application/json"}
+        return await self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "aggs",
+            "collapse",
+            "docvalue_fields",
+            "explain",
+            "ext",
+            "fields",
+            "from_",
+            "highlight",
+            "indices_boost",
+            "knn",
+            "min_score",
+            "pit",
+            "post_filter",
+            "profile",
+            "query",
+            "rescore",
+            "runtime_mappings",
+            "script_fields",
+            "search_after",
+            "seq_no_primary_term",
+            "size",
+            "slice",
+            "sort",
+            "source",
+            "stats",
+            "stored_fields",
+            "suggest",
+            "terminate_after",
+            "timeout",
+            "track_scores",
+            "track_total_hits",
+            "version",
+        ),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
             "from": "from_",
         },
     )
-    async def search(
+    async def submit(
         self,
         *,
-        index: str,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         allow_partial_search_results: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         batched_reduce_size: t.Optional[int] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         collapse: t.Optional[t.Mapping[str, t.Any]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
-        docvalue_fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docvalue_fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
         ext: t.Optional[t.Mapping[str, t.Any]] = None,
-        fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         highlight: t.Optional[t.Mapping[str, t.Any]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indices_boost: t.Optional[
-            t.Union[t.List[t.Mapping[str, float]], t.Tuple[t.Mapping[str, float], ...]]
+        indices_boost: t.Optional[t.Sequence[t.Mapping[str, float]]] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        keep_on_completion: t.Optional[bool] = None,
+        knn: t.Optional[
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         lenient: t.Optional[bool] = None,
         max_concurrent_shard_requests: t.Optional[int] = None,
         min_compatible_shard_node: t.Optional[str] = None,
         min_score: t.Optional[float] = None,
         pit: t.Optional[t.Mapping[str, t.Any]] = None,
         post_filter: t.Optional[t.Mapping[str, t.Any]] = None,
@@ -303,328 +248,346 @@
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         profile: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         request_cache: t.Optional[bool] = None,
         rescore: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         search_after: t.Optional[
-            t.Union[
-                t.List[t.Union[None, bool, float, int, str, t.Any]],
-                t.Tuple[t.Union[None, bool, float, int, str, t.Any], ...],
-            ]
+            t.Sequence[t.Union[None, bool, float, int, str, t.Any]]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         seq_no_primary_term: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
         source: t.Optional[t.Union[bool, t.Mapping[str, t.Any]]] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         suggest: t.Optional[t.Mapping[str, t.Any]] = None,
         suggest_field: t.Optional[str] = None,
         suggest_mode: t.Optional[
             t.Union["t.Literal['always', 'missing', 'popular']", str]
         ] = None,
         suggest_size: t.Optional[int] = None,
         suggest_text: t.Optional[str] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[str] = None,
         track_scores: t.Optional[bool] = None,
         track_total_hits: t.Optional[t.Union[bool, int]] = None,
         typed_keys: t.Optional[bool] = None,
         version: t.Optional[bool] = None,
-        wait_for_checkpoints: t.Optional[
-            t.Union[t.List[int], t.Tuple[int, ...]]
+        wait_for_completion_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Search API where the search will only be executed after specified checkpoints
-        are available due to a refresh. This API is designed for internal use by the
-        fleet server project.
+        Executes a search request asynchronously.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/async-search.html>`_
 
-        :param index: A single target to search. If the target is an index alias, it
-            must resolve to a single index.
+        :param index: A comma-separated list of index names to search; use `_all` or
+            empty string to perform the operation on all indices
         :param aggregations:
         :param aggs:
-        :param allow_no_indices:
-        :param allow_partial_search_results: If true, returns partial results if there
-            are shard request timeouts or [shard failures](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#shard-failures).
-            If false, returns an error with no partial results. Defaults to the configured
-            cluster setting `search.default_allow_partial_results` which is true by default.
-        :param analyze_wildcard:
-        :param analyzer:
-        :param batched_reduce_size:
-        :param ccs_minimize_roundtrips:
+        :param allow_no_indices: Whether to ignore if a wildcard indices expression resolves
+            into no concrete indices. (This includes `_all` string or when no indices
+            have been specified)
+        :param allow_partial_search_results: Indicate if an error should be returned
+            if there is a partial search failure or timeout
+        :param analyze_wildcard: Specify whether wildcard and prefix queries should be
+            analyzed (default: false)
+        :param analyzer: The analyzer to use for the query string
+        :param batched_reduce_size: Affects how often partial results become available,
+            which happens whenever shard results are reduced. A partial reduction is
+            performed every time the coordinating node has received a certain number
+            of new shard responses (5 by default).
+        :param ccs_minimize_roundtrips: The default value is the only supported value.
         :param collapse:
-        :param default_operator:
-        :param df:
+        :param default_operator: The default operator for query string query (AND or
+            OR)
+        :param df: The field to use as default where no field prefix is given in the
+            query string
         :param docvalue_fields: Array of wildcard (*) patterns. The request returns doc
             values for field names matching these patterns in the hits.fields property
             of the response.
-        :param expand_wildcards:
+        :param expand_wildcards: Whether to expand wildcard expression to concrete indices
+            that are open, closed or both.
         :param explain: If true, returns detailed information about score computation
             as part of a hit.
         :param ext: Configuration of search extensions defined by Elasticsearch plugins.
         :param fields: Array of wildcard (*) patterns. The request returns values for
             field names matching these patterns in the hits.fields property of the response.
         :param from_: Starting document offset. By default, you cannot page through more
             than 10,000 hits using the from and size parameters. To page through more
             hits, use the search_after parameter.
         :param highlight:
-        :param ignore_throttled:
-        :param ignore_unavailable:
+        :param ignore_throttled: Whether specified concrete, expanded or aliased indices
+            should be ignored when throttled
+        :param ignore_unavailable: Whether specified concrete indices should be ignored
+            when unavailable (missing or closed)
         :param indices_boost: Boosts the _score of documents from specified indices.
-        :param lenient:
-        :param max_concurrent_shard_requests:
+        :param keep_alive: Specifies how long the async search needs to be available.
+            Ongoing async searches and any saved search results are deleted after this
+            period.
+        :param keep_on_completion: If `true`, results are stored for later retrieval
+            when the search completes within the `wait_for_completion_timeout`.
+        :param knn: Defines the approximate kNN search to run.
+        :param lenient: Specify whether format-based query failures (such as providing
+            text to a numeric field) should be ignored
+        :param max_concurrent_shard_requests: The number of concurrent shard requests
+            per node this search executes concurrently. This value should be used to
+            limit the impact of the search on the cluster in order to limit the number
+            of concurrent shard requests
         :param min_compatible_shard_node:
         :param min_score: Minimum _score for matching documents. Documents with a lower
             _score are not included in the search results.
         :param pit: Limits the search to a point in time (PIT). If you provide a PIT,
             you cannot specify an <index> in the request path.
         :param post_filter:
-        :param pre_filter_shard_size:
-        :param preference:
+        :param pre_filter_shard_size: The default value cannot be changed, which enforces
+            the execution of a pre-filter roundtrip to retrieve statistics from each
+            shard so that the ones that surely don’t hold any document matching the query
+            get skipped.
+        :param preference: Specify the node or shard the operation should be performed
+            on (default: random)
         :param profile:
-        :param q:
+        :param q: Query in the Lucene query string syntax
         :param query: Defines the search definition using the Query DSL.
-        :param request_cache:
+        :param request_cache: Specify if request cache should be used for this request
+            or not, defaults to true
         :param rescore:
         :param rest_total_hits_as_int:
-        :param routing:
+        :param routing: A comma-separated list of specific routing values
         :param runtime_mappings: Defines one or more runtime fields in the search request.
             These fields take precedence over mapped fields with the same name.
         :param script_fields: Retrieve a script evaluation (based on different fields)
             for each hit.
         :param scroll:
         :param search_after:
-        :param search_type:
+        :param search_type: Search operation type
         :param seq_no_primary_term: If true, returns sequence number and primary term
             of the last modification of each hit. See Optimistic concurrency control.
         :param size: The number of hits to return. By default, you cannot page through
             more than 10,000 hits using the from and size parameters. To page through
             more hits, use the search_after parameter.
         :param slice:
         :param sort:
         :param source: Indicates which source fields are returned for matching documents.
             These fields are returned in the hits._source property of the search response.
-        :param source_excludes:
-        :param source_includes:
+        :param source_excludes: A list of fields to exclude from the returned _source
+            field
+        :param source_includes: A list of fields to extract and return from the _source
+            field
         :param stats: Stats groups to associate with the search. Each group maintains
             a statistics aggregation for its associated searches. You can retrieve these
             stats using the indices stats API.
         :param stored_fields: List of stored fields to return as part of a hit. If no
             fields are specified, no stored fields are included in the response. If this
             field is specified, the _source parameter defaults to false. You can pass
             _source: true to return both source fields and stored fields in the search
             response.
         :param suggest:
         :param suggest_field: Specifies which field to use for suggestions.
-        :param suggest_mode:
-        :param suggest_size:
+        :param suggest_mode: Specify suggest mode
+        :param suggest_size: How many suggestions to return in response
         :param suggest_text: The source text for which the suggestions should be returned.
         :param terminate_after: Maximum number of documents to collect for each shard.
             If a query reaches this limit, Elasticsearch terminates the query early.
             Elasticsearch collects documents before sorting. Defaults to 0, which does
             not terminate query execution early.
         :param timeout: Specifies the period of time to wait for a response from each
             shard. If no response is received before the timeout expires, the request
             fails and returns an error. Defaults to no timeout.
         :param track_scores: If true, calculate and return document scores, even if the
             scores are not used for sorting.
         :param track_total_hits: Number of hits matching the query to count accurately.
             If true, the exact number of hits is returned at the cost of some performance.
             If false, the response does not include the total number of hits matching
             the query. Defaults to 10,000 hits.
-        :param typed_keys:
+        :param typed_keys: Specify whether aggregation and suggester names should be
+            prefixed by their respective types in the response
         :param version: If true, returns document version as part of a hit.
-        :param wait_for_checkpoints: A comma separated list of checkpoints. When configured,
-            the search API will only be executed on a shard after the relevant checkpoint
-            has become visible for search. Defaults to an empty list which will cause
-            Elasticsearch to immediately execute the search.
+        :param wait_for_completion_timeout: Blocks and waits until the search is completed
+            up to a certain timeout. When the async search completes within the timeout,
+            the response won’t include the ID as the results are not stored in the cluster.
         """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_fleet/_fleet_search"
-        __body: t.Dict[str, t.Any] = {}
+        if index not in SKIP_IN_PATH:
+            __path = f"/{_quote(index)}/_async_search"
+        else:
+            __path = "/_async_search"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
             )
         ):
             __query["sort"] = sort
             sort = None
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
-        if aggs is not None:
-            __body["aggs"] = aggs
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if allow_partial_search_results is not None:
             __query["allow_partial_search_results"] = allow_partial_search_results
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if batched_reduce_size is not None:
             __query["batched_reduce_size"] = batched_reduce_size
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
-        if collapse is not None:
-            __body["collapse"] = collapse
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
             __query["df"] = df
-        if docvalue_fields is not None:
-            __body["docvalue_fields"] = docvalue_fields
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if explain is not None:
-            __body["explain"] = explain
-        if ext is not None:
-            __body["ext"] = ext
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_ is not None:
-            __body["from"] = from_
-        if highlight is not None:
-            __body["highlight"] = highlight
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indices_boost is not None:
-            __body["indices_boost"] = indices_boost
+        if keep_alive is not None:
+            __query["keep_alive"] = keep_alive
+        if keep_on_completion is not None:
+            __query["keep_on_completion"] = keep_on_completion
         if lenient is not None:
             __query["lenient"] = lenient
         if max_concurrent_shard_requests is not None:
             __query["max_concurrent_shard_requests"] = max_concurrent_shard_requests
         if min_compatible_shard_node is not None:
             __query["min_compatible_shard_node"] = min_compatible_shard_node
-        if min_score is not None:
-            __body["min_score"] = min_score
-        if pit is not None:
-            __body["pit"] = pit
-        if post_filter is not None:
-            __body["post_filter"] = post_filter
         if pre_filter_shard_size is not None:
             __query["pre_filter_shard_size"] = pre_filter_shard_size
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if profile is not None:
-            __body["profile"] = profile
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if request_cache is not None:
             __query["request_cache"] = request_cache
-        if rescore is not None:
-            __body["rescore"] = rescore
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
         if scroll is not None:
             __query["scroll"] = scroll
-        if search_after is not None:
-            __body["search_after"] = search_after
         if search_type is not None:
             __query["search_type"] = search_type
-        if seq_no_primary_term is not None:
-            __body["seq_no_primary_term"] = seq_no_primary_term
-        if size is not None:
-            __body["size"] = size
-        if slice is not None:
-            __body["slice"] = slice
-        if sort is not None:
-            __body["sort"] = sort
-        if source is not None:
-            __body["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
-        if stats is not None:
-            __body["stats"] = stats
-        if stored_fields is not None:
-            __body["stored_fields"] = stored_fields
-        if suggest is not None:
-            __body["suggest"] = suggest
         if suggest_field is not None:
             __query["suggest_field"] = suggest_field
         if suggest_mode is not None:
             __query["suggest_mode"] = suggest_mode
         if suggest_size is not None:
             __query["suggest_size"] = suggest_size
         if suggest_text is not None:
             __query["suggest_text"] = suggest_text
-        if terminate_after is not None:
-            __body["terminate_after"] = terminate_after
-        if timeout is not None:
-            __body["timeout"] = timeout
-        if track_scores is not None:
-            __body["track_scores"] = track_scores
-        if track_total_hits is not None:
-            __body["track_total_hits"] = track_total_hits
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        if version is not None:
-            __body["version"] = version
-        if wait_for_checkpoints is not None:
-            __query["wait_for_checkpoints"] = wait_for_checkpoints
+        if wait_for_completion_timeout is not None:
+            __query["wait_for_completion_timeout"] = wait_for_completion_timeout
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if collapse is not None:
+                __body["collapse"] = collapse
+            if docvalue_fields is not None:
+                __body["docvalue_fields"] = docvalue_fields
+            if explain is not None:
+                __body["explain"] = explain
+            if ext is not None:
+                __body["ext"] = ext
+            if fields is not None:
+                __body["fields"] = fields
+            if from_ is not None:
+                __body["from"] = from_
+            if highlight is not None:
+                __body["highlight"] = highlight
+            if indices_boost is not None:
+                __body["indices_boost"] = indices_boost
+            if knn is not None:
+                __body["knn"] = knn
+            if min_score is not None:
+                __body["min_score"] = min_score
+            if pit is not None:
+                __body["pit"] = pit
+            if post_filter is not None:
+                __body["post_filter"] = post_filter
+            if profile is not None:
+                __body["profile"] = profile
+            if query is not None:
+                __body["query"] = query
+            if rescore is not None:
+                __body["rescore"] = rescore
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if seq_no_primary_term is not None:
+                __body["seq_no_primary_term"] = seq_no_primary_term
+            if size is not None:
+                __body["size"] = size
+            if slice is not None:
+                __body["slice"] = slice
+            if sort is not None:
+                __body["sort"] = sort
+            if source is not None:
+                __body["_source"] = source
+            if stats is not None:
+                __body["stats"] = stats
+            if stored_fields is not None:
+                __body["stored_fields"] = stored_fields
+            if suggest is not None:
+                __body["suggest"] = suggest
+            if terminate_after is not None:
+                __body["terminate_after"] = terminate_after
+            if timeout is not None:
+                __body["timeout"] = timeout
+            if track_scores is not None:
+                __body["track_scores"] = track_scores
+            if track_total_hits is not None:
+                __body["track_total_hits"] = track_total_hits
+            if version is not None:
+                __body["version"] = version
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/graph.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/graph.py`

 * *Files 4% similar despite different names*

```diff
@@ -20,35 +20,33 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class GraphClient(NamespacedClient):
+
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("connections", "controls", "query", "vertices"),
     )
-    async def explore(
+    def explore(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         connections: t.Optional[t.Mapping[str, t.Any]] = None,
         controls: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         routing: t.Optional[str] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        vertices: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        vertices: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Explore extracted and summarized information about the documents and terms in
         an index.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/graph-explore-api.html>`_
 
@@ -64,37 +62,38 @@
             fails and returns an error. Defaults to no timeout.
         :param vertices: Specifies one or more fields that contain the terms you want
             to include in the graph as vertices.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_graph/explore"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if connections is not None:
-            __body["connections"] = connections
-        if controls is not None:
-            __body["controls"] = controls
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
         if routing is not None:
             __query["routing"] = routing
         if timeout is not None:
             __query["timeout"] = timeout
-        if vertices is not None:
-            __body["vertices"] = vertices
+        if not __body:
+            if connections is not None:
+                __body["connections"] = connections
+            if controls is not None:
+                __body["controls"] = controls
+            if query is not None:
+                __body["query"] = query
+            if vertices is not None:
+                __body["vertices"] = vertices
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ilm.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/sql.py`

 * *Files 22% similar despite different names*

```diff
@@ -19,525 +19,368 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class IlmClient(NamespacedClient):
-    @_rewrite_parameters()
-    async def delete_lifecycle(
-        self,
-        *,
-        name: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Deletes the specified lifecycle policy definition. A currently used policy cannot
-        be deleted.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-delete-lifecycle.html>`_
-
-        :param name: Identifier for the policy.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_ilm/policy/{_quote(name)}"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "DELETE", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    async def explain_lifecycle(
-        self,
-        *,
-        index: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        only_errors: t.Optional[bool] = None,
-        only_managed: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Retrieves information about the index's current lifecycle state, such as the
-        currently executing phase, action, and step.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-explain-lifecycle.html>`_
-
-        :param index: Comma-separated list of data streams, indices, and aliases to target.
-            Supports wildcards (`*`). To target all data streams and indices, use `*`
-            or `_all`.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param only_errors: Filters the returned indices to only indices that are managed
-            by ILM and are in an error state, either due to an encountering an error
-            while executing the policy, or attempting to use a policy that does not exist.
-        :param only_managed: Filters the returned indices to only indices that are managed
-            by ILM.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_ilm/explain"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if only_errors is not None:
-            __query["only_errors"] = only_errors
-        if only_managed is not None:
-            __query["only_managed"] = only_managed
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    async def get_lifecycle(
-        self,
-        *,
-        name: t.Optional[str] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Returns the specified policy definition. Includes the policy version and last
-        modified date.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-get-lifecycle.html>`_
-
-        :param name: Identifier for the policy.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if name not in SKIP_IN_PATH:
-            __path = f"/_ilm/policy/{_quote(name)}"
-        else:
-            __path = "/_ilm/policy"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    async def get_status(
-        self,
-        *,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Retrieves the current index lifecycle management (ILM) status.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-get-status.html>`_
-        """
-        __path = "/_ilm/status"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
+class SqlClient(NamespacedClient):
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("cursor",),
     )
-    async def migrate_to_data_tiers(
+    def clear_cursor(
         self,
         *,
-        dry_run: t.Optional[bool] = None,
+        cursor: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        legacy_template_to_delete: t.Optional[str] = None,
-        node_attribute: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Migrates the indices and ILM policies away from custom node attribute allocation
-        routing to data tiers routing
+        Clears the SQL cursor
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-migrate-to-data-tiers.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-sql-cursor-api.html>`_
 
-        :param dry_run: If true, simulates the migration from node attributes based allocation
-            filters to data tiers, but does not perform the migration. This provides
-            a way to retrieve the indices and ILM policies that need to be migrated.
-        :param legacy_template_to_delete:
-        :param node_attribute:
+        :param cursor: Cursor to clear.
         """
-        __path = "/_ilm/migrate_to_data_tiers"
+        if cursor is None and body is None:
+            raise ValueError("Empty value passed for parameter 'cursor'")
+        __path = "/_sql/close"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
-        if dry_run is not None:
-            __query["dry_run"] = dry_run
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if legacy_template_to_delete is not None:
-            __body["legacy_template_to_delete"] = legacy_template_to_delete
-        if node_attribute is not None:
-            __body["node_attribute"] = node_attribute
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
-            __body = None  # type: ignore[assignment]
-        __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+            if cursor is not None:
+                __body["cursor"] = cursor
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters(
-        body_fields=True,
-    )
-    async def move_to_step(
+    @_rewrite_parameters()
+    def delete_async(
         self,
         *,
-        index: str,
-        current_step: t.Optional[t.Mapping[str, t.Any]] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        next_step: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Manually moves an index into the specified step and executes that step.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-move-to-step.html>`_
+        Deletes an async SQL search or a stored synchronous SQL search. If the search
+        is still running, the API cancels it.
 
-        :param index: The name of the index whose lifecycle step is to change
-        :param current_step:
-        :param next_step:
-        """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/_ilm/move/{_quote(index)}"
-        __body: t.Dict[str, t.Any] = {}
-        __query: t.Dict[str, t.Any] = {}
-        if current_step is not None:
-            __body["current_step"] = current_step
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if next_step is not None:
-            __body["next_step"] = next_step
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if not __body:
-            __body = None  # type: ignore[assignment]
-        __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
-        )
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-async-sql-search-api.html>`_
 
-    @_rewrite_parameters(
-        body_fields=True,
-    )
-    async def put_lifecycle(
-        self,
-        *,
-        name: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        policy: t.Optional[t.Mapping[str, t.Any]] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-    ) -> ObjectApiResponse[t.Any]:
+        :param id: Identifier for the search.
         """
-        Creates a lifecycle policy
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-put-lifecycle.html>`_
-
-        :param name: Identifier for the policy.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param policy:
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_ilm/policy/{_quote(name)}"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_sql/async/delete/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if policy is not None:
-            __body["policy"] = policy
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if not __body:
-            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
+        return self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def remove_policy(
+    def get_async(
         self,
         *,
-        index: str,
+        id: str,
+        delimiter: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        format: t.Optional[str] = None,
         human: t.Optional[bool] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         pretty: t.Optional[bool] = None,
+        wait_for_completion_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
+        ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Removes the assigned lifecycle policy and stops managing the specified index
+        Returns the current status and available results for an async SQL search or stored
+        synchronous SQL search
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-remove-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-sql-search-api.html>`_
 
-        :param index: The name of the index to remove policy on
+        :param id: Identifier for the search.
+        :param delimiter: Separator for CSV results. The API only supports this parameter
+            for CSV responses.
+        :param format: Format for the response. You must specify a format using this
+            parameter or the Accept HTTP header. If you specify both, the API uses this
+            parameter.
+        :param keep_alive: Retention period for the search and its results. Defaults
+            to the `keep_alive` period for the original SQL search.
+        :param wait_for_completion_timeout: Period to wait for complete results. Defaults
+            to no timeout, meaning the request waits for complete search results.
         """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_ilm/remove"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_sql/async/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
+        if delimiter is not None:
+            __query["delimiter"] = delimiter
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if format is not None:
+            __query["format"] = format
         if human is not None:
             __query["human"] = human
+        if keep_alive is not None:
+            __query["keep_alive"] = keep_alive
         if pretty is not None:
             __query["pretty"] = pretty
+        if wait_for_completion_timeout is not None:
+            __query["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def retry(
+    def get_async_status(
         self,
         *,
-        index: str,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retries executing the policy for an index that is in the ERROR step.
+        Returns the current status of an async SQL search or a stored synchronous SQL
+        search
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-retry-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-sql-search-status-api.html>`_
 
-        :param index: The name of the indices (comma-separated) whose failed lifecycle
-            step is to be retry
+        :param id: Identifier for the search.
         """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_ilm/retry"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_sql/async/status/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    async def start(
+    @_rewrite_parameters(
+        body_fields=(
+            "catalog",
+            "columnar",
+            "cursor",
+            "fetch_size",
+            "field_multi_value_leniency",
+            "filter",
+            "index_using_frozen",
+            "keep_alive",
+            "keep_on_completion",
+            "page_timeout",
+            "params",
+            "query",
+            "request_timeout",
+            "runtime_mappings",
+            "time_zone",
+            "wait_for_completion_timeout",
+        ),
+        ignore_deprecated_options={"params", "request_timeout"},
+    )
+    def query(
         self,
         *,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        catalog: t.Optional[str] = None,
+        columnar: t.Optional[bool] = None,
+        cursor: t.Optional[str] = None,
+        error_trace: t.Optional[bool] = None,
+        fetch_size: t.Optional[int] = None,
+        field_multi_value_leniency: t.Optional[bool] = None,
+        filter: t.Optional[t.Mapping[str, t.Any]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        format: t.Optional[str] = None,
+        human: t.Optional[bool] = None,
+        index_using_frozen: t.Optional[bool] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        keep_on_completion: t.Optional[bool] = None,
+        page_timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        params: t.Optional[t.Mapping[str, t.Any]] = None,
+        pretty: t.Optional[bool] = None,
+        query: t.Optional[str] = None,
+        request_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
+        runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        time_zone: t.Optional[str] = None,
+        wait_for_completion_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Start the index lifecycle management (ILM) plugin.
+        Executes a SQL request
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-start.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/sql-search-api.html>`_
 
-        :param master_timeout:
-        :param timeout:
-        """
-        __path = "/_ilm/start"
+        :param catalog: Default catalog (cluster) for queries. If unspecified, the queries
+            execute on the data in the local cluster only.
+        :param columnar: If true, the results in a columnar fashion: one row represents
+            all the values of a certain column from the current page of results.
+        :param cursor: Cursor used to retrieve a set of paginated results. If you specify
+            a cursor, the API only uses the `columnar` and `time_zone` request body parameters.
+            It ignores other request body parameters.
+        :param fetch_size: The maximum number of rows (or entries) to return in one response
+        :param field_multi_value_leniency: Throw an exception when encountering multiple
+            values for a field (default) or be lenient and return the first value from
+            the list (without any guarantees of what that will be - typically the first
+            in natural ascending order).
+        :param filter: Elasticsearch query DSL for additional filtering.
+        :param format: Format for the response.
+        :param index_using_frozen: If true, the search can run on frozen indices. Defaults
+            to false.
+        :param keep_alive: Retention period for an async or saved synchronous search.
+        :param keep_on_completion: If true, Elasticsearch stores synchronous searches
+            if you also specify the wait_for_completion_timeout parameter. If false,
+            Elasticsearch only stores async searches that don’t finish before the wait_for_completion_timeout.
+        :param page_timeout: The timeout before a pagination request fails.
+        :param params: Values for parameters in the query.
+        :param query: SQL query to run.
+        :param request_timeout: The timeout before the request fails.
+        :param runtime_mappings: Defines one or more runtime fields in the search request.
+            These fields take precedence over mapped fields with the same name.
+        :param time_zone: ISO-8601 time zone ID for the search.
+        :param wait_for_completion_timeout: Period to wait for complete results. Defaults
+            to no timeout, meaning the request waits for complete search results. If
+            the search doesn’t finish within this period, the search becomes async.
+        """
+        __path = "/_sql"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if format is not None:
+            __query["format"] = format
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        if not __body:
+            if catalog is not None:
+                __body["catalog"] = catalog
+            if columnar is not None:
+                __body["columnar"] = columnar
+            if cursor is not None:
+                __body["cursor"] = cursor
+            if fetch_size is not None:
+                __body["fetch_size"] = fetch_size
+            if field_multi_value_leniency is not None:
+                __body["field_multi_value_leniency"] = field_multi_value_leniency
+            if filter is not None:
+                __body["filter"] = filter
+            if index_using_frozen is not None:
+                __body["index_using_frozen"] = index_using_frozen
+            if keep_alive is not None:
+                __body["keep_alive"] = keep_alive
+            if keep_on_completion is not None:
+                __body["keep_on_completion"] = keep_on_completion
+            if page_timeout is not None:
+                __body["page_timeout"] = page_timeout
+            if params is not None:
+                __body["params"] = params
+            if query is not None:
+                __body["query"] = query
+            if request_timeout is not None:
+                __body["request_timeout"] = request_timeout
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if time_zone is not None:
+                __body["time_zone"] = time_zone
+            if wait_for_completion_timeout is not None:
+                __body["wait_for_completion_timeout"] = wait_for_completion_timeout
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters()
-    async def stop(
+    @_rewrite_parameters(
+        body_fields=("query", "fetch_size", "filter", "time_zone"),
+    )
+    def translate(
         self,
         *,
+        query: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fetch_size: t.Optional[int] = None,
+        filter: t.Optional[t.Mapping[str, t.Any]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        time_zone: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Halts all lifecycle management operations and stops the index lifecycle management
-        (ILM) plugin
+        Translates SQL into Elasticsearch queries
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/ilm-stop.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/sql-translate-api.html>`_
 
-        :param master_timeout:
-        :param timeout:
+        :param query: SQL query to run.
+        :param fetch_size: The maximum number of rows (or entries) to return in one response.
+        :param filter: Elasticsearch query DSL for additional filtering.
+        :param time_zone: ISO-8601 time zone ID for the search.
         """
-        __path = "/_ilm/stop"
+        if query is None and body is None:
+            raise ValueError("Empty value passed for parameter 'query'")
+        __path = "/_sql/translate"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        if not __body:
+            if query is not None:
+                __body["query"] = query
+            if fetch_size is not None:
+                __body["fetch_size"] = fetch_size
+            if filter is not None:
+                __body["filter"] = filter
+            if time_zone is not None:
+                __body["time_zone"] = time_zone
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/indices.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/indices.py`

 * *Files 6% similar despite different names*

```diff
@@ -20,43 +20,32 @@
 from elastic_transport import HeadApiResponse, ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class IndicesClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def add_block(
+    def add_block(
         self,
         *,
         index: str,
         block: t.Union["t.Literal['metadata', 'read', 'read_only', 'write']", str],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
@@ -99,50 +88,49 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analyzer",
+            "attributes",
+            "char_filter",
+            "explain",
+            "field",
+            "filter",
+            "normalizer",
+            "text",
+            "tokenizer",
+        ),
     )
-    async def analyze(
+    def analyze(
         self,
         *,
         index: t.Optional[str] = None,
         analyzer: t.Optional[str] = None,
-        attributes: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        char_filter: t.Optional[
-            t.Union[
-                t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-            ]
-        ] = None,
+        attributes: t.Optional[t.Sequence[str]] = None,
+        char_filter: t.Optional[t.Sequence[t.Union[str, t.Mapping[str, t.Any]]]] = None,
         error_trace: t.Optional[bool] = None,
         explain: t.Optional[bool] = None,
         field: t.Optional[str] = None,
-        filter: t.Optional[
-            t.Union[
-                t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-            ]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter: t.Optional[t.Sequence[t.Union[str, t.Mapping[str, t.Any]]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         normalizer: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
-        text: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        text: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         tokenizer: t.Optional[t.Union[str, t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Performs the analysis process on a text and return the tokens breakdown of the
         text.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html>`_
 
@@ -167,74 +155,74 @@
             as a multi-value field.
         :param tokenizer: Tokenizer to use to convert text into tokens.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_analyze"
         else:
             __path = "/_analyze"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analyzer is not None:
-            __body["analyzer"] = analyzer
-        if attributes is not None:
-            __body["attributes"] = attributes
-        if char_filter is not None:
-            __body["char_filter"] = char_filter
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if explain is not None:
-            __body["explain"] = explain
-        if field is not None:
-            __body["field"] = field
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if normalizer is not None:
-            __body["normalizer"] = normalizer
         if pretty is not None:
             __query["pretty"] = pretty
-        if text is not None:
-            __body["text"] = text
-        if tokenizer is not None:
-            __body["tokenizer"] = tokenizer
+        if not __body:
+            if analyzer is not None:
+                __body["analyzer"] = analyzer
+            if attributes is not None:
+                __body["attributes"] = attributes
+            if char_filter is not None:
+                __body["char_filter"] = char_filter
+            if explain is not None:
+                __body["explain"] = explain
+            if field is not None:
+                __body["field"] = field
+            if filter is not None:
+                __body["filter"] = filter
+            if normalizer is not None:
+                __body["normalizer"] = normalizer
+            if text is not None:
+                __body["text"] = text
+            if tokenizer is not None:
+                __body["tokenizer"] = tokenizer
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("aliases", "mappings", "settings"),
     )
-    async def create(
+    def create(
         self,
         *,
         index: str,
         aliases: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         mappings: t.Optional[t.Mapping[str, t.Any]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates an index with optional settings and mappings.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html>`_
 
         :param index: Name of the index you wish to create.
@@ -250,54 +238,53 @@
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to `all` or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aliases is not None:
-            __body["aliases"] = aliases
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if mappings is not None:
-            __body["mappings"] = mappings
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if settings is not None:
-            __body["settings"] = settings
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if not __body:
+            if aliases is not None:
+                __body["aliases"] = aliases
+            if mappings is not None:
+                __body["mappings"] = mappings
+            if settings is not None:
+                __body["settings"] = settings
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def create_data_stream(
+    def create_data_stream(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a data stream
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -317,45 +304,33 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def data_streams_stats(
+    def data_streams_stats(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Provides statistics on operations happening in a data stream.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -378,46 +353,34 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete(
+    def delete(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
@@ -465,28 +428,26 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete_alias(
+    def delete_alias(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -520,45 +481,33 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete_data_lifecycle(
+    def delete_data_lifecycle(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -589,45 +538,33 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete_data_stream(
+    def delete_data_stream(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a data stream.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -648,38 +585,36 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete_index_template(
+    def delete_index_template(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-template.html>`_
 
         :param name: Comma-separated list of index template names used to limit the request.
             Wildcard (*) expressions are supported.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
@@ -698,46 +633,34 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def exists(
+    def exists(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
@@ -783,47 +706,35 @@
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def exists_alias(
+    def exists_alias(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Union[str, t.Sequence[str]],
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a particular alias exists.
@@ -868,37 +779,35 @@
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def exists_index_template(
+    def exists_index_template(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a particular index template exists.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/index-templates.html>`_
 
         :param name: Comma-separated list of index template names used to limit the request.
             Wildcard (*) expressions are supported.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         """
@@ -913,27 +822,25 @@
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def explain_data_lifecycle(
+    def explain_data_lifecycle(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -961,60 +868,42 @@
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get(
+    def get(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         features: t.Optional[
             t.Union[
-                t.Union["t.Literal['aliases', 'mappings', 'settings']", str],
-                t.Union[
-                    t.List[
-                        t.Union["t.Literal['aliases', 'mappings', 'settings']", str]
-                    ],
-                    t.Tuple[
-                        t.Union["t.Literal['aliases', 'mappings', 'settings']", str],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['aliases', 'mappings', 'settings']", str]
                 ],
+                t.Union["t.Literal['aliases', 'mappings', 'settings']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
@@ -1074,47 +963,35 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_alias(
+    def get_alias(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns an alias.
@@ -1160,45 +1037,33 @@
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_data_lifecycle(
+    def get_data_lifecycle(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the data stream lifecycle of the selected data streams.
 
@@ -1225,45 +1090,33 @@
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_data_stream(
+    def get_data_stream(
         self,
         *,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns data streams.
 
@@ -1291,40 +1144,38 @@
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_index_template(
+    def get_index_template(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-template.html>`_
 
         :param name: Comma-separated list of index template names used to limit the request.
             Wildcard (*) expressions are supported.
         :param flat_settings: If true, returns settings in flat format.
         :param include_defaults: If true, returns all relevant default configurations
             for the index template.
         :param local: If true, the request retrieves information from the local node
@@ -1352,46 +1203,34 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_mapping(
+    def get_mapping(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
@@ -1439,47 +1278,35 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_settings(
+    def get_settings(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
@@ -1542,27 +1369,25 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def migrate_to_data_stream(
+    def migrate_to_data_stream(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Migrates an alias to a data stream
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -1578,84 +1403,87 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("actions",),
     )
-    async def modify_data_stream(
+    def modify_data_stream(
         self,
         *,
-        actions: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        actions: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Modifies a data stream
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
 
         :param actions: Actions to perform.
         """
-        if actions is None:
+        if actions is None and body is None:
             raise ValueError("Empty value passed for parameter 'actions'")
         __path = "/_data_stream/_modify"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if actions is not None:
-            __body["actions"] = actions
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if actions is not None:
+                __body["actions"] = actions
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "filter",
+            "index_routing",
+            "is_write_index",
+            "routing",
+            "search_routing",
+        ),
     )
-    async def put_alias(
+    def put_alias(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         name: str,
         error_trace: t.Optional[bool] = None,
         filter: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         index_routing: t.Optional[str] = None,
         is_write_index: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         search_routing: t.Optional[str] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates an alias.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html>`_
 
         :param index: Comma-separated list of data streams or indices to add. Supports
@@ -1686,85 +1514,75 @@
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/{_quote(index)}/_alias/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index_routing is not None:
-            __body["index_routing"] = index_routing
-        if is_write_index is not None:
-            __body["is_write_index"] = is_write_index
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if routing is not None:
-            __body["routing"] = routing
-        if search_routing is not None:
-            __body["search_routing"] = search_routing
         if timeout is not None:
             __query["timeout"] = timeout
         if not __body:
+            if filter is not None:
+                __body["filter"] = filter
+            if index_routing is not None:
+                __body["index_routing"] = index_routing
+            if is_write_index is not None:
+                __body["is_write_index"] = is_write_index
+            if routing is not None:
+                __body["routing"] = routing
+            if search_routing is not None:
+                __body["search_routing"] = search_routing
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("data_retention", "downsampling"),
     )
-    async def put_data_lifecycle(
+    def put_data_lifecycle(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         data_retention: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         downsampling: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates the data stream lifecycle of the selected data streams.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams-put-lifecycle.html>`_
 
         :param name: Comma-separated list of data streams used to limit the request.
@@ -1784,20 +1602,16 @@
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_data_stream/{_quote(name)}/_lifecycle"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if data_retention is not None:
-            __body["data_retention"] = data_retention
-        if downsampling is not None:
-            __body["downsampling"] = downsampling
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
@@ -1805,51 +1619,61 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         if not __body:
+            if data_retention is not None:
+                __body["data_retention"] = data_retention
+            if downsampling is not None:
+                __body["downsampling"] = downsampling
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "composed_of",
+            "data_stream",
+            "index_patterns",
+            "meta",
+            "priority",
+            "template",
+            "version",
+        ),
         parameter_aliases={"_meta": "meta"},
     )
-    async def put_index_template(
+    def put_index_template(
         self,
         *,
         name: str,
-        composed_of: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        composed_of: t.Optional[t.Sequence[str]] = None,
         create: t.Optional[bool] = None,
         data_stream: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        index_patterns: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        index_patterns: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         priority: t.Optional[int] = None,
         template: t.Optional[t.Mapping[str, t.Any]] = None,
         version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-template.html>`_
 
         :param name: Index or template name
         :param composed_of: An ordered list of component template names. Component templates
             are merged in the order specified, meaning that the last component template
             specified has the highest precedence.
         :param create: If `true`, this request cannot replace or update existing index
             templates.
@@ -1868,112 +1692,109 @@
             `mappings`, or `settings` configuration.
         :param version: Version number used to manage index templates externally. This
             number is not automatically generated by Elasticsearch.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_index_template/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if composed_of is not None:
-            __body["composed_of"] = composed_of
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
-        if data_stream is not None:
-            __body["data_stream"] = data_stream
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index_patterns is not None:
-            __body["index_patterns"] = index_patterns
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if priority is not None:
-            __body["priority"] = priority
-        if template is not None:
-            __body["template"] = template
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if composed_of is not None:
+                __body["composed_of"] = composed_of
+            if data_stream is not None:
+                __body["data_stream"] = data_stream
+            if index_patterns is not None:
+                __body["index_patterns"] = index_patterns
+            if meta is not None:
+                __body["_meta"] = meta
+            if priority is not None:
+                __body["priority"] = priority
+            if template is not None:
+                __body["template"] = template
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "date_detection",
+            "dynamic",
+            "dynamic_date_formats",
+            "dynamic_templates",
+            "field_names",
+            "meta",
+            "numeric_detection",
+            "properties",
+            "routing",
+            "runtime",
+            "source",
+        ),
         parameter_aliases={
             "_field_names": "field_names",
             "_meta": "meta",
             "_routing": "routing",
             "_source": "source",
         },
     )
-    async def put_mapping(
+    def put_mapping(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         date_detection: t.Optional[bool] = None,
         dynamic: t.Optional[
             t.Union["t.Literal['false', 'runtime', 'strict', 'true']", str]
         ] = None,
-        dynamic_date_formats: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
+        dynamic_date_formats: t.Optional[t.Sequence[str]] = None,
         dynamic_templates: t.Optional[
             t.Union[
                 t.Mapping[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Mapping[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Mapping[str, t.Mapping[str, t.Any]], ...],
-                ],
+                t.Sequence[t.Mapping[str, t.Mapping[str, t.Any]]],
             ]
         ] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         field_names: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         numeric_detection: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         properties: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         routing: t.Optional[t.Mapping[str, t.Any]] = None,
         runtime: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         source: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         write_index_only: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates the index mappings.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html>`_
 
         :param index: A comma-separated list of index names the mapping should be added
@@ -2012,93 +1833,83 @@
         :param write_index_only: If `true`, the mappings are applied only to the current
             write index for the target.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_mapping"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if date_detection is not None:
-            __body["date_detection"] = date_detection
-        if dynamic is not None:
-            __body["dynamic"] = dynamic
-        if dynamic_date_formats is not None:
-            __body["dynamic_date_formats"] = dynamic_date_formats
-        if dynamic_templates is not None:
-            __body["dynamic_templates"] = dynamic_templates
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if field_names is not None:
-            __body["_field_names"] = field_names
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
-        if numeric_detection is not None:
-            __body["numeric_detection"] = numeric_detection
         if pretty is not None:
             __query["pretty"] = pretty
-        if properties is not None:
-            __body["properties"] = properties
-        if routing is not None:
-            __body["_routing"] = routing
-        if runtime is not None:
-            __body["runtime"] = runtime
-        if source is not None:
-            __body["_source"] = source
         if timeout is not None:
             __query["timeout"] = timeout
         if write_index_only is not None:
             __query["write_index_only"] = write_index_only
+        if not __body:
+            if date_detection is not None:
+                __body["date_detection"] = date_detection
+            if dynamic is not None:
+                __body["dynamic"] = dynamic
+            if dynamic_date_formats is not None:
+                __body["dynamic_date_formats"] = dynamic_date_formats
+            if dynamic_templates is not None:
+                __body["dynamic_templates"] = dynamic_templates
+            if field_names is not None:
+                __body["_field_names"] = field_names
+            if meta is not None:
+                __body["_meta"] = meta
+            if numeric_detection is not None:
+                __body["numeric_detection"] = numeric_detection
+            if properties is not None:
+                __body["properties"] = properties
+            if routing is not None:
+                __body["_routing"] = routing
+            if runtime is not None:
+                __body["runtime"] = runtime
+            if source is not None:
+                __body["_source"] = source
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="settings",
     )
-    async def put_settings(
+    def put_settings(
         self,
         *,
-        settings: t.Mapping[str, t.Any],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        settings: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         preserve_existing: t.Optional[bool] = None,
@@ -2128,16 +1939,20 @@
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param preserve_existing: If `true`, existing index settings remain unchanged.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
-        if settings is None:
-            raise ValueError("Empty value passed for parameter 'settings'")
+        if settings is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'settings' and 'body', one of them should be set."
+            )
+        elif settings is not None and body is not None:
+            raise ValueError("Cannot set both 'settings' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_settings"
         else:
             __path = "/_settings"
         __query: t.Dict[str, t.Any] = {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
@@ -2157,52 +1972,56 @@
             __query["master_timeout"] = master_timeout
         if preserve_existing is not None:
             __query["preserve_existing"] = preserve_existing
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
-        __body = settings
+        __body = settings if settings is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aliases",
+            "index_patterns",
+            "mappings",
+            "order",
+            "settings",
+            "version",
+        ),
     )
-    async def put_template(
+    def put_template(
         self,
         *,
         name: str,
         aliases: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         create: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        index_patterns: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        index_patterns: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         mappings: t.Optional[t.Mapping[str, t.Any]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         order: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates-v1.html>`_
 
         :param name: The name of the template
         :param aliases: Aliases for the index.
         :param create: If true, this request cannot replace or update existing index
             templates.
         :param flat_settings: If `true`, returns settings in flat format.
         :param index_patterns: Array of wildcard expressions used to match the names
@@ -2220,77 +2039,66 @@
             the timeout expires, the request fails and returns an error.
         :param version: Version number used to manage index templates externally. This
             number is not automatically generated by Elasticsearch.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_template/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aliases is not None:
-            __body["aliases"] = aliases
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if flat_settings is not None:
             __query["flat_settings"] = flat_settings
         if human is not None:
             __query["human"] = human
-        if index_patterns is not None:
-            __body["index_patterns"] = index_patterns
-        if mappings is not None:
-            __body["mappings"] = mappings
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if order is not None:
-            __body["order"] = order
         if pretty is not None:
             __query["pretty"] = pretty
-        if settings is not None:
-            __body["settings"] = settings
         if timeout is not None:
             __query["timeout"] = timeout
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if aliases is not None:
+                __body["aliases"] = aliases
+            if index_patterns is not None:
+                __body["index_patterns"] = index_patterns
+            if mappings is not None:
+                __body["mappings"] = mappings
+            if order is not None:
+                __body["order"] = order
+            if settings is not None:
+                __body["settings"] = settings
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def refresh(
+    def refresh(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Performs the refresh operation in one or more indices.
 
@@ -2325,45 +2133,33 @@
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def resolve_index(
+    def resolve_index(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns information about any matching indices, aliases, and data streams
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-resolve-index-api.html>`_
@@ -2387,44 +2183,43 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("aliases", "conditions", "mappings", "settings"),
     )
-    async def rollover(
+    def rollover(
         self,
         *,
         alias: str,
         new_index: t.Optional[str] = None,
         aliases: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         conditions: t.Optional[t.Mapping[str, t.Any]] = None,
         dry_run: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         mappings: t.Optional[t.Mapping[str, t.Any]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates an alias to point to a new index when the existing index is considered
         to be too large or too old.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html>`_
 
@@ -2458,329 +2253,315 @@
             raise ValueError("Empty value passed for parameter 'alias'")
         if alias not in SKIP_IN_PATH and new_index not in SKIP_IN_PATH:
             __path = f"/{_quote(alias)}/_rollover/{_quote(new_index)}"
         elif alias not in SKIP_IN_PATH:
             __path = f"/{_quote(alias)}/_rollover"
         else:
             raise ValueError("Couldn't find a path for the given parameters")
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aliases is not None:
-            __body["aliases"] = aliases
-        if conditions is not None:
-            __body["conditions"] = conditions
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if dry_run is not None:
             __query["dry_run"] = dry_run
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if mappings is not None:
-            __body["mappings"] = mappings
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if settings is not None:
-            __body["settings"] = settings
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if not __body:
+            if aliases is not None:
+                __body["aliases"] = aliases
+            if conditions is not None:
+                __body["conditions"] = conditions
+            if mappings is not None:
+                __body["mappings"] = mappings
+            if settings is not None:
+                __body["settings"] = settings
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters(
-        body_fields=True,
-        parameter_aliases={"_meta": "meta"},
-    )
-    async def simulate_index_template(
+    @_rewrite_parameters()
+    def simulate_index_template(
         self,
         *,
         name: str,
-        allow_auto_create: t.Optional[bool] = None,
-        composed_of: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        create: t.Optional[bool] = None,
-        data_stream: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
-        index_patterns: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        priority: t.Optional[int] = None,
-        template: t.Optional[t.Mapping[str, t.Any]] = None,
-        version: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Simulate matching the given index name against the index templates in the system
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-simulate-index.html>`_
 
-        :param name: Index or template name to simulate
-        :param allow_auto_create: This setting overrides the value of the `action.auto_create_index`
-            cluster setting. If set to `true` in a template, then indices can be automatically
-            created using that template even if auto-creation of indices is disabled
-            via `actions.auto_create_index`. If set to `false`, then indices or data
-            streams matching the template must always be explicitly created, and may
-            never be automatically created.
-        :param composed_of: An ordered list of component template names. Component templates
-            are merged in the order specified, meaning that the last component template
-            specified has the highest precedence.
-        :param create: If `true`, the template passed in the body is only used if no
-            existing templates match the same index patterns. If `false`, the simulation
-            uses the template with the highest priority. Note that the template is not
-            permanently added or updated in either case; it is only used for the simulation.
-        :param data_stream: If this object is included, the template is used to create
-            data streams and their backing indices. Supports an empty object. Data streams
-            require a matching index template with a `data_stream` object.
+        :param name: Name of the index to simulate
         :param include_defaults: If true, returns all relevant default configurations
             for the index template.
-        :param index_patterns: Array of wildcard (`*`) expressions used to match the
-            names of data streams and indices during creation.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
-        :param meta: Optional user metadata about the index template. May have any contents.
-            This map is not automatically generated by Elasticsearch.
-        :param priority: Priority to determine index template precedence when a new data
-            stream or index is created. The index template with the highest priority
-            is chosen. If no priority is specified the template is treated as though
-            it is of priority 0 (lowest priority). This number is not automatically generated
-            by Elasticsearch.
-        :param template: Template to be applied. It may optionally include an `aliases`,
-            `mappings`, or `settings` configuration.
-        :param version: Version number used to manage index templates externally. This
-            number is not automatically generated by Elasticsearch.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_index_template/_simulate_index/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_auto_create is not None:
-            __body["allow_auto_create"] = allow_auto_create
-        if composed_of is not None:
-            __body["composed_of"] = composed_of
-        if create is not None:
-            __query["create"] = create
-        if data_stream is not None:
-            __body["data_stream"] = data_stream
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
-        if index_patterns is not None:
-            __body["index_patterns"] = index_patterns
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if priority is not None:
-            __body["priority"] = priority
-        if template is not None:
-            __body["template"] = template
-        if version is not None:
-            __body["version"] = version
-        if not __body:
-            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_name="template",
+        body_fields=(
+            "allow_auto_create",
+            "composed_of",
+            "data_stream",
+            "ignore_missing_component_templates",
+            "index_patterns",
+            "meta",
+            "priority",
+            "template",
+            "version",
+        ),
+        parameter_aliases={"_meta": "meta"},
     )
-    async def simulate_template(
+    def simulate_template(
         self,
         *,
         name: t.Optional[str] = None,
+        allow_auto_create: t.Optional[bool] = None,
+        composed_of: t.Optional[t.Sequence[str]] = None,
         create: t.Optional[bool] = None,
+        data_stream: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        ignore_missing_component_templates: t.Optional[t.Sequence[str]] = None,
         include_defaults: t.Optional[bool] = None,
+        index_patterns: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        priority: t.Optional[int] = None,
         template: t.Optional[t.Mapping[str, t.Any]] = None,
+        version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Simulate resolving the given template name or body
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-simulate-template.html>`_
 
         :param name: Name of the index template to simulate. To test a template configuration
             before you add it to the cluster, omit this parameter and specify the template
             configuration in the request body.
+        :param allow_auto_create: This setting overrides the value of the `action.auto_create_index`
+            cluster setting. If set to `true` in a template, then indices can be automatically
+            created using that template even if auto-creation of indices is disabled
+            via `actions.auto_create_index`. If set to `false`, then indices or data
+            streams matching the template must always be explicitly created, and may
+            never be automatically created.
+        :param composed_of: An ordered list of component template names. Component templates
+            are merged in the order specified, meaning that the last component template
+            specified has the highest precedence.
         :param create: If true, the template passed in the body is only used if no existing
             templates match the same index patterns. If false, the simulation uses the
             template with the highest priority. Note that the template is not permanently
             added or updated in either case; it is only used for the simulation.
+        :param data_stream: If this object is included, the template is used to create
+            data streams and their backing indices. Supports an empty object. Data streams
+            require a matching index template with a `data_stream` object.
+        :param ignore_missing_component_templates: The configuration option ignore_missing_component_templates
+            can be used when an index template references a component template that might
+            not exist
         :param include_defaults: If true, returns all relevant default configurations
             for the index template.
+        :param index_patterns: Array of wildcard (`*`) expressions used to match the
+            names of data streams and indices during creation.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
-        :param template:
+        :param meta: Optional user metadata about the index template. May have any contents.
+            This map is not automatically generated by Elasticsearch.
+        :param priority: Priority to determine index template precedence when a new data
+            stream or index is created. The index template with the highest priority
+            is chosen. If no priority is specified the template is treated as though
+            it is of priority 0 (lowest priority). This number is not automatically generated
+            by Elasticsearch.
+        :param template: Template to be applied. It may optionally include an `aliases`,
+            `mappings`, or `settings` configuration.
+        :param version: Version number used to manage index templates externally. This
+            number is not automatically generated by Elasticsearch.
         """
         if name not in SKIP_IN_PATH:
             __path = f"/_index_template/_simulate/{_quote(name)}"
         else:
             __path = "/_index_template/_simulate"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = template
         if not __body:
-            __body = None
+            if allow_auto_create is not None:
+                __body["allow_auto_create"] = allow_auto_create
+            if composed_of is not None:
+                __body["composed_of"] = composed_of
+            if data_stream is not None:
+                __body["data_stream"] = data_stream
+            if ignore_missing_component_templates is not None:
+                __body["ignore_missing_component_templates"] = (
+                    ignore_missing_component_templates
+                )
+            if index_patterns is not None:
+                __body["index_patterns"] = index_patterns
+            if meta is not None:
+                __body["_meta"] = meta
+            if priority is not None:
+                __body["priority"] = priority
+            if template is not None:
+                __body["template"] = template
+            if version is not None:
+                __body["version"] = version
+        if not __body:
+            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("actions",),
     )
-    async def update_aliases(
+    def update_aliases(
         self,
         *,
-        actions: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        actions: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates index aliases.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html>`_
 
         :param actions: Actions to perform.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         __path = "/_aliases"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if actions is not None:
-            __body["actions"] = actions
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if actions is not None:
+                __body["actions"] = actions
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("query",),
     )
-    async def validate_query(
+    def validate_query(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         all_shards: t.Optional[bool] = None,
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         rewrite: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows a user to validate a potentially expensive query without executing it.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -2815,15 +2596,15 @@
             Lucene query that will be executed.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_validate/query"
         else:
             __path = "/_validate/query"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if all_shards is not None:
             __query["all_shards"] = all_shards
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
@@ -2846,19 +2627,20 @@
             __query["ignore_unavailable"] = ignore_unavailable
         if lenient is not None:
             __query["lenient"] = lenient
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if rewrite is not None:
             __query["rewrite"] = rewrite
         if not __body:
+            if query is not None:
+                __body["query"] = query
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ingest.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/ingest.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class IngestClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def delete_pipeline(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -76,17 +75,15 @@
 
     @_rewrite_parameters()
     async def get_pipeline(
         self,
         *,
         id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         summary: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -125,17 +122,15 @@
         )
 
     @_rewrite_parameters()
     async def processor_grok(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns a list of the built-in patterns.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/grok-processor.html>`_
@@ -152,41 +147,36 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("description", "meta", "on_failure", "processors", "version"),
         parameter_aliases={"_meta": "meta"},
     )
     async def put_pipeline(
         self,
         *,
         id: str,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_version: t.Optional[int] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
-        on_failure: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        on_failure: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         pretty: t.Optional[bool] = None,
-        processors: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        processors: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a pipeline.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ingest.html>`_
 
         :param id: ID of the ingest pipeline to create or update.
@@ -211,63 +201,61 @@
         :param version: Version number used by external systems to track ingest pipelines.
             This parameter is intended for external systems only. Elasticsearch does
             not use or validate pipeline version numbers.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/_ingest/pipeline/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if if_version is not None:
             __query["if_version"] = if_version
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
-        if on_failure is not None:
-            __body["on_failure"] = on_failure
         if pretty is not None:
             __query["pretty"] = pretty
-        if processors is not None:
-            __body["processors"] = processors
         if timeout is not None:
             __query["timeout"] = timeout
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if meta is not None:
+                __body["_meta"] = meta
+            if on_failure is not None:
+                __body["on_failure"] = on_failure
+            if processors is not None:
+                __body["processors"] = processors
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "pipeline"),
     )
     async def simulate(
         self,
         *,
         id: t.Optional[str] = None,
-        docs: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pipeline: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         verbose: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to simulate a pipeline with example documents.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html>`_
 
         :param id: Pipeline to test. If you don’t specify a `pipeline` in the request
@@ -279,27 +267,28 @@
         :param verbose: If `true`, the response includes output data for each processor
             in the executed pipeline.
         """
         if id not in SKIP_IN_PATH:
             __path = f"/_ingest/pipeline/{_quote(id)}/_simulate"
         else:
             __path = "/_ingest/pipeline/_simulate"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if pipeline is not None:
-            __body["pipeline"] = pipeline
         if pretty is not None:
             __query["pretty"] = pretty
         if verbose is not None:
             __query["verbose"] = verbose
+        if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if pipeline is not None:
+                __body["pipeline"] = pipeline
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/license.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/license.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import _rewrite_parameters
 
 
 class LicenseClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def get(
+    def get(
         self,
         *,
         accept_enterprise: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves licensing information for the cluster
 
@@ -60,10 +59,10 @@
         if human is not None:
             __query["human"] = human
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/logstash.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/logstash.py`

 * *Files 6% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class LogstashClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def delete_pipeline(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes Logstash Pipelines used by Central Management
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/logstash-api-delete-pipeline.html>`_
@@ -60,31 +59,27 @@
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def get_pipeline(
         self,
         *,
-        id: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves Logstash Pipelines used by Central Management
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/logstash-api-get-pipeline.html>`_
 
         :param id: Comma-separated list of pipeline identifiers.
         """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
         if id not in SKIP_IN_PATH:
             __path = f"/_logstash/pipeline/{_quote(id)}"
         else:
             __path = "/_logstash/pipeline"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
@@ -102,42 +97,45 @@
     @_rewrite_parameters(
         body_name="pipeline",
     )
     async def put_pipeline(
         self,
         *,
         id: str,
-        pipeline: t.Mapping[str, t.Any],
+        pipeline: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Adds and updates Logstash Pipelines used for Central Management
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/logstash-api-put-pipeline.html>`_
 
         :param id: Identifier for the pipeline.
         :param pipeline:
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if pipeline is None:
-            raise ValueError("Empty value passed for parameter 'pipeline'")
+        if pipeline is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'pipeline' and 'body', one of them should be set."
+            )
+        elif pipeline is not None and body is not None:
+            raise ValueError("Cannot set both 'pipeline' and 'body'")
         __path = f"/_logstash/pipeline/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = pipeline
+        __body = pipeline if pipeline is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/migration.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/graph.py`

 * *Files 18% similar despite different names*

```diff
@@ -19,109 +19,81 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class MigrationClient(NamespacedClient):
-    @_rewrite_parameters()
-    async def deprecations(
-        self,
-        *,
-        index: t.Optional[str] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Retrieves information about different cluster, node, and index level settings
-        that use deprecated features that will be removed or changed in the next major
-        version.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/migration-api-deprecation.html>`_
-
-        :param index: Comma-separate list of data streams or indices to check. Wildcard
-            (*) expressions are supported.
-        """
-        if index not in SKIP_IN_PATH:
-            __path = f"/{_quote(index)}/_migration/deprecations"
-        else:
-            __path = "/_migration/deprecations"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
+class GraphClient(NamespacedClient):
 
-    @_rewrite_parameters()
-    async def get_feature_upgrade_status(
+    @_rewrite_parameters(
+        body_fields=("connections", "controls", "query", "vertices"),
+    )
+    async def explore(
         self,
         *,
+        index: t.Union[str, t.Sequence[str]],
+        connections: t.Optional[t.Mapping[str, t.Any]] = None,
+        controls: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        query: t.Optional[t.Mapping[str, t.Any]] = None,
+        routing: t.Optional[str] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        vertices: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Find out whether system features need to be upgraded or not
+        Explore extracted and summarized information about the documents and terms in
+        an index.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/migration-api-feature-upgrade.html>`_
-        """
-        __path = "/_migration/system_features"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/graph-explore-api.html>`_
 
-    @_rewrite_parameters()
-    async def post_feature_upgrade(
-        self,
-        *,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Begin upgrades for system features
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/migration-api-feature-upgrade.html>`_
-        """
-        __path = "/_migration/system_features"
+        :param index: Name of the index.
+        :param connections: Specifies or more fields from which you want to extract terms
+            that are associated with the specified vertices.
+        :param controls: Direct the Graph API how to build the graph.
+        :param query: A seed query that identifies the documents of interest. Can be
+            any valid Elasticsearch query.
+        :param routing: Custom value used to route operations to a specific shard.
+        :param timeout: Specifies the period of time to wait for a response from each
+            shard. If no response is received before the timeout expires, the request
+            fails and returns an error. Defaults to no timeout.
+        :param vertices: Specifies one or more fields that contain the terms you want
+            to include in the graph as vertices.
+        """
+        if index in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'index'")
+        __path = f"/{_quote(index)}/_graph/explore"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if routing is not None:
+            __query["routing"] = routing
+        if timeout is not None:
+            __query["timeout"] = timeout
+        if not __body:
+            if connections is not None:
+                __body["connections"] = connections
+            if controls is not None:
+                __body["controls"] = controls
+            if query is not None:
+                __body["query"] = query
+            if vertices is not None:
+                __body["vertices"] = vertices
+        if not __body:
+            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
+        if __body is not None:
+            __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ml.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/ml.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,30 +20,30 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class MlClient(NamespacedClient):
+
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("allow_no_match", "force", "timeout"),
     )
     async def close_job(
         self,
         *,
         job_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Closes one or more anomaly detection jobs. A job can be opened and closed multiple
         times throughout its lifecycle.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-close-job.html>`_
 
@@ -56,30 +56,31 @@
             parameter.
         :param force: Refer to the descriptiion for the `force` query parameter.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_close"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_match is not None:
-            __body["allow_no_match"] = allow_no_match
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if force is not None:
-            __body["force"] = force
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if allow_no_match is not None:
+                __body["allow_no_match"] = allow_no_match
+            if force is not None:
+                __body["force"] = force
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -87,17 +88,15 @@
 
     @_rewrite_parameters()
     async def delete_calendar(
         self,
         *,
         calendar_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-calendar.html>`_
@@ -124,17 +123,15 @@
     @_rewrite_parameters()
     async def delete_calendar_event(
         self,
         *,
         calendar_id: str,
         event_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes scheduled events from a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-calendar-event.html>`_
@@ -163,19 +160,17 @@
         )
 
     @_rewrite_parameters()
     async def delete_calendar_job(
         self,
         *,
         calendar_id: str,
-        job_id: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        job_id: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes anomaly detection jobs from a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-calendar-job.html>`_
@@ -205,17 +200,15 @@
 
     @_rewrite_parameters()
     async def delete_data_frame_analytics(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing data frame analytics job.
@@ -250,17 +243,15 @@
 
     @_rewrite_parameters()
     async def delete_datafeed(
         self,
         *,
         datafeed_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing datafeed.
 
@@ -294,17 +285,15 @@
 
     @_rewrite_parameters()
     async def delete_filter(
         self,
         *,
         filter_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a filter.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-filter.html>`_
@@ -331,17 +320,15 @@
     @_rewrite_parameters()
     async def delete_job(
         self,
         *,
         job_id: str,
         delete_user_annotations: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing anomaly detection job.
@@ -382,17 +369,15 @@
 
     @_rewrite_parameters()
     async def delete_trained_model(
         self,
         *,
         model_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing trained inference model that is currently not referenced
         by an ingest pipeline.
@@ -425,17 +410,15 @@
     @_rewrite_parameters()
     async def delete_trained_model_alias(
         self,
         *,
         model_id: str,
         model_alias: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a model alias that refers to the trained model
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-trained-models-aliases.html>`_
@@ -459,28 +442,31 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analysis_config",
+            "max_bucket_cardinality",
+            "overall_cardinality",
+        ),
     )
     async def estimate_model_memory(
         self,
         *,
         analysis_config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_bucket_cardinality: t.Optional[t.Mapping[str, int]] = None,
         overall_cardinality: t.Optional[t.Mapping[str, int]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Estimates the model memory
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-apis.html>`_
 
         :param analysis_config: For a list of the properties that you can specify in
@@ -495,105 +481,105 @@
             a good answer, values must be provided for fields referenced in the `by_field_name`,
             `over_field_name` and `partition_field_name` of any detectors. Providing
             values for other fields has no effect on the estimation. It can be omitted
             from the request if no detectors have a `by_field_name`, `over_field_name`
             or `partition_field_name`.
         """
         __path = "/_ml/anomaly_detectors/_estimate_model_memory"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analysis_config is not None:
-            __body["analysis_config"] = analysis_config
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if max_bucket_cardinality is not None:
-            __body["max_bucket_cardinality"] = max_bucket_cardinality
-        if overall_cardinality is not None:
-            __body["overall_cardinality"] = overall_cardinality
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if analysis_config is not None:
+                __body["analysis_config"] = analysis_config
+            if max_bucket_cardinality is not None:
+                __body["max_bucket_cardinality"] = max_bucket_cardinality
+            if overall_cardinality is not None:
+                __body["overall_cardinality"] = overall_cardinality
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("evaluation", "index", "query"),
     )
     async def evaluate_data_frame(
         self,
         *,
-        evaluation: t.Mapping[str, t.Any],
-        index: str,
+        evaluation: t.Optional[t.Mapping[str, t.Any]] = None,
+        index: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Evaluates the data frame analytics for an annotated index.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/evaluate-dfanalytics.html>`_
 
         :param evaluation: Defines the type of evaluation you want to perform.
         :param index: Defines the `index` in which the evaluation will be performed.
         :param query: A query clause that retrieves a subset of data from the source
             index.
         """
-        if evaluation is None:
+        if evaluation is None and body is None:
             raise ValueError("Empty value passed for parameter 'evaluation'")
-        if index is None:
+        if index is None and body is None:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = "/_ml/data_frame/_evaluate"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if evaluation is not None:
-            __body["evaluation"] = evaluation
-        if index is not None:
-            __body["index"] = index
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
+        if not __body:
+            if evaluation is not None:
+                __body["evaluation"] = evaluation
+            if index is not None:
+                __body["index"] = index
+            if query is not None:
+                __body["query"] = query
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("advance_time", "calc_interim", "end", "skip_time", "start"),
     )
     async def flush_job(
         self,
         *,
         job_id: str,
         advance_time: t.Optional[t.Union[str, t.Any]] = None,
         calc_interim: t.Optional[bool] = None,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         skip_time: t.Optional[t.Union[str, t.Any]] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Forces any buffered data to be processed by the job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-flush-job.html>`_
 
         :param job_id: Identifier for the anomaly detection job.
@@ -602,34 +588,35 @@
         :param end: Refer to the description for the `end` query parameter.
         :param skip_time: Refer to the description for the `skip_time` query parameter.
         :param start: Refer to the description for the `start` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_flush"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if advance_time is not None:
-            __body["advance_time"] = advance_time
-        if calc_interim is not None:
-            __body["calc_interim"] = calc_interim
-        if end is not None:
-            __body["end"] = end
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if skip_time is not None:
-            __body["skip_time"] = skip_time
-        if start is not None:
-            __body["start"] = start
+        if not __body:
+            if advance_time is not None:
+                __body["advance_time"] = advance_time
+            if calc_interim is not None:
+                __body["calc_interim"] = calc_interim
+            if end is not None:
+                __body["end"] = end
+            if skip_time is not None:
+                __body["skip_time"] = skip_time
+            if start is not None:
+                __body["start"] = start
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -640,17 +627,15 @@
     )
     async def get_calendar_events(
         self,
         *,
         calendar_id: str,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         job_id: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -694,30 +679,29 @@
             __query["start"] = start
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("page",),
         parameter_aliases={"from": "from_"},
     )
     async def get_calendars(
         self,
         *,
         calendar_id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         page: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for calendars.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-calendar.html>`_
 
         :param calendar_id: A string that uniquely identifies a calendar. You can get
@@ -731,30 +715,31 @@
             is supported only when you omit the calendar identifier.
         """
         if calendar_id not in SKIP_IN_PATH:
             __path = f"/_ml/calendars/{_quote(calendar_id)}"
         else:
             __path = "/_ml/calendars"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if from_ is not None:
             __query["from"] = from_
         if human is not None:
             __query["human"] = human
-        if page is not None:
-            __body["page"] = page
         if pretty is not None:
             __query["pretty"] = pretty
         if size is not None:
             __query["size"] = size
         if not __body:
+            if page is not None:
+                __body["page"] = page
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
@@ -765,17 +750,15 @@
     async def get_data_frame_analytics(
         self,
         *,
         id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for data frame analytics jobs.
@@ -830,17 +813,15 @@
     )
     async def get_data_frame_analytics_stats(
         self,
         *,
         id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         verbose: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -889,22 +870,18 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def get_datafeed_stats(
         self,
         *,
-        datafeed_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        datafeed_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves usage information for datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-datafeed-stats.html>`_
@@ -940,23 +917,19 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def get_datafeeds(
         self,
         *,
-        datafeed_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        datafeed_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-datafeed.html>`_
@@ -999,21 +972,17 @@
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     async def get_filters(
         self,
         *,
-        filter_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves filters.
@@ -1049,17 +1018,15 @@
     @_rewrite_parameters()
     async def get_job_stats(
         self,
         *,
         job_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves usage information for anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-job-stats.html>`_
@@ -1096,23 +1063,19 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def get_jobs(
         self,
         *,
-        job_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        job_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-job.html>`_
@@ -1150,33 +1113,40 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "allow_no_match",
+            "bucket_span",
+            "end",
+            "exclude_interim",
+            "overall_score",
+            "start",
+            "top_n",
+        ),
     )
     async def get_overall_buckets(
         self,
         *,
         job_id: str,
         allow_no_match: t.Optional[bool] = None,
         bucket_span: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         exclude_interim: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         overall_score: t.Optional[t.Union[float, str]] = None,
         pretty: t.Optional[bool] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
         top_n: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves overall bucket results that summarize the bucket results of multiple
         anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-overall-buckets.html>`_
 
@@ -1194,38 +1164,39 @@
             parameter.
         :param start: Refer to the description for the `start` query parameter.
         :param top_n: Refer to the description for the `top_n` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/results/overall_buckets"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_match is not None:
-            __body["allow_no_match"] = allow_no_match
-        if bucket_span is not None:
-            __body["bucket_span"] = bucket_span
-        if end is not None:
-            __body["end"] = end
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if exclude_interim is not None:
-            __body["exclude_interim"] = exclude_interim
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if overall_score is not None:
-            __body["overall_score"] = overall_score
         if pretty is not None:
             __query["pretty"] = pretty
-        if start is not None:
-            __body["start"] = start
-        if top_n is not None:
-            __body["top_n"] = top_n
+        if not __body:
+            if allow_no_match is not None:
+                __body["allow_no_match"] = allow_no_match
+            if bucket_span is not None:
+                __body["bucket_span"] = bucket_span
+            if end is not None:
+                __body["end"] = end
+            if exclude_interim is not None:
+                __body["exclude_interim"] = exclude_interim
+            if overall_score is not None:
+                __body["overall_score"] = overall_score
+            if start is not None:
+                __body["start"] = start
+            if top_n is not None:
+                __body["top_n"] = top_n
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -1238,17 +1209,15 @@
         self,
         *,
         model_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         decompress_definition: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         include: t.Optional[
             t.Union[
                 "t.Literal['definition', 'definition_status', 'feature_importance_baseline', 'hyperparameters', 'total_feature_importance']",
                 str,
             ]
@@ -1316,22 +1285,18 @@
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     async def get_trained_models_stats(
         self,
         *,
-        model_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        model_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves usage information for trained inference models.
@@ -1369,31 +1334,28 @@
             __query["size"] = size
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "inference_config"),
     )
     async def infer_trained_model(
         self,
         *,
         model_id: str,
-        docs: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         inference_config: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Evaluate a trained model.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/infer-trained-model.html>`_
 
         :param model_id: The unique identifier of the trained model.
@@ -1403,148 +1365,146 @@
             only a single value is allowed.
         :param inference_config: The inference configuration updates to apply on the
             API call
         :param timeout: Controls the amount of time to wait for inference results.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
-        if docs is None:
+        if docs is None and body is None:
             raise ValueError("Empty value passed for parameter 'docs'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/_infer"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if inference_config is not None:
-            __body["inference_config"] = inference_config
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if inference_config is not None:
+                __body["inference_config"] = inference_config
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("timeout",),
     )
     async def open_job(
         self,
         *,
         job_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Opens one or more anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-open-job.html>`_
 
         :param job_id: Identifier for the anomaly detection job.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_open"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("events",),
     )
     async def post_calendar_events(
         self,
         *,
         calendar_id: str,
-        events: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        events: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Posts scheduled events in a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-post-calendar-event.html>`_
 
         :param calendar_id: A string that uniquely identifies a calendar.
         :param events: A list of one of more scheduled events. The event’s start and
             end times can be specified as integer milliseconds since the epoch or as
             a string in ISO 8601 format.
         """
         if calendar_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'calendar_id'")
-        if events is None:
+        if events is None and body is None:
             raise ValueError("Empty value passed for parameter 'events'")
         __path = f"/_ml/calendars/{_quote(calendar_id)}/events"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if events is not None:
-            __body["events"] = events
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if events is not None:
+                __body["events"] = events
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("config",),
     )
     async def preview_data_frame_analytics(
         self,
         *,
         id: t.Optional[str] = None,
         config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Previews that will be analyzed given a data frame analytics config.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/preview-dfanalytics.html>`_
 
         :param id: Identifier for the data frame analytics job.
@@ -1552,52 +1512,52 @@
             analytics jobs. Note that `id` and `dest` don’t need to be provided in the
             context of this API.
         """
         if id not in SKIP_IN_PATH:
             __path = f"/_ml/data_frame/analytics/{_quote(id)}/_preview"
         else:
             __path = "/_ml/data_frame/analytics/_preview"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if config is not None:
-            __body["config"] = config
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if config is not None:
+                __body["config"] = config
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("datafeed_config", "job_config"),
     )
     async def preview_datafeed(
         self,
         *,
         datafeed_id: t.Optional[str] = None,
         datafeed_config: t.Optional[t.Mapping[str, t.Any]] = None,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         job_config: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Previews a datafeed.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-preview-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -1615,84 +1575,85 @@
             object unless you also supply a `datafeed_config` object.
         :param start: The start time from where the datafeed preview should begin
         """
         if datafeed_id not in SKIP_IN_PATH:
             __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_preview"
         else:
             __path = "/_ml/datafeeds/_preview"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if datafeed_config is not None:
-            __body["datafeed_config"] = datafeed_config
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if end is not None:
             __query["end"] = end
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if job_config is not None:
-            __body["job_config"] = job_config
         if pretty is not None:
             __query["pretty"] = pretty
         if start is not None:
             __query["start"] = start
         if not __body:
+            if datafeed_config is not None:
+                __body["datafeed_config"] = datafeed_config
+            if job_config is not None:
+                __body["job_config"] = job_config
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("description", "job_ids"),
     )
     async def put_calendar(
         self,
         *,
         calendar_id: str,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        job_ids: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        job_ids: t.Optional[t.Sequence[str]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-calendar.html>`_
 
         :param calendar_id: A string that uniquely identifies a calendar.
         :param description: A description of the calendar.
         :param job_ids: An array of anomaly detection job identifiers.
         """
         if calendar_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'calendar_id'")
         __path = f"/_ml/calendars/{_quote(calendar_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if job_ids is not None:
-            __body["job_ids"] = job_ids
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if description is not None:
+                __body["description"] = description
+            if job_ids is not None:
+                __body["job_ids"] = job_ids
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
@@ -1700,17 +1661,15 @@
     @_rewrite_parameters()
     async def put_calendar_job(
         self,
         *,
         calendar_id: str,
         job_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Adds an anomaly detection job to a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-calendar-job.html>`_
@@ -1735,39 +1694,47 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analysis",
+            "dest",
+            "source",
+            "allow_lazy_start",
+            "analyzed_fields",
+            "description",
+            "headers",
+            "max_num_threads",
+            "model_memory_limit",
+            "version",
+        ),
         ignore_deprecated_options={"headers"},
     )
     async def put_data_frame_analytics(
         self,
         *,
         id: str,
-        analysis: t.Mapping[str, t.Any],
-        dest: t.Mapping[str, t.Any],
-        source: t.Mapping[str, t.Any],
+        analysis: t.Optional[t.Mapping[str, t.Any]] = None,
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
         allow_lazy_start: t.Optional[bool] = None,
         analyzed_fields: t.Optional[t.Mapping[str, t.Any]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        headers: t.Optional[
-            t.Mapping[str, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        headers: t.Optional[t.Mapping[str, t.Union[str, t.Sequence[str]]]] = None,
         human: t.Optional[bool] = None,
         max_num_threads: t.Optional[int] = None,
         model_memory_limit: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         version: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a data frame analytics job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-dfanalytics.html>`_
 
         :param id: Identifier for the data frame analytics job. This identifier can contain
@@ -1823,112 +1790,112 @@
             file contains an `xpack.ml.max_model_memory_limit` setting, an error occurs
             when you try to create data frame analytics jobs that have `model_memory_limit`
             values greater than that setting.
         :param version:
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if analysis is None:
+        if analysis is None and body is None:
             raise ValueError("Empty value passed for parameter 'analysis'")
-        if dest is None:
+        if dest is None and body is None:
             raise ValueError("Empty value passed for parameter 'dest'")
-        if source is None:
+        if source is None and body is None:
             raise ValueError("Empty value passed for parameter 'source'")
         __path = f"/_ml/data_frame/analytics/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analysis is not None:
-            __body["analysis"] = analysis
-        if dest is not None:
-            __body["dest"] = dest
-        if source is not None:
-            __body["source"] = source
-        if allow_lazy_start is not None:
-            __body["allow_lazy_start"] = allow_lazy_start
-        if analyzed_fields is not None:
-            __body["analyzed_fields"] = analyzed_fields
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if headers is not None:
-            __body["headers"] = headers
         if human is not None:
             __query["human"] = human
-        if max_num_threads is not None:
-            __body["max_num_threads"] = max_num_threads
-        if model_memory_limit is not None:
-            __body["model_memory_limit"] = model_memory_limit
         if pretty is not None:
             __query["pretty"] = pretty
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if analysis is not None:
+                __body["analysis"] = analysis
+            if dest is not None:
+                __body["dest"] = dest
+            if source is not None:
+                __body["source"] = source
+            if allow_lazy_start is not None:
+                __body["allow_lazy_start"] = allow_lazy_start
+            if analyzed_fields is not None:
+                __body["analyzed_fields"] = analyzed_fields
+            if description is not None:
+                __body["description"] = description
+            if headers is not None:
+                __body["headers"] = headers
+            if max_num_threads is not None:
+                __body["max_num_threads"] = max_num_threads
+            if model_memory_limit is not None:
+                __body["model_memory_limit"] = model_memory_limit
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "chunking_config",
+            "delayed_data_check_config",
+            "frequency",
+            "headers",
+            "indexes",
+            "indices",
+            "indices_options",
+            "job_id",
+            "max_empty_searches",
+            "query",
+            "query_delay",
+            "runtime_mappings",
+            "script_fields",
+            "scroll_size",
+        ),
         ignore_deprecated_options={"headers"},
     )
     async def put_datafeed(
         self,
         *,
         datafeed_id: str,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         chunking_config: t.Optional[t.Mapping[str, t.Any]] = None,
         delayed_data_check_config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        headers: t.Optional[
-            t.Mapping[str, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
+        headers: t.Optional[t.Mapping[str, t.Union[str, t.Sequence[str]]]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indexes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        indices: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        indexes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        indices: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         indices_options: t.Optional[t.Mapping[str, t.Any]] = None,
         job_id: t.Optional[str] = None,
         max_empty_searches: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         query_delay: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll_size: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a datafeed.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -1999,145 +1966,161 @@
         :param scroll_size: The size parameter that is used in Elasticsearch searches
             when the datafeed does not use aggregations. The maximum value is the value
             of `index.max_result_window`, which is 10,000 by default.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if chunking_config is not None:
-            __body["chunking_config"] = chunking_config
-        if delayed_data_check_config is not None:
-            __body["delayed_data_check_config"] = delayed_data_check_config
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
-        if headers is not None:
-            __body["headers"] = headers
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indexes is not None:
-            __body["indexes"] = indexes
-        if indices is not None:
-            __body["indices"] = indices
-        if indices_options is not None:
-            __body["indices_options"] = indices_options
-        if job_id is not None:
-            __body["job_id"] = job_id
-        if max_empty_searches is not None:
-            __body["max_empty_searches"] = max_empty_searches
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if query_delay is not None:
-            __body["query_delay"] = query_delay
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
-        if scroll_size is not None:
-            __body["scroll_size"] = scroll_size
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if chunking_config is not None:
+                __body["chunking_config"] = chunking_config
+            if delayed_data_check_config is not None:
+                __body["delayed_data_check_config"] = delayed_data_check_config
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if headers is not None:
+                __body["headers"] = headers
+            if indexes is not None:
+                __body["indexes"] = indexes
+            if indices is not None:
+                __body["indices"] = indices
+            if indices_options is not None:
+                __body["indices_options"] = indices_options
+            if job_id is not None:
+                __body["job_id"] = job_id
+            if max_empty_searches is not None:
+                __body["max_empty_searches"] = max_empty_searches
+            if query is not None:
+                __body["query"] = query
+            if query_delay is not None:
+                __body["query_delay"] = query_delay
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if scroll_size is not None:
+                __body["scroll_size"] = scroll_size
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("description", "items"),
     )
     async def put_filter(
         self,
         *,
         filter_id: str,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        items: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        items: t.Optional[t.Sequence[str]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a filter.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-filter.html>`_
 
         :param filter_id: A string that uniquely identifies a filter.
         :param description: A description of the filter.
         :param items: The items of the filter. A wildcard `*` can be used at the beginning
             or the end of an item. Up to 10000 items are allowed in each filter.
         """
         if filter_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'filter_id'")
         __path = f"/_ml/filters/{_quote(filter_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if items is not None:
-            __body["items"] = items
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if items is not None:
+                __body["items"] = items
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analysis_config",
+            "data_description",
+            "allow_lazy_open",
+            "analysis_limits",
+            "background_persist_interval",
+            "custom_settings",
+            "daily_model_snapshot_retention_after_days",
+            "datafeed_config",
+            "description",
+            "groups",
+            "model_plot_config",
+            "model_snapshot_retention_days",
+            "renormalization_window_days",
+            "results_index_name",
+            "results_retention_days",
+        ),
     )
     async def put_job(
         self,
         *,
         job_id: str,
-        analysis_config: t.Mapping[str, t.Any],
-        data_description: t.Mapping[str, t.Any],
+        analysis_config: t.Optional[t.Mapping[str, t.Any]] = None,
+        data_description: t.Optional[t.Mapping[str, t.Any]] = None,
         allow_lazy_open: t.Optional[bool] = None,
         analysis_limits: t.Optional[t.Mapping[str, t.Any]] = None,
         background_persist_interval: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         custom_settings: t.Optional[t.Any] = None,
         daily_model_snapshot_retention_after_days: t.Optional[int] = None,
         datafeed_config: t.Optional[t.Mapping[str, t.Any]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        groups: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        groups: t.Optional[t.Sequence[str]] = None,
         human: t.Optional[bool] = None,
         model_plot_config: t.Optional[t.Mapping[str, t.Any]] = None,
         model_snapshot_retention_days: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         renormalization_window_days: t.Optional[int] = None,
         results_index_name: t.Optional[str] = None,
         results_retention_days: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates an anomaly detection job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-job.html>`_
 
         :param job_id: The identifier for the anomaly detection job. This identifier
@@ -2211,91 +2194,106 @@
             The default value is null, which means all results are retained. Annotations
             generated by the system also count as results for retention purposes; they
             are deleted after the same number of days as results. Annotations added by
             users are retained forever.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
-        if analysis_config is None:
+        if analysis_config is None and body is None:
             raise ValueError("Empty value passed for parameter 'analysis_config'")
-        if data_description is None:
+        if data_description is None and body is None:
             raise ValueError("Empty value passed for parameter 'data_description'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analysis_config is not None:
-            __body["analysis_config"] = analysis_config
-        if data_description is not None:
-            __body["data_description"] = data_description
-        if allow_lazy_open is not None:
-            __body["allow_lazy_open"] = allow_lazy_open
-        if analysis_limits is not None:
-            __body["analysis_limits"] = analysis_limits
-        if background_persist_interval is not None:
-            __body["background_persist_interval"] = background_persist_interval
-        if custom_settings is not None:
-            __body["custom_settings"] = custom_settings
-        if daily_model_snapshot_retention_after_days is not None:
-            __body[
-                "daily_model_snapshot_retention_after_days"
-            ] = daily_model_snapshot_retention_after_days
-        if datafeed_config is not None:
-            __body["datafeed_config"] = datafeed_config
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if groups is not None:
-            __body["groups"] = groups
-        if human is not None:
-            __query["human"] = human
-        if model_plot_config is not None:
-            __body["model_plot_config"] = model_plot_config
-        if model_snapshot_retention_days is not None:
-            __body["model_snapshot_retention_days"] = model_snapshot_retention_days
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if renormalization_window_days is not None:
-            __body["renormalization_window_days"] = renormalization_window_days
-        if results_index_name is not None:
-            __body["results_index_name"] = results_index_name
-        if results_retention_days is not None:
-            __body["results_retention_days"] = results_retention_days
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        if not __body:
+            if analysis_config is not None:
+                __body["analysis_config"] = analysis_config
+            if data_description is not None:
+                __body["data_description"] = data_description
+            if allow_lazy_open is not None:
+                __body["allow_lazy_open"] = allow_lazy_open
+            if analysis_limits is not None:
+                __body["analysis_limits"] = analysis_limits
+            if background_persist_interval is not None:
+                __body["background_persist_interval"] = background_persist_interval
+            if custom_settings is not None:
+                __body["custom_settings"] = custom_settings
+            if daily_model_snapshot_retention_after_days is not None:
+                __body["daily_model_snapshot_retention_after_days"] = (
+                    daily_model_snapshot_retention_after_days
+                )
+            if datafeed_config is not None:
+                __body["datafeed_config"] = datafeed_config
+            if description is not None:
+                __body["description"] = description
+            if groups is not None:
+                __body["groups"] = groups
+            if model_plot_config is not None:
+                __body["model_plot_config"] = model_plot_config
+            if model_snapshot_retention_days is not None:
+                __body["model_snapshot_retention_days"] = model_snapshot_retention_days
+            if renormalization_window_days is not None:
+                __body["renormalization_window_days"] = renormalization_window_days
+            if results_index_name is not None:
+                __body["results_index_name"] = results_index_name
+            if results_retention_days is not None:
+                __body["results_retention_days"] = results_retention_days
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "compressed_definition",
+            "definition",
+            "description",
+            "inference_config",
+            "input",
+            "metadata",
+            "model_size_bytes",
+            "model_type",
+            "platform_architecture",
+            "prefix_strings",
+            "tags",
+        ),
     )
     async def put_trained_model(
         self,
         *,
         model_id: str,
         compressed_definition: t.Optional[str] = None,
         defer_definition_decompression: t.Optional[bool] = None,
         definition: t.Optional[t.Mapping[str, t.Any]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         inference_config: t.Optional[t.Mapping[str, t.Any]] = None,
         input: t.Optional[t.Mapping[str, t.Any]] = None,
         metadata: t.Optional[t.Any] = None,
         model_size_bytes: t.Optional[int] = None,
         model_type: t.Optional[
             t.Union["t.Literal['lang_ident', 'pytorch', 'tree_ensemble']", str]
         ] = None,
+        platform_architecture: t.Optional[str] = None,
+        prefix_strings: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        tags: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        tags: t.Optional[t.Sequence[str]] = None,
+        wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates an inference trained model.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-trained-models.html>`_
 
         :param model_id: The unique identifier of the trained model.
@@ -2314,64 +2312,80 @@
             the config is not required.
         :param input: The input field names for the model definition.
         :param metadata: An object map that contains metadata about the model.
         :param model_size_bytes: The estimated memory usage in bytes to keep the trained
             model in memory. This property is supported only if defer_definition_decompression
             is true or the model definition is not supplied.
         :param model_type: The model type.
+        :param platform_architecture: The platform architecture (if applicable) of the
+            trained mode. If the model only works on one platform, because it is heavily
+            optimized for a particular processor architecture and OS combination, then
+            this field specifies which. The format of the string must match the platform
+            identifiers used by Elasticsearch, so one of, `linux-x86_64`, `linux-aarch64`,
+            `darwin-x86_64`, `darwin-aarch64`, or `windows-x86_64`. For portable models
+            (those that work independent of processor architecture or OS features), leave
+            this field unset.
+        :param prefix_strings: Optional prefix strings applied at inference
         :param tags: An array of tags to organize the model.
+        :param wait_for_completion: Whether to wait for all child operations (e.g. model
+            download) to complete.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
         __path = f"/_ml/trained_models/{_quote(model_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if compressed_definition is not None:
-            __body["compressed_definition"] = compressed_definition
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if defer_definition_decompression is not None:
             __query["defer_definition_decompression"] = defer_definition_decompression
-        if definition is not None:
-            __body["definition"] = definition
-        if description is not None:
-            __body["description"] = description
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if inference_config is not None:
-            __body["inference_config"] = inference_config
-        if input is not None:
-            __body["input"] = input
-        if metadata is not None:
-            __body["metadata"] = metadata
-        if model_size_bytes is not None:
-            __body["model_size_bytes"] = model_size_bytes
-        if model_type is not None:
-            __body["model_type"] = model_type
         if pretty is not None:
             __query["pretty"] = pretty
-        if tags is not None:
-            __body["tags"] = tags
+        if wait_for_completion is not None:
+            __query["wait_for_completion"] = wait_for_completion
+        if not __body:
+            if compressed_definition is not None:
+                __body["compressed_definition"] = compressed_definition
+            if definition is not None:
+                __body["definition"] = definition
+            if description is not None:
+                __body["description"] = description
+            if inference_config is not None:
+                __body["inference_config"] = inference_config
+            if input is not None:
+                __body["input"] = input
+            if metadata is not None:
+                __body["metadata"] = metadata
+            if model_size_bytes is not None:
+                __body["model_size_bytes"] = model_size_bytes
+            if model_type is not None:
+                __body["model_type"] = model_type
+            if platform_architecture is not None:
+                __body["platform_architecture"] = platform_architecture
+            if prefix_strings is not None:
+                __body["prefix_strings"] = prefix_strings
+            if tags is not None:
+                __body["tags"] = tags
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     async def put_trained_model_alias(
         self,
         *,
         model_id: str,
         model_alias: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         reassign: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a new model alias (or reassigns an existing one) to refer to the trained
         model
@@ -2402,30 +2416,29 @@
             __query["reassign"] = reassign
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("definition", "total_definition_length", "total_parts"),
     )
     async def put_trained_model_definition_part(
         self,
         *,
         model_id: str,
         part: int,
-        definition: str,
-        total_definition_length: int,
-        total_parts: int,
+        definition: t.Optional[str] = None,
+        total_definition_length: t.Optional[int] = None,
+        total_parts: t.Optional[int] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates part of a trained model definition
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-trained-model-definition-part.html>`_
 
         :param model_id: The unique identifier of the trained model.
@@ -2439,103 +2452,106 @@
         :param total_parts: The total number of parts that will be uploaded. Must be
             greater than 0.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
         if part in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'part'")
-        if definition is None:
+        if definition is None and body is None:
             raise ValueError("Empty value passed for parameter 'definition'")
-        if total_definition_length is None:
+        if total_definition_length is None and body is None:
             raise ValueError(
                 "Empty value passed for parameter 'total_definition_length'"
             )
-        if total_parts is None:
+        if total_parts is None and body is None:
             raise ValueError("Empty value passed for parameter 'total_parts'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/definition/{_quote(part)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if definition is not None:
-            __body["definition"] = definition
-        if total_definition_length is not None:
-            __body["total_definition_length"] = total_definition_length
-        if total_parts is not None:
-            __body["total_parts"] = total_parts
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if definition is not None:
+                __body["definition"] = definition
+            if total_definition_length is not None:
+                __body["total_definition_length"] = total_definition_length
+            if total_parts is not None:
+                __body["total_parts"] = total_parts
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("vocabulary", "merges", "scores"),
     )
     async def put_trained_model_vocabulary(
         self,
         *,
         model_id: str,
-        vocabulary: t.Union[t.List[str], t.Tuple[str, ...]],
+        vocabulary: t.Optional[t.Sequence[str]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        merges: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        merges: t.Optional[t.Sequence[str]] = None,
         pretty: t.Optional[bool] = None,
+        scores: t.Optional[t.Sequence[float]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a trained model vocabulary
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-trained-model-vocabulary.html>`_
 
         :param model_id: The unique identifier of the trained model.
         :param vocabulary: The model vocabulary, which must not be empty.
         :param merges: The optional model merges if required by the tokenizer.
+        :param scores: The optional vocabulary value scores if required by the tokenizer.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
-        if vocabulary is None:
+        if vocabulary is None and body is None:
             raise ValueError("Empty value passed for parameter 'vocabulary'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/vocabulary"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if vocabulary is not None:
-            __body["vocabulary"] = vocabulary
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if merges is not None:
-            __body["merges"] = merges
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if vocabulary is not None:
+                __body["vocabulary"] = vocabulary
+            if merges is not None:
+                __body["merges"] = merges
+            if scores is not None:
+                __body["scores"] = scores
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     async def reset_job(
         self,
         *,
         job_id: str,
         delete_user_annotations: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Resets an existing anomaly detection job.
 
@@ -2571,17 +2587,15 @@
 
     @_rewrite_parameters()
     async def start_data_frame_analytics(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Starts a data frame analytics job.
 
@@ -2609,29 +2623,28 @@
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("end", "start", "timeout"),
     )
     async def start_datafeed(
         self,
         *,
         datafeed_id: str,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Starts one or more datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-start-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -2641,30 +2654,31 @@
         :param end: Refer to the description for the `end` query parameter.
         :param start: Refer to the description for the `start` query parameter.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_start"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if end is not None:
-            __body["end"] = end
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if start is not None:
-            __body["start"] = start
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if end is not None:
+                __body["end"] = end
+            if start is not None:
+                __body["start"] = start
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -2672,18 +2686,17 @@
 
     @_rewrite_parameters()
     async def start_trained_model_deployment(
         self,
         *,
         model_id: str,
         cache_size: t.Optional[t.Union[int, str]] = None,
+        deployment_id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         number_of_allocations: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         priority: t.Optional[t.Union["t.Literal['low', 'normal']", str]] = None,
         queue_capacity: t.Optional[int] = None,
         threads_per_allocation: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
@@ -2697,14 +2710,15 @@
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/start-trained-model-deployment.html>`_
 
         :param model_id: The unique identifier of the trained model. Currently, only
             PyTorch models are supported.
         :param cache_size: The inference cache size (in memory outside the JVM heap)
             per node for the model. The default value is the same size as the `model_size_bytes`.
             To disable the cache, `0b` can be provided.
+        :param deployment_id: A unique identifier for the deployment of the model.
         :param number_of_allocations: The number of model allocations on each node where
             the model is deployed. All allocations on a node share the same copy of the
             model in memory but use a separate set of threads to evaluate the model.
             Increasing this value generally increases the throughput. If this setting
             is greater than the number of hardware threads it will automatically be changed
             to a value less than the number of hardware threads.
         :param priority: The deployment priority.
@@ -2723,14 +2737,16 @@
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/deployment/_start"
         __query: t.Dict[str, t.Any] = {}
         if cache_size is not None:
             __query["cache_size"] = cache_size
+        if deployment_id is not None:
+            __query["deployment_id"] = deployment_id
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if number_of_allocations is not None:
@@ -2755,17 +2771,15 @@
     @_rewrite_parameters()
     async def stop_data_frame_analytics(
         self,
         *,
         id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Stops one or more data frame analytics jobs.
@@ -2807,29 +2821,28 @@
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("allow_no_match", "force", "timeout"),
     )
     async def stop_datafeed(
         self,
         *,
         datafeed_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Stops one or more datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-stop-datafeed.html>`_
 
         :param datafeed_id: Identifier for the datafeed. You can stop multiple datafeeds
@@ -2840,30 +2853,31 @@
             parameter.
         :param force: Refer to the description for the `force` query parameter.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_stop"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_match is not None:
-            __body["allow_no_match"] = allow_no_match
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if force is not None:
-            __body["force"] = force
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if allow_no_match is not None:
+                __body["allow_no_match"] = allow_no_match
+            if force is not None:
+                __body["force"] = force
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -2872,17 +2886,15 @@
     @_rewrite_parameters()
     async def stop_trained_model_deployment(
         self,
         *,
         model_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Stop a trained model deployment.
 
@@ -2917,30 +2929,34 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "allow_lazy_start",
+            "description",
+            "max_num_threads",
+            "model_memory_limit",
+        ),
     )
     async def update_data_frame_analytics(
         self,
         *,
         id: str,
         allow_lazy_start: t.Optional[bool] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_num_threads: t.Optional[int] = None,
         model_memory_limit: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of a data frame analytics job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/update-dfanalytics.html>`_
 
         :param id: Identifier for the data frame analytics job. This identifier can contain
@@ -2958,85 +2974,90 @@
             file contains an `xpack.ml.max_model_memory_limit` setting, an error occurs
             when you try to create data frame analytics jobs that have `model_memory_limit`
             values greater than that setting.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/_ml/data_frame/analytics/{_quote(id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_lazy_start is not None:
-            __body["allow_lazy_start"] = allow_lazy_start
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if max_num_threads is not None:
-            __body["max_num_threads"] = max_num_threads
-        if model_memory_limit is not None:
-            __body["model_memory_limit"] = model_memory_limit
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if allow_lazy_start is not None:
+                __body["allow_lazy_start"] = allow_lazy_start
+            if description is not None:
+                __body["description"] = description
+            if max_num_threads is not None:
+                __body["max_num_threads"] = max_num_threads
+            if model_memory_limit is not None:
+                __body["model_memory_limit"] = model_memory_limit
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "chunking_config",
+            "delayed_data_check_config",
+            "frequency",
+            "indexes",
+            "indices",
+            "indices_options",
+            "job_id",
+            "max_empty_searches",
+            "query",
+            "query_delay",
+            "runtime_mappings",
+            "script_fields",
+            "scroll_size",
+        ),
     )
     async def update_datafeed(
         self,
         *,
         datafeed_id: str,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         chunking_config: t.Optional[t.Mapping[str, t.Any]] = None,
         delayed_data_check_config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indexes: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        indices: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        indexes: t.Optional[t.Sequence[str]] = None,
+        indices: t.Optional[t.Sequence[str]] = None,
         indices_options: t.Optional[t.Mapping[str, t.Any]] = None,
         job_id: t.Optional[str] = None,
         max_empty_searches: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         query_delay: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll_size: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of a datafeed.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-update-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -3118,152 +3139,164 @@
         :param scroll_size: The size parameter that is used in Elasticsearch searches
             when the datafeed does not use aggregations. The maximum value is the value
             of `index.max_result_window`.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if chunking_config is not None:
-            __body["chunking_config"] = chunking_config
-        if delayed_data_check_config is not None:
-            __body["delayed_data_check_config"] = delayed_data_check_config
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indexes is not None:
-            __body["indexes"] = indexes
-        if indices is not None:
-            __body["indices"] = indices
-        if indices_options is not None:
-            __body["indices_options"] = indices_options
-        if job_id is not None:
-            __body["job_id"] = job_id
-        if max_empty_searches is not None:
-            __body["max_empty_searches"] = max_empty_searches
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if query_delay is not None:
-            __body["query_delay"] = query_delay
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
-        if scroll_size is not None:
-            __body["scroll_size"] = scroll_size
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if chunking_config is not None:
+                __body["chunking_config"] = chunking_config
+            if delayed_data_check_config is not None:
+                __body["delayed_data_check_config"] = delayed_data_check_config
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if indexes is not None:
+                __body["indexes"] = indexes
+            if indices is not None:
+                __body["indices"] = indices
+            if indices_options is not None:
+                __body["indices_options"] = indices_options
+            if job_id is not None:
+                __body["job_id"] = job_id
+            if max_empty_searches is not None:
+                __body["max_empty_searches"] = max_empty_searches
+            if query is not None:
+                __body["query"] = query
+            if query_delay is not None:
+                __body["query_delay"] = query_delay
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if scroll_size is not None:
+                __body["scroll_size"] = scroll_size
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("add_items", "description", "remove_items"),
     )
     async def update_filter(
         self,
         *,
         filter_id: str,
-        add_items: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        add_items: t.Optional[t.Sequence[str]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        remove_items: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        remove_items: t.Optional[t.Sequence[str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates the description of a filter, adds items, or removes items.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-update-filter.html>`_
 
         :param filter_id: A string that uniquely identifies a filter.
         :param add_items: The items to add to the filter.
         :param description: A description for the filter.
         :param remove_items: The items to remove from the filter.
         """
         if filter_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'filter_id'")
         __path = f"/_ml/filters/{_quote(filter_id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if add_items is not None:
-            __body["add_items"] = add_items
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if remove_items is not None:
-            __body["remove_items"] = remove_items
+        if not __body:
+            if add_items is not None:
+                __body["add_items"] = add_items
+            if description is not None:
+                __body["description"] = description
+            if remove_items is not None:
+                __body["remove_items"] = remove_items
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "allow_lazy_open",
+            "analysis_limits",
+            "background_persist_interval",
+            "categorization_filters",
+            "custom_settings",
+            "daily_model_snapshot_retention_after_days",
+            "description",
+            "detectors",
+            "groups",
+            "model_plot_config",
+            "model_prune_window",
+            "model_snapshot_retention_days",
+            "per_partition_categorization",
+            "renormalization_window_days",
+            "results_retention_days",
+        ),
     )
     async def update_job(
         self,
         *,
         job_id: str,
         allow_lazy_open: t.Optional[bool] = None,
         analysis_limits: t.Optional[t.Mapping[str, t.Any]] = None,
         background_persist_interval: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        categorization_filters: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
+        categorization_filters: t.Optional[t.Sequence[str]] = None,
         custom_settings: t.Optional[t.Mapping[str, t.Any]] = None,
         daily_model_snapshot_retention_after_days: t.Optional[int] = None,
         description: t.Optional[str] = None,
-        detectors: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        detectors: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        groups: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        groups: t.Optional[t.Sequence[str]] = None,
         human: t.Optional[bool] = None,
         model_plot_config: t.Optional[t.Mapping[str, t.Any]] = None,
         model_prune_window: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         model_snapshot_retention_days: t.Optional[int] = None,
         per_partition_categorization: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         renormalization_window_days: t.Optional[int] = None,
         results_retention_days: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of an anomaly detection job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-update-job.html>`_
 
         :param job_id: Identifier for the job.
@@ -3314,53 +3347,54 @@
             per day at 00:30 (server time), results that are the specified number of
             days older than the latest bucket result are deleted from Elasticsearch.
             The default value is null, which means all results are retained.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_lazy_open is not None:
-            __body["allow_lazy_open"] = allow_lazy_open
-        if analysis_limits is not None:
-            __body["analysis_limits"] = analysis_limits
-        if background_persist_interval is not None:
-            __body["background_persist_interval"] = background_persist_interval
-        if categorization_filters is not None:
-            __body["categorization_filters"] = categorization_filters
-        if custom_settings is not None:
-            __body["custom_settings"] = custom_settings
-        if daily_model_snapshot_retention_after_days is not None:
-            __body[
-                "daily_model_snapshot_retention_after_days"
-            ] = daily_model_snapshot_retention_after_days
-        if description is not None:
-            __body["description"] = description
-        if detectors is not None:
-            __body["detectors"] = detectors
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if groups is not None:
-            __body["groups"] = groups
-        if human is not None:
-            __query["human"] = human
-        if model_plot_config is not None:
-            __body["model_plot_config"] = model_plot_config
-        if model_prune_window is not None:
-            __body["model_prune_window"] = model_prune_window
-        if model_snapshot_retention_days is not None:
-            __body["model_snapshot_retention_days"] = model_snapshot_retention_days
-        if per_partition_categorization is not None:
-            __body["per_partition_categorization"] = per_partition_categorization
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if renormalization_window_days is not None:
-            __body["renormalization_window_days"] = renormalization_window_days
-        if results_retention_days is not None:
-            __body["results_retention_days"] = results_retention_days
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        if not __body:
+            if allow_lazy_open is not None:
+                __body["allow_lazy_open"] = allow_lazy_open
+            if analysis_limits is not None:
+                __body["analysis_limits"] = analysis_limits
+            if background_persist_interval is not None:
+                __body["background_persist_interval"] = background_persist_interval
+            if categorization_filters is not None:
+                __body["categorization_filters"] = categorization_filters
+            if custom_settings is not None:
+                __body["custom_settings"] = custom_settings
+            if daily_model_snapshot_retention_after_days is not None:
+                __body["daily_model_snapshot_retention_after_days"] = (
+                    daily_model_snapshot_retention_after_days
+                )
+            if description is not None:
+                __body["description"] = description
+            if detectors is not None:
+                __body["detectors"] = detectors
+            if groups is not None:
+                __body["groups"] = groups
+            if model_plot_config is not None:
+                __body["model_plot_config"] = model_plot_config
+            if model_prune_window is not None:
+                __body["model_prune_window"] = model_prune_window
+            if model_snapshot_retention_days is not None:
+                __body["model_snapshot_retention_days"] = model_snapshot_retention_days
+            if per_partition_categorization is not None:
+                __body["per_partition_categorization"] = per_partition_categorization
+            if renormalization_window_days is not None:
+                __body["renormalization_window_days"] = renormalization_window_days
+            if results_retention_days is not None:
+                __body["results_retention_days"] = results_retention_days
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/monitoring.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/tasks.py`

 * *Files 16% similar despite different names*

```diff
@@ -16,72 +16,55 @@
 #  under the License.
 
 import typing as t
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
-from .utils import _rewrite_parameters
+from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class MonitoringClient(NamespacedClient):
-    @_rewrite_parameters(
-        body_name="operations",
-    )
-    async def bulk(
+class TasksClient(NamespacedClient):
+
+    @_rewrite_parameters()
+    def get(
         self,
         *,
-        interval: t.Union["t.Literal[-1]", "t.Literal[0]", str],
-        operations: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        system_api_version: str,
-        system_id: str,
+        task_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Used by the monitoring features to send monitoring data.
+        Returns information about a task.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/monitor-elasticsearch-cluster.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html>`_
 
-        :param interval: Collection interval (e.g., '10s' or '10000ms') of the payload
-        :param operations:
-        :param system_api_version:
-        :param system_id: Identifier of the monitored system
+        :param task_id: ID of the task.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        :param wait_for_completion: If `true`, the request blocks until the task has
+            completed.
         """
-        if interval is None:
-            raise ValueError("Empty value passed for parameter 'interval'")
-        if operations is None:
-            raise ValueError("Empty value passed for parameter 'operations'")
-        if system_api_version is None:
-            raise ValueError("Empty value passed for parameter 'system_api_version'")
-        if system_id is None:
-            raise ValueError("Empty value passed for parameter 'system_id'")
-        __path = "/_monitoring/bulk"
+        if task_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'task_id'")
+        __path = f"/_tasks/{_quote(task_id)}"
         __query: t.Dict[str, t.Any] = {}
-        if interval is not None:
-            __query["interval"] = interval
-        if system_api_version is not None:
-            __query["system_api_version"] = system_api_version
-        if system_id is not None:
-            __query["system_id"] = system_id
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = operations
-        __headers = {
-            "accept": "application/json",
-            "content-type": "application/x-ndjson",
-        }
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
+        if timeout is not None:
+            __query["timeout"] = timeout
+        if wait_for_completion is not None:
+            __query["wait_for_completion"] = wait_for_completion
+        __headers = {"accept": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/nodes.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/sql.py`

 * *Files 26% similar despite different names*

```diff
@@ -13,471 +13,374 @@
 #  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 #  KIND, either express or implied.  See the License for the
 #  specific language governing permissions and limitations
 #  under the License.
 
 import typing as t
 
-from elastic_transport import ObjectApiResponse, TextApiResponse
+from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class NodesClient(NamespacedClient):
-    @_rewrite_parameters()
-    async def clear_repositories_metering_archive(
+class SqlClient(NamespacedClient):
+
+    @_rewrite_parameters(
+        body_fields=("cursor",),
+    )
+    async def clear_cursor(
         self,
         *,
-        node_id: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        max_archive_version: int,
+        cursor: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Removes the archived repositories metering information present in the cluster.
+        Clears the SQL cursor
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/clear-repositories-metering-archive-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-sql-cursor-api.html>`_
 
-        :param node_id: Comma-separated list of node IDs or names used to limit returned
-            information. All the nodes selective options are explained [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html#cluster-nodes).
-        :param max_archive_version: Specifies the maximum [archive_version](https://www.elastic.co/guide/en/elasticsearch/reference/current/get-repositories-metering-api.html#get-repositories-metering-api-response-body)
-            to be cleared from the archive.
-        """
-        if node_id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'node_id'")
-        if max_archive_version in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'max_archive_version'")
-        __path = f"/_nodes/{_quote(node_id)}/_repositories_metering/{_quote(max_archive_version)}"
+        :param cursor: Cursor to clear.
+        """
+        if cursor is None and body is None:
+            raise ValueError("Empty value passed for parameter 'cursor'")
+        __path = "/_sql/close"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
+        if not __body:
+            if cursor is not None:
+                __body["cursor"] = cursor
+        __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "DELETE", __path, params=__query, headers=__headers
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def get_repositories_metering_info(
+    async def delete_async(
         self,
         *,
-        node_id: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns cluster repositories metering information.
+        Deletes an async SQL search or a stored synchronous SQL search. If the search
+        is still running, the API cancels it.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/get-repositories-metering-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-async-sql-search-api.html>`_
 
-        :param node_id: Comma-separated list of node IDs or names used to limit returned
-            information. All the nodes selective options are explained [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html#cluster-nodes).
+        :param id: Identifier for the search.
         """
-        if node_id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'node_id'")
-        __path = f"/_nodes/{_quote(node_id)}/_repositories_metering"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_sql/async/delete/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+            "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def hot_threads(
+    async def get_async(
         self,
         *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        id: str,
+        delimiter: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        format: t.Optional[str] = None,
         human: t.Optional[bool] = None,
-        ignore_idle_threads: t.Optional[bool] = None,
-        interval: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         pretty: t.Optional[bool] = None,
-        snapshots: t.Optional[int] = None,
-        sort: t.Optional[
-            t.Union["t.Literal['block', 'cpu', 'gpu', 'mem', 'wait']", str]
-        ] = None,
-        threads: t.Optional[int] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        type: t.Optional[
-            t.Union["t.Literal['block', 'cpu', 'gpu', 'mem', 'wait']", str]
+        wait_for_completion_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-    ) -> TextApiResponse:
+    ) -> ObjectApiResponse[t.Any]:
         """
-        Returns information about hot threads on each node in the cluster.
+        Returns the current status and available results for an async SQL search or stored
+        synchronous SQL search
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/cluster-nodes-hot-threads.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-sql-search-api.html>`_
 
-        :param node_id: List of node IDs or names used to limit returned information.
-        :param ignore_idle_threads: If true, known idle threads (e.g. waiting in a socket
-            select, or to get a task from an empty queue) are filtered out.
-        :param interval: The interval to do the second sampling of threads.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param snapshots: Number of samples of thread stacktrace.
-        :param sort: The sort order for 'cpu' type (default: total)
-        :param threads: Specifies the number of hot threads to provide information for.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        :param type: The type to sample.
-        """
-        if node_id not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/hot_threads"
-        else:
-            __path = "/_nodes/hot_threads"
+        :param id: Identifier for the search.
+        :param delimiter: Separator for CSV results. The API only supports this parameter
+            for CSV responses.
+        :param format: Format for the response. You must specify a format using this
+            parameter or the Accept HTTP header. If you specify both, the API uses this
+            parameter.
+        :param keep_alive: Retention period for the search and its results. Defaults
+            to the `keep_alive` period for the original SQL search.
+        :param wait_for_completion_timeout: Period to wait for complete results. Defaults
+            to no timeout, meaning the request waits for complete search results.
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_sql/async/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
+        if delimiter is not None:
+            __query["delimiter"] = delimiter
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if format is not None:
+            __query["format"] = format
         if human is not None:
             __query["human"] = human
-        if ignore_idle_threads is not None:
-            __query["ignore_idle_threads"] = ignore_idle_threads
-        if interval is not None:
-            __query["interval"] = interval
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
+        if keep_alive is not None:
+            __query["keep_alive"] = keep_alive
         if pretty is not None:
             __query["pretty"] = pretty
-        if snapshots is not None:
-            __query["snapshots"] = snapshots
-        if sort is not None:
-            __query["sort"] = sort
-        if threads is not None:
-            __query["threads"] = threads
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if type is not None:
-            __query["type"] = type
-        __headers = {"accept": "text/plain"}
+        if wait_for_completion_timeout is not None:
+            __query["wait_for_completion_timeout"] = wait_for_completion_timeout
+        __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def info(
+    async def get_async_status(
         self,
         *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        metric: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        flat_settings: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns information about nodes in the cluster.
+        Returns the current status of an async SQL search or a stored synchronous SQL
+        search
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/cluster-nodes-info.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-sql-search-status-api.html>`_
 
-        :param node_id: Comma-separated list of node IDs or names used to limit returned
-            information.
-        :param metric: Limits the information returned to the specific metrics. Supports
-            a comma-separated list, such as http,ingest.
-        :param flat_settings: If true, returns settings in flat format.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if node_id not in SKIP_IN_PATH and metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/{_quote(metric)}"
-        elif node_id not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}"
-        elif metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(metric)}"
-        else:
-            __path = "/_nodes"
+        :param id: Identifier for the search.
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_sql/async/status/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if flat_settings is not None:
-            __query["flat_settings"] = flat_settings
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "catalog",
+            "columnar",
+            "cursor",
+            "fetch_size",
+            "field_multi_value_leniency",
+            "filter",
+            "index_using_frozen",
+            "keep_alive",
+            "keep_on_completion",
+            "page_timeout",
+            "params",
+            "query",
+            "request_timeout",
+            "runtime_mappings",
+            "time_zone",
+            "wait_for_completion_timeout",
+        ),
+        ignore_deprecated_options={"params", "request_timeout"},
     )
-    async def reload_secure_settings(
+    async def query(
         self,
         *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        catalog: t.Optional[str] = None,
+        columnar: t.Optional[bool] = None,
+        cursor: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fetch_size: t.Optional[int] = None,
+        field_multi_value_leniency: t.Optional[bool] = None,
+        filter: t.Optional[t.Mapping[str, t.Any]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        format: t.Optional[str] = None,
         human: t.Optional[bool] = None,
+        index_using_frozen: t.Optional[bool] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        keep_on_completion: t.Optional[bool] = None,
+        page_timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        params: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        secure_settings_password: t.Optional[str] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Reloads secure settings.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/secure-settings.html#reloadable-secure-settings>`_
-
-        :param node_id: A comma-separated list of node IDs to span the reload/reinit
-            call. Should stay empty because reloading usually involves all cluster nodes.
-        :param secure_settings_password:
-        :param timeout: Explicit operation timeout
-        """
-        if node_id not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/reload_secure_settings"
-        else:
-            __path = "/_nodes/reload_secure_settings"
-        __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if secure_settings_password is not None:
-            __body["secure_settings_password"] = secure_settings_password
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if not __body:
-            __body = None  # type: ignore[assignment]
-        __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
-        )
-
-    @_rewrite_parameters()
-    async def stats(
-        self,
-        *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        metric: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        index_metric: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        completion_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        error_trace: t.Optional[bool] = None,
-        fielddata_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        groups: t.Optional[bool] = None,
-        human: t.Optional[bool] = None,
-        include_segment_file_sizes: t.Optional[bool] = None,
-        include_unloaded_segments: t.Optional[bool] = None,
-        level: t.Optional[
-            t.Union["t.Literal['cluster', 'indices', 'shards']", str]
+        query: t.Optional[str] = None,
+        request_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        master_timeout: t.Optional[
+        runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        time_zone: t.Optional[str] = None,
+        wait_for_completion_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        types: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns statistical information about nodes in the cluster.
+        Executes a SQL request
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/cluster-nodes-stats.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/sql-search-api.html>`_
 
-        :param node_id: Comma-separated list of node IDs or names used to limit returned
-            information.
-        :param metric: Limit the information returned to the specified metrics
-        :param index_metric: Limit the information returned for indices metric to the
-            specific index metrics. It can be used only if indices (or all) metric is
-            specified.
-        :param completion_fields: Comma-separated list or wildcard expressions of fields
-            to include in fielddata and suggest statistics.
-        :param fielddata_fields: Comma-separated list or wildcard expressions of fields
-            to include in fielddata statistics.
-        :param fields: Comma-separated list or wildcard expressions of fields to include
-            in the statistics.
-        :param groups: Comma-separated list of search groups to include in the search
-            statistics.
-        :param include_segment_file_sizes: If true, the call reports the aggregated disk
-            usage of each one of the Lucene index files (only applies if segment stats
-            are requested).
-        :param include_unloaded_segments: If set to true segment stats will include stats
-            for segments that are not currently loaded into memory
-        :param level: Indicates whether statistics are aggregated at the cluster, index,
-            or shard level.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        :param types: A comma-separated list of document types for the indexing index
-            metric.
-        """
-        if (
-            node_id not in SKIP_IN_PATH
-            and metric not in SKIP_IN_PATH
-            and index_metric not in SKIP_IN_PATH
-        ):
-            __path = f"/_nodes/{_quote(node_id)}/stats/{_quote(metric)}/{_quote(index_metric)}"
-        elif node_id not in SKIP_IN_PATH and metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/stats/{_quote(metric)}"
-        elif metric not in SKIP_IN_PATH and index_metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/stats/{_quote(metric)}/{_quote(index_metric)}"
-        elif node_id not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/stats"
-        elif metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/stats/{_quote(metric)}"
-        else:
-            __path = "/_nodes/stats"
+        :param catalog: Default catalog (cluster) for queries. If unspecified, the queries
+            execute on the data in the local cluster only.
+        :param columnar: If true, the results in a columnar fashion: one row represents
+            all the values of a certain column from the current page of results.
+        :param cursor: Cursor used to retrieve a set of paginated results. If you specify
+            a cursor, the API only uses the `columnar` and `time_zone` request body parameters.
+            It ignores other request body parameters.
+        :param fetch_size: The maximum number of rows (or entries) to return in one response
+        :param field_multi_value_leniency: Throw an exception when encountering multiple
+            values for a field (default) or be lenient and return the first value from
+            the list (without any guarantees of what that will be - typically the first
+            in natural ascending order).
+        :param filter: Elasticsearch query DSL for additional filtering.
+        :param format: Format for the response.
+        :param index_using_frozen: If true, the search can run on frozen indices. Defaults
+            to false.
+        :param keep_alive: Retention period for an async or saved synchronous search.
+        :param keep_on_completion: If true, Elasticsearch stores synchronous searches
+            if you also specify the wait_for_completion_timeout parameter. If false,
+            Elasticsearch only stores async searches that don’t finish before the wait_for_completion_timeout.
+        :param page_timeout: The timeout before a pagination request fails.
+        :param params: Values for parameters in the query.
+        :param query: SQL query to run.
+        :param request_timeout: The timeout before the request fails.
+        :param runtime_mappings: Defines one or more runtime fields in the search request.
+            These fields take precedence over mapped fields with the same name.
+        :param time_zone: ISO-8601 time zone ID for the search.
+        :param wait_for_completion_timeout: Period to wait for complete results. Defaults
+            to no timeout, meaning the request waits for complete search results. If
+            the search doesn’t finish within this period, the search becomes async.
+        """
+        __path = "/_sql"
         __query: t.Dict[str, t.Any] = {}
-        if completion_fields is not None:
-            __query["completion_fields"] = completion_fields
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if fielddata_fields is not None:
-            __query["fielddata_fields"] = fielddata_fields
-        if fields is not None:
-            __query["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if groups is not None:
-            __query["groups"] = groups
+        if format is not None:
+            __query["format"] = format
         if human is not None:
             __query["human"] = human
-        if include_segment_file_sizes is not None:
-            __query["include_segment_file_sizes"] = include_segment_file_sizes
-        if include_unloaded_segments is not None:
-            __query["include_unloaded_segments"] = include_unloaded_segments
-        if level is not None:
-            __query["level"] = level
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if types is not None:
-            __query["types"] = types
-        __headers = {"accept": "application/json"}
+        if not __body:
+            if catalog is not None:
+                __body["catalog"] = catalog
+            if columnar is not None:
+                __body["columnar"] = columnar
+            if cursor is not None:
+                __body["cursor"] = cursor
+            if fetch_size is not None:
+                __body["fetch_size"] = fetch_size
+            if field_multi_value_leniency is not None:
+                __body["field_multi_value_leniency"] = field_multi_value_leniency
+            if filter is not None:
+                __body["filter"] = filter
+            if index_using_frozen is not None:
+                __body["index_using_frozen"] = index_using_frozen
+            if keep_alive is not None:
+                __body["keep_alive"] = keep_alive
+            if keep_on_completion is not None:
+                __body["keep_on_completion"] = keep_on_completion
+            if page_timeout is not None:
+                __body["page_timeout"] = page_timeout
+            if params is not None:
+                __body["params"] = params
+            if query is not None:
+                __body["query"] = query
+            if request_timeout is not None:
+                __body["request_timeout"] = request_timeout
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if time_zone is not None:
+                __body["time_zone"] = time_zone
+            if wait_for_completion_timeout is not None:
+                __body["wait_for_completion_timeout"] = wait_for_completion_timeout
+        __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters()
-    async def usage(
+    @_rewrite_parameters(
+        body_fields=("query", "fetch_size", "filter", "time_zone"),
+    )
+    async def translate(
         self,
         *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        metric: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        query: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fetch_size: t.Optional[int] = None,
+        filter: t.Optional[t.Mapping[str, t.Any]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        time_zone: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns low-level information about REST actions usage on nodes.
+        Translates SQL into Elasticsearch queries
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/cluster-nodes-usage.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/sql-translate-api.html>`_
 
-        :param node_id: A comma-separated list of node IDs or names to limit the returned
-            information; use `_local` to return information from the node you're connecting
-            to, leave empty to get information from all nodes
-        :param metric: Limit the information returned to the specified metrics
-        :param timeout: Explicit operation timeout
-        """
-        if node_id not in SKIP_IN_PATH and metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/usage/{_quote(metric)}"
-        elif node_id not in SKIP_IN_PATH:
-            __path = f"/_nodes/{_quote(node_id)}/usage"
-        elif metric not in SKIP_IN_PATH:
-            __path = f"/_nodes/usage/{_quote(metric)}"
-        else:
-            __path = "/_nodes/usage"
+        :param query: SQL query to run.
+        :param fetch_size: The maximum number of rows (or entries) to return in one response.
+        :param filter: Elasticsearch query DSL for additional filtering.
+        :param time_zone: ISO-8601 time zone ID for the search.
+        """
+        if query is None and body is None:
+            raise ValueError("Empty value passed for parameter 'query'")
+        __path = "/_sql/translate"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
+        if not __body:
+            if query is not None:
+                __body["query"] = query
+            if fetch_size is not None:
+                __body["fetch_size"] = fetch_size
+            if filter is not None:
+                __body["filter"] = filter
+            if time_zone is not None:
+                __body["time_zone"] = time_zone
+        __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/query_ruleset.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/query_ruleset.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class QueryRulesetClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def delete(
         self,
         *,
         ruleset_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a query ruleset.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-query-ruleset.html>`_
@@ -62,17 +61,15 @@
 
     @_rewrite_parameters()
     async def get(
         self,
         *,
         ruleset_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the details about a query ruleset.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-query-ruleset.html>`_
@@ -99,17 +96,15 @@
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     async def list(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Lists query rulesets.
@@ -135,53 +130,51 @@
             __query["size"] = size
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("rules",),
     )
     async def put(
         self,
         *,
         ruleset_id: str,
-        rules: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        rules: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a query ruleset.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-query-ruleset.html>`_
 
         :param ruleset_id: The unique identifier of the query ruleset to be created or
             updated
         :param rules:
         """
         if ruleset_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'ruleset_id'")
-        if rules is None:
+        if rules is None and body is None:
             raise ValueError("Empty value passed for parameter 'rules'")
         __path = f"/_query_rules/{_quote(ruleset_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if rules is not None:
-            __body["rules"] = rules
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if rules is not None:
+                __body["rules"] = rules
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/rollup.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/eql.py`

 * *Files 25% similar despite different names*

```diff
@@ -19,37 +19,39 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class RollupClient(NamespacedClient):
+class EqlClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete_job(
+    async def delete(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes an existing rollup job.
+        Deletes an async EQL search by ID. If the search is still running, the search
+        request will be cancelled. Otherwise, the saved search results are deleted.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-delete-job.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/eql-search-api.html>`_
 
-        :param id: The ID of the job to delete
+        :param id: Identifier for the search to delete. A search ID is provided in the
+            EQL search API's response for an async search. A search ID is also provided
+            if the request’s `keep_on_completion` parameter is `true`.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_rollup/job/{_quote(id)}"
+        __path = f"/_eql/search/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
@@ -57,114 +59,82 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_jobs(
+    async def get(
         self,
         *,
-        id: t.Optional[str] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Retrieves the configuration, stats, and status of rollup jobs.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-get-job.html>`_
-
-        :param id: The ID of the job(s) to fetch. Accepts glob patterns, or left blank
-            for all jobs
-        """
-        if id not in SKIP_IN_PATH:
-            __path = f"/_rollup/job/{_quote(id)}"
-        else:
-            __path = "/_rollup/job"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    async def get_rollup_caps(
-        self,
-        *,
-        id: t.Optional[str] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        wait_for_completion_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns the capabilities of any rollup jobs that have been configured for a specific
-        index or index pattern.
+        Returns async results from previously executed Event Query Language (EQL) search
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-get-rollup-caps.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-eql-search-api.html>`_
 
-        :param id: The ID of the index to check rollup capabilities on, or left blank
-            for all jobs
+        :param id: Identifier for the search.
+        :param keep_alive: Period for which the search and its results are stored on
+            the cluster. Defaults to the keep_alive value set by the search’s EQL search
+            API request.
+        :param wait_for_completion_timeout: Timeout duration to wait for the request
+            to finish. Defaults to no timeout, meaning the request waits for complete
+            search results.
         """
-        if id not in SKIP_IN_PATH:
-            __path = f"/_rollup/data/{_quote(id)}"
-        else:
-            __path = "/_rollup/data"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_eql/search/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
+        if keep_alive is not None:
+            __query["keep_alive"] = keep_alive
         if pretty is not None:
             __query["pretty"] = pretty
+        if wait_for_completion_timeout is not None:
+            __query["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_rollup_index_caps(
+    async def get_status(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns the rollup capabilities of all jobs inside of a rollup index (e.g. the
-        index where rollup data is stored).
+        Returns the status of a previously submitted async or stored Event Query Language
+        (EQL) search
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-get-rollup-index-caps.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-eql-status-api.html>`_
 
-        :param index: The rollup index or index pattern to obtain rollup capabilities
-            from.
+        :param id: Identifier for the search.
         """
-        if index in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_rollup/data"
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_eql/search/status/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
@@ -172,269 +142,149 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
-        ignore_deprecated_options={"headers"},
+        body_fields=(
+            "query",
+            "case_sensitive",
+            "event_category_field",
+            "fetch_size",
+            "fields",
+            "filter",
+            "keep_alive",
+            "keep_on_completion",
+            "result_position",
+            "runtime_mappings",
+            "size",
+            "tiebreaker_field",
+            "timestamp_field",
+            "wait_for_completion_timeout",
+        ),
     )
-    async def put_job(
+    async def search(
         self,
         *,
-        id: str,
-        cron: str,
-        groups: t.Mapping[str, t.Any],
-        index_pattern: str,
-        page_size: int,
-        rollup_index: str,
+        index: t.Union[str, t.Sequence[str]],
+        query: t.Optional[str] = None,
+        allow_no_indices: t.Optional[bool] = None,
+        case_sensitive: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        event_category_field: t.Optional[str] = None,
+        expand_wildcards: t.Optional[
+            t.Union[
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
+                ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
+            ]
         ] = None,
-        headers: t.Optional[
-            t.Mapping[str, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
+        fetch_size: t.Optional[int] = None,
+        fields: t.Optional[
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
-        human: t.Optional[bool] = None,
-        metrics: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Creates a rollup job.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-put-job.html>`_
-
-        :param id: Identifier for the rollup job. This can be any alphanumeric string
-            and uniquely identifies the data that is associated with the rollup job.
-            The ID is persistent; it is stored with the rolled up data. If you create
-            a job, let it run for a while, then delete the job, the data that the job
-            rolled up is still be associated with this job ID. You cannot create a new
-            job with the same ID since that could lead to problems with mismatched job
-            configurations.
-        :param cron: A cron string which defines the intervals when the rollup job should
-            be executed. When the interval triggers, the indexer attempts to rollup the
-            data in the index pattern. The cron pattern is unrelated to the time interval
-            of the data being rolled up. For example, you may wish to create hourly rollups
-            of your document but to only run the indexer on a daily basis at midnight,
-            as defined by the cron. The cron pattern is defined just like a Watcher cron
-            schedule.
-        :param groups: Defines the grouping fields and aggregations that are defined
-            for this rollup job. These fields will then be available later for aggregating
-            into buckets. These aggs and fields can be used in any combination. Think
-            of the groups configuration as defining a set of tools that can later be
-            used in aggregations to partition the data. Unlike raw data, we have to think
-            ahead to which fields and aggregations might be used. Rollups provide enough
-            flexibility that you simply need to determine which fields are needed, not
-            in what order they are needed.
-        :param index_pattern: The index or index pattern to roll up. Supports wildcard-style
-            patterns (`logstash-*`). The job attempts to rollup the entire index or index-pattern.
-        :param page_size: The number of bucket results that are processed on each iteration
-            of the rollup indexer. A larger value tends to execute faster, but requires
-            more memory during processing. This value has no effect on how the data is
-            rolled up; it is merely used for tweaking the speed or memory cost of the
-            indexer.
-        :param rollup_index: The index that contains the rollup results. The index can
-            be shared with other rollup jobs. The data is stored so that it doesn’t interfere
-            with unrelated jobs.
-        :param headers:
-        :param metrics: Defines the metrics to collect for each grouping tuple. By default,
-            only the doc_counts are collected for each group. To make rollup useful,
-            you will often add metrics like averages, mins, maxes, etc. Metrics are defined
-            on a per-field basis and for each field you configure which metric should
-            be collected.
-        :param timeout: Time to wait for the request to complete.
-        """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        if cron is None:
-            raise ValueError("Empty value passed for parameter 'cron'")
-        if groups is None:
-            raise ValueError("Empty value passed for parameter 'groups'")
-        if index_pattern is None:
-            raise ValueError("Empty value passed for parameter 'index_pattern'")
-        if page_size is None:
-            raise ValueError("Empty value passed for parameter 'page_size'")
-        if rollup_index is None:
-            raise ValueError("Empty value passed for parameter 'rollup_index'")
-        __path = f"/_rollup/job/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
-        __query: t.Dict[str, t.Any] = {}
-        if cron is not None:
-            __body["cron"] = cron
-        if groups is not None:
-            __body["groups"] = groups
-        if index_pattern is not None:
-            __body["index_pattern"] = index_pattern
-        if page_size is not None:
-            __body["page_size"] = page_size
-        if rollup_index is not None:
-            __body["rollup_index"] = rollup_index
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if headers is not None:
-            __body["headers"] = headers
-        if human is not None:
-            __query["human"] = human
-        if metrics is not None:
-            __body["metrics"] = metrics
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
-        __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
-        )
-
-    @_rewrite_parameters(
-        body_fields=True,
-    )
-    async def rollup_search(
-        self,
-        *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
-        aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        filter: t.Optional[
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        ignore_unavailable: t.Optional[bool] = None,
+        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        keep_on_completion: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        query: t.Optional[t.Mapping[str, t.Any]] = None,
-        rest_total_hits_as_int: t.Optional[bool] = None,
+        result_position: t.Optional[t.Union["t.Literal['head', 'tail']", str]] = None,
+        runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         size: t.Optional[int] = None,
-        typed_keys: t.Optional[bool] = None,
+        tiebreaker_field: t.Optional[str] = None,
+        timestamp_field: t.Optional[str] = None,
+        wait_for_completion_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
+        ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Enables searching rolled-up data using the standard query DSL.
+        Returns results matching a query expressed in Event Query Language (EQL)
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-search.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/eql-search-api.html>`_
 
-        :param index: The indices or index-pattern(s) (containing rollup or regular data)
-            that should be searched
-        :param aggregations:
-        :param aggs:
-        :param query:
-        :param rest_total_hits_as_int: Indicates whether hits.total should be rendered
-            as an integer or an object in the rest search response
-        :param size: Must be zero if set, as rollups work on pre-aggregated data
-        :param typed_keys: Specify whether aggregation and suggester names should be
-            prefixed by their respective types in the response
+        :param index: The name of the index to scope the operation
+        :param query: EQL query you wish to run.
+        :param allow_no_indices:
+        :param case_sensitive:
+        :param event_category_field: Field containing the event classification, such
+            as process, file, or network.
+        :param expand_wildcards:
+        :param fetch_size: Maximum number of events to search at a time for sequence
+            queries.
+        :param fields: Array of wildcard (*) patterns. The response returns values for
+            field names matching these patterns in the fields property of each hit.
+        :param filter: Query, written in Query DSL, used to filter the events on which
+            the EQL query runs.
+        :param ignore_unavailable: If true, missing or closed indices are not included
+            in the response.
+        :param keep_alive:
+        :param keep_on_completion:
+        :param result_position:
+        :param runtime_mappings:
+        :param size: For basic queries, the maximum number of matching events to return.
+            Defaults to 10
+        :param tiebreaker_field: Field used to sort hits with the same timestamp in ascending
+            order
+        :param timestamp_field: Field containing event timestamp. Default "@timestamp"
+        :param wait_for_completion_timeout:
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/{_quote(index)}/_rollup_search"
-        __body: t.Dict[str, t.Any] = {}
+        if query is None and body is None:
+            raise ValueError("Empty value passed for parameter 'query'")
+        __path = f"/{_quote(index)}/_eql/search"
         __query: t.Dict[str, t.Any] = {}
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
-        if aggs is not None:
-            __body["aggs"] = aggs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
+        if allow_no_indices is not None:
+            __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
+        if expand_wildcards is not None:
+            __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
+        if ignore_unavailable is not None:
+            __query["ignore_unavailable"] = ignore_unavailable
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if rest_total_hits_as_int is not None:
-            __query["rest_total_hits_as_int"] = rest_total_hits_as_int
-        if size is not None:
-            __body["size"] = size
-        if typed_keys is not None:
-            __query["typed_keys"] = typed_keys
+        if not __body:
+            if query is not None:
+                __body["query"] = query
+            if case_sensitive is not None:
+                __body["case_sensitive"] = case_sensitive
+            if event_category_field is not None:
+                __body["event_category_field"] = event_category_field
+            if fetch_size is not None:
+                __body["fetch_size"] = fetch_size
+            if fields is not None:
+                __body["fields"] = fields
+            if filter is not None:
+                __body["filter"] = filter
+            if keep_alive is not None:
+                __body["keep_alive"] = keep_alive
+            if keep_on_completion is not None:
+                __body["keep_on_completion"] = keep_on_completion
+            if result_position is not None:
+                __body["result_position"] = result_position
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if size is not None:
+                __body["size"] = size
+            if tiebreaker_field is not None:
+                __body["tiebreaker_field"] = tiebreaker_field
+            if timestamp_field is not None:
+                __body["timestamp_field"] = timestamp_field
+            if wait_for_completion_timeout is not None:
+                __body["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
-
-    @_rewrite_parameters()
-    async def start_job(
-        self,
-        *,
-        id: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Starts an existing, stopped rollup job.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-start-job.html>`_
-
-        :param id: The ID of the job to start
-        """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_rollup/job/{_quote(id)}/_start"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    async def stop_job(
-        self,
-        *,
-        id: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        wait_for_completion: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Stops an existing, started rollup job.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/rollup-stop-job.html>`_
-
-        :param id: The ID of the job to stop
-        :param timeout: Block for (at maximum) the specified duration while waiting for
-            the job to stop. Defaults to 30s.
-        :param wait_for_completion: True if the API should block until the job has fully
-            stopped, false if should be executed async. Defaults to false.
-        """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_rollup/job/{_quote(id)}/_stop"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if wait_for_completion is not None:
-            __query["wait_for_completion"] = wait_for_completion
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
-        )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/search_application.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/search_application.py`

 * *Files 8% similar despite different names*

```diff
@@ -20,30 +20,29 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class SearchApplicationClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def delete(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a search application.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-search-application.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-search-application.html>`_
 
         :param name: The name of the search application to delete
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_application/search_application/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
@@ -62,17 +61,15 @@
 
     @_rewrite_parameters()
     async def delete_behavioral_analytics(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Delete a behavioral analytics collection.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-analytics-collection.html>`_
@@ -98,17 +95,15 @@
 
     @_rewrite_parameters()
     async def get(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the details about a search application.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-search-application.html>`_
@@ -132,19 +127,17 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     async def get_behavioral_analytics(
         self,
         *,
-        name: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        name: t.Optional[t.Sequence[str]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the existing behavioral analytics collections.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/list-analytics-collection.html>`_
@@ -172,17 +165,15 @@
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     async def list(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -218,20 +209,19 @@
     @_rewrite_parameters(
         body_name="search_application",
     )
     async def put(
         self,
         *,
         name: str,
-        search_application: t.Mapping[str, t.Any],
+        search_application: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         create: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a search application.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-search-application.html>`_
@@ -239,43 +229,45 @@
         :param name: The name of the search application to be created or updated.
         :param search_application:
         :param create: If `true`, this request cannot replace or update existing Search
             Applications.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
-        if search_application is None:
-            raise ValueError("Empty value passed for parameter 'search_application'")
+        if search_application is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'search_application' and 'body', one of them should be set."
+            )
+        elif search_application is not None and body is not None:
+            raise ValueError("Cannot set both 'search_application' and 'body'")
         __path = f"/_application/search_application/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if create is not None:
             __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = search_application
+        __body = search_application if search_application is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     async def put_behavioral_analytics(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a behavioral analytics collection.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-analytics-collection.html>`_
@@ -296,54 +288,54 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("params",),
         ignore_deprecated_options={"params"},
     )
     async def search(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         params: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Perform a search against a search application
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-application-search.html>`_
 
         :param name: The name of the search application to be searched.
         :param params: Query parameters specific to this request, which will override
             any defaults specified in the template.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_application/search_application/{_quote(name)}/_search"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if params is not None:
-            __body["params"] = params
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if params is not None:
+                __body["params"] = params
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/searchable_snapshots.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/ingest.py`

 * *Files 15% similar despite different names*

```diff
@@ -19,247 +19,276 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class SearchableSnapshotsClient(NamespacedClient):
+class IngestClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def cache_stats(
+    def delete_pipeline(
         self,
         *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        human: t.Optional[bool] = None,
+        master_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        pretty: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+    ) -> ObjectApiResponse[t.Any]:
+        """
+        Deletes a pipeline.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-pipeline-api.html>`_
+
+        :param id: Pipeline ID or wildcard expression of pipeline IDs used to limit the
+            request. To delete all ingest pipelines in a cluster, use a value of `*`.
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_ingest/pipeline/{_quote(id)}"
+        __query: t.Dict[str, t.Any] = {}
+        if error_trace is not None:
+            __query["error_trace"] = error_trace
+        if filter_path is not None:
+            __query["filter_path"] = filter_path
+        if human is not None:
+            __query["human"] = human
+        if master_timeout is not None:
+            __query["master_timeout"] = master_timeout
+        if pretty is not None:
+            __query["pretty"] = pretty
+        if timeout is not None:
+            __query["timeout"] = timeout
+        __headers = {"accept": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
+        )
+
+    @_rewrite_parameters()
+    def get_pipeline(
+        self,
+        *,
+        id: t.Optional[str] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
+        summary: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieve node-level cache statistics about searchable snapshots.
+        Returns a pipeline.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-apis.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-pipeline-api.html>`_
 
-        :param node_id: A comma-separated list of node IDs or names to limit the returned
-            information; use `_local` to return information from the node you're connecting
-            to, leave empty to get information from all nodes
-        :param master_timeout:
+        :param id: Comma-separated list of pipeline IDs to retrieve. Wildcard (`*`) expressions
+            are supported. To get all ingest pipelines, omit this parameter or use `*`.
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        :param summary: Return pipelines without their definitions (default: false)
         """
-        if node_id not in SKIP_IN_PATH:
-            __path = f"/_searchable_snapshots/{_quote(node_id)}/cache/stats"
+        if id not in SKIP_IN_PATH:
+            __path = f"/_ingest/pipeline/{_quote(id)}"
         else:
-            __path = "/_searchable_snapshots/cache/stats"
+            __path = "/_ingest/pipeline"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
+        if summary is not None:
+            __query["summary"] = summary
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def clear_cache(
+    def processor_grok(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        expand_wildcards: t.Optional[
-            t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
-                ],
-            ]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ignore_unavailable: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Clear the cache of searchable snapshots.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-apis.html>`_
+        Returns a list of the built-in patterns.
 
-        :param index: A comma-separated list of index names
-        :param allow_no_indices: Whether to ignore if a wildcard indices expression resolves
-            into no concrete indices. (This includes `_all` string or when no indices
-            have been specified)
-        :param expand_wildcards: Whether to expand wildcard expression to concrete indices
-            that are open, closed or both.
-        :param ignore_unavailable: Whether specified concrete indices should be ignored
-            when unavailable (missing or closed)
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/grok-processor.html>`_
         """
-        if index not in SKIP_IN_PATH:
-            __path = f"/{_quote(index)}/_searchable_snapshots/cache/clear"
-        else:
-            __path = "/_searchable_snapshots/cache/clear"
+        __path = "/_ingest/processor/grok"
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_indices is not None:
-            __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if expand_wildcards is not None:
-            __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ignore_unavailable is not None:
-            __query["ignore_unavailable"] = ignore_unavailable
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("description", "meta", "on_failure", "processors", "version"),
+        parameter_aliases={"_meta": "meta"},
     )
-    async def mount(
+    def put_pipeline(
         self,
         *,
-        repository: str,
-        snapshot: str,
-        index: str,
+        id: str,
+        description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ignore_index_settings: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
-        index_settings: t.Optional[t.Mapping[str, t.Any]] = None,
+        if_version: t.Optional[int] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        meta: t.Optional[t.Mapping[str, t.Any]] = None,
+        on_failure: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         pretty: t.Optional[bool] = None,
-        renamed_index: t.Optional[str] = None,
-        storage: t.Optional[str] = None,
-        wait_for_completion: t.Optional[bool] = None,
+        processors: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Mount a snapshot as a searchable index.
+        Creates or updates a pipeline.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-api-mount-snapshot.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ingest.html>`_
 
-        :param repository: The name of the repository containing the snapshot of the
-            index to mount
-        :param snapshot: The name of the snapshot of the index to mount
-        :param index:
-        :param ignore_index_settings:
-        :param index_settings:
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param renamed_index:
-        :param storage: Selects the kind of local storage used to accelerate searches.
-            Experimental, and defaults to `full_copy`
-        :param wait_for_completion: Should this request wait until the operation has
-            completed before returning
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        if index is None:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}/_mount"
-        __body: t.Dict[str, t.Any] = {}
+        :param id: ID of the ingest pipeline to create or update.
+        :param description: Description of the ingest pipeline.
+        :param if_version: Required version for optimistic concurrency control for pipeline
+            updates
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        :param meta: Optional metadata about the ingest pipeline. May have any contents.
+            This map is not automatically generated by Elasticsearch.
+        :param on_failure: Processors to run immediately after a processor failure. Each
+            processor supports a processor-level `on_failure` value. If a processor without
+            an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter
+            as a fallback. The processors in this parameter run sequentially in the order
+            specified. Elasticsearch will not attempt to run the pipeline's remaining
+            processors.
+        :param processors: Processors used to perform transformations on documents before
+            indexing. Processors run sequentially in the order specified.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        :param version: Version number used by external systems to track ingest pipelines.
+            This parameter is intended for external systems only. Elasticsearch does
+            not use or validate pipeline version numbers.
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_ingest/pipeline/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        if index is not None:
-            __body["index"] = index
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ignore_index_settings is not None:
-            __body["ignore_index_settings"] = ignore_index_settings
-        if index_settings is not None:
-            __body["index_settings"] = index_settings
+        if if_version is not None:
+            __query["if_version"] = if_version
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if renamed_index is not None:
-            __body["renamed_index"] = renamed_index
-        if storage is not None:
-            __query["storage"] = storage
-        if wait_for_completion is not None:
-            __query["wait_for_completion"] = wait_for_completion
+        if timeout is not None:
+            __query["timeout"] = timeout
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if meta is not None:
+                __body["_meta"] = meta
+            if on_failure is not None:
+                __body["on_failure"] = on_failure
+            if processors is not None:
+                __body["processors"] = processors
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+        return self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters()
-    async def stats(
+    @_rewrite_parameters(
+        body_fields=("docs", "pipeline"),
+    )
+    def simulate(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        id: t.Optional[str] = None,
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        level: t.Optional[
-            t.Union["t.Literal['cluster', 'indices', 'shards']", str]
-        ] = None,
+        pipeline: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        verbose: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieve shard-level statistics about searchable snapshots.
+        Allows to simulate a pipeline with example documents.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-apis.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html>`_
 
-        :param index: A comma-separated list of index names
-        :param level: Return stats aggregated at cluster, index or shard level
+        :param id: Pipeline to test. If you don’t specify a `pipeline` in the request
+            body, this parameter is required.
+        :param docs: Sample documents to test in the pipeline.
+        :param pipeline: Pipeline to test. If you don’t specify the `pipeline` request
+            path parameter, this parameter is required. If you specify both this and
+            the request path parameter, the API only uses the request path parameter.
+        :param verbose: If `true`, the response includes output data for each processor
+            in the executed pipeline.
         """
-        if index not in SKIP_IN_PATH:
-            __path = f"/{_quote(index)}/_searchable_snapshots/stats"
+        if id not in SKIP_IN_PATH:
+            __path = f"/_ingest/pipeline/{_quote(id)}/_simulate"
         else:
-            __path = "/_searchable_snapshots/stats"
+            __path = "/_ingest/pipeline/_simulate"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if level is not None:
-            __query["level"] = level
         if pretty is not None:
             __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        if verbose is not None:
+            __query["verbose"] = verbose
+        if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if pipeline is not None:
+                __body["pipeline"] = pipeline
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/security.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/security.py`

 * *Files 11% similar despite different names*

```diff
@@ -20,22 +20,21 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class SecurityClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def authenticate(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Enables authentication as a user and retrieve information about the authenticated
         user.
 
@@ -53,32 +52,31 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("expiration", "metadata", "name", "role_descriptors"),
     )
     async def create_api_key(
         self,
         *,
         error_trace: t.Optional[bool] = None,
         expiration: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         metadata: t.Optional[t.Mapping[str, t.Any]] = None,
         name: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         role_descriptors: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates an API key for access without requiring basic authentication.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-create-api-key.html>`_
 
         :param expiration: Expiration time for the API key. By default, API keys never
@@ -97,60 +95,66 @@
             be an intersection of API keys permissions and authenticated user’s permissions
             thereby limiting the access scope for API keys. The structure of role descriptor
             is the same as the request for create role API. For more details, see create
             or update roles API.
         """
         __path = "/_security/api_key"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if expiration is not None:
-            __body["expiration"] = expiration
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if metadata is not None:
-            __body["metadata"] = metadata
-        if name is not None:
-            __body["name"] = name
         if pretty is not None:
             __query["pretty"] = pretty
         if refresh is not None:
             __query["refresh"] = refresh
-        if role_descriptors is not None:
-            __body["role_descriptors"] = role_descriptors
+        if not __body:
+            if expiration is not None:
+                __body["expiration"] = expiration
+            if metadata is not None:
+                __body["metadata"] = metadata
+            if name is not None:
+                __body["name"] = name
+            if role_descriptors is not None:
+                __body["role_descriptors"] = role_descriptors
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     async def get_api_key(
         self,
         *,
+        active_only: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         id: t.Optional[str] = None,
         name: t.Optional[str] = None,
         owner: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         realm_name: t.Optional[str] = None,
         username: t.Optional[str] = None,
         with_limited_by: t.Optional[bool] = None,
+        with_profile_uid: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves information for one or more API keys.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-get-api-key.html>`_
 
+        :param active_only: A boolean flag that can be used to query API keys that are
+            currently active. An API key is considered active if it is neither invalidated,
+            nor expired at query time. You can specify this together with other parameters
+            such as `owner` or `name`. If `active_only` is false, the response will include
+            both active and inactive (expired or invalidated) keys.
         :param id: An API key id. This parameter cannot be used with any of `name`, `realm_name`
             or `username`.
         :param name: An API key name. This parameter cannot be used with any of `id`,
             `realm_name` or `username`. It supports prefix search with wildcard.
         :param owner: A boolean flag that can be used to query API keys owned by the
             currently authenticated user. The `realm_name` or `username` parameters cannot
             be specified when this parameter is set to `true` as they are assumed to
@@ -158,17 +162,21 @@
         :param realm_name: The name of an authentication realm. This parameter cannot
             be used with either `id` or `name` or when `owner` flag is set to `true`.
         :param username: The username of a user. This parameter cannot be used with either
             `id` or `name` or when `owner` flag is set to `true`.
         :param with_limited_by: Return the snapshot of the owner user's role descriptors
             associated with the API key. An API key's actual permission is the intersection
             of its assigned role descriptors and the owner user's role descriptors.
+        :param with_profile_uid: Determines whether to also retrieve the profile uid,
+            for the API key owner principal, if it exists.
         """
         __path = "/_security/api_key"
         __query: t.Dict[str, t.Any] = {}
+        if active_only is not None:
+            __query["active_only"] = active_only
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if id is not None:
@@ -181,55 +189,43 @@
             __query["pretty"] = pretty
         if realm_name is not None:
             __query["realm_name"] = realm_name
         if username is not None:
             __query["username"] = username
         if with_limited_by is not None:
             __query["with_limited_by"] = with_limited_by
+        if with_profile_uid is not None:
+            __query["with_profile_uid"] = with_profile_uid
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("application", "cluster", "index"),
     )
     async def has_privileges(
         self,
         *,
         user: t.Optional[str] = None,
-        application: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        application: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         cluster: t.Optional[
-            t.Union[
-                t.List[
-                    t.Union[
-                        "t.Literal['all', 'cancel_task', 'create_snapshot', 'grant_api_key', 'manage', 'manage_api_key', 'manage_ccr', 'manage_enrich', 'manage_ilm', 'manage_index_templates', 'manage_ingest_pipelines', 'manage_logstash_pipelines', 'manage_ml', 'manage_oidc', 'manage_own_api_key', 'manage_pipeline', 'manage_rollup', 'manage_saml', 'manage_security', 'manage_service_account', 'manage_slm', 'manage_token', 'manage_transform', 'manage_user_profile', 'manage_watcher', 'monitor', 'monitor_ml', 'monitor_rollup', 'monitor_snapshot', 'monitor_text_structure', 'monitor_transform', 'monitor_watcher', 'read_ccr', 'read_ilm', 'read_pipeline', 'read_slm', 'transport_client']",
-                        str,
-                    ]
-                ],
-                t.Tuple[
-                    t.Union[
-                        "t.Literal['all', 'cancel_task', 'create_snapshot', 'grant_api_key', 'manage', 'manage_api_key', 'manage_ccr', 'manage_enrich', 'manage_ilm', 'manage_index_templates', 'manage_ingest_pipelines', 'manage_logstash_pipelines', 'manage_ml', 'manage_oidc', 'manage_own_api_key', 'manage_pipeline', 'manage_rollup', 'manage_saml', 'manage_security', 'manage_service_account', 'manage_slm', 'manage_token', 'manage_transform', 'manage_user_profile', 'manage_watcher', 'monitor', 'monitor_ml', 'monitor_rollup', 'monitor_snapshot', 'monitor_text_structure', 'monitor_transform', 'monitor_watcher', 'read_ccr', 'read_ilm', 'read_pipeline', 'read_slm', 'transport_client']",
-                        str,
-                    ],
-                    ...,
-                ],
+            t.Sequence[
+                t.Union[
+                    "t.Literal['all', 'cancel_task', 'create_snapshot', 'grant_api_key', 'manage', 'manage_api_key', 'manage_ccr', 'manage_enrich', 'manage_ilm', 'manage_index_templates', 'manage_ingest_pipelines', 'manage_logstash_pipelines', 'manage_ml', 'manage_oidc', 'manage_own_api_key', 'manage_pipeline', 'manage_rollup', 'manage_saml', 'manage_security', 'manage_service_account', 'manage_slm', 'manage_token', 'manage_transform', 'manage_user_profile', 'manage_watcher', 'monitor', 'monitor_ml', 'monitor_rollup', 'monitor_snapshot', 'monitor_text_structure', 'monitor_transform', 'monitor_watcher', 'read_ccr', 'read_ilm', 'read_pipeline', 'read_slm', 'transport_client']",
+                    str,
+                ]
             ]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        index: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        index: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Determines whether the specified user has a specified list of privileges.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-has-privileges.html>`_
 
         :param user: Username
@@ -237,53 +233,53 @@
         :param cluster: A list of the cluster privileges that you want to check.
         :param index:
         """
         if user not in SKIP_IN_PATH:
             __path = f"/_security/user/{_quote(user)}/_has_privileges"
         else:
             __path = "/_security/user/_has_privileges"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if application is not None:
-            __body["application"] = application
-        if cluster is not None:
-            __body["cluster"] = cluster
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index is not None:
-            __body["index"] = index
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if application is not None:
+                __body["application"] = application
+            if cluster is not None:
+                __body["cluster"] = cluster
+            if index is not None:
+                __body["index"] = index
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("id", "ids", "name", "owner", "realm_name", "username"),
     )
     async def invalidate_api_key(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         id: t.Optional[str] = None,
-        ids: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        ids: t.Optional[t.Sequence[str]] = None,
         name: t.Optional[str] = None,
         owner: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         realm_name: t.Optional[str] = None,
         username: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Invalidates one or more API keys.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-invalidate-api-key.html>`_
 
         :param id:
@@ -298,99 +294,124 @@
         :param realm_name: The name of an authentication realm. This parameter cannot
             be used with either `ids` or `name`, or when `owner` flag is set to `true`.
         :param username: The username of a user. This parameter cannot be used with either
             `ids` or `name`, or when `owner` flag is set to `true`.
         """
         __path = "/_security/api_key"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if id is not None:
-            __body["id"] = id
-        if ids is not None:
-            __body["ids"] = ids
-        if name is not None:
-            __body["name"] = name
-        if owner is not None:
-            __body["owner"] = owner
         if pretty is not None:
             __query["pretty"] = pretty
-        if realm_name is not None:
-            __body["realm_name"] = realm_name
-        if username is not None:
-            __body["username"] = username
+        if not __body:
+            if id is not None:
+                __body["id"] = id
+            if ids is not None:
+                __body["ids"] = ids
+            if name is not None:
+                __body["name"] = name
+            if owner is not None:
+                __body["owner"] = owner
+            if realm_name is not None:
+                __body["realm_name"] = realm_name
+            if username is not None:
+                __body["username"] = username
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "aggs",
+            "from_",
+            "query",
+            "search_after",
+            "size",
+            "sort",
+        ),
         parameter_aliases={"from": "from_"},
     )
     async def query_api_keys(
         self,
         *,
+        aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         search_after: t.Optional[
-            t.Union[
-                t.List[t.Union[None, bool, float, int, str, t.Any]],
-                t.Tuple[t.Union[None, bool, float, int, str, t.Any], ...],
-            ]
+            t.Sequence[t.Union[None, bool, float, int, str, t.Any]]
         ] = None,
         size: t.Optional[int] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
+        typed_keys: t.Optional[bool] = None,
         with_limited_by: t.Optional[bool] = None,
+        with_profile_uid: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves information for API keys using a subset of query DSL
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-query-api-key.html>`_
 
+        :param aggregations: Any aggregations to run over the corpus of returned API
+            keys. Aggregations and queries work together. Aggregations are computed only
+            on the API keys that match the query. This supports only a subset of aggregation
+            types, namely: `terms`, `range`, `date_range`, `missing`, `cardinality`,
+            `value_count`, `composite`, `filter`, and `filters`. Additionally, aggregations
+            only run over the same subset of fields that query works with.
+        :param aggs: Any aggregations to run over the corpus of returned API keys. Aggregations
+            and queries work together. Aggregations are computed only on the API keys
+            that match the query. This supports only a subset of aggregation types, namely:
+            `terms`, `range`, `date_range`, `missing`, `cardinality`, `value_count`,
+            `composite`, `filter`, and `filters`. Additionally, aggregations only run
+            over the same subset of fields that query works with.
         :param from_: Starting document offset. By default, you cannot page through more
             than 10,000 hits using the from and size parameters. To page through more
             hits, use the `search_after` parameter.
-        :param query: A query to filter which API keys to return. The query supports
-            a subset of query types, including `match_all`, `bool`, `term`, `terms`,
-            `ids`, `prefix`, `wildcard`, and `range`. You can query all public information
-            associated with an API key.
+        :param query: A query to filter which API keys to return. If the query parameter
+            is missing, it is equivalent to a `match_all` query. The query supports a
+            subset of query types, including `match_all`, `bool`, `term`, `terms`, `match`,
+            `ids`, `prefix`, `wildcard`, `exists`, `range`, and `simple_query_string`.
+            You can query the following public information associated with an API key:
+            `id`, `type`, `name`, `creation`, `expiration`, `invalidated`, `invalidation`,
+            `username`, `realm`, and `metadata`.
         :param search_after: Search after definition
         :param size: The number of hits to return. By default, you cannot page through
             more than 10,000 hits using the `from` and `size` parameters. To page through
             more hits, use the `search_after` parameter.
         :param sort: Other than `id`, all public fields of an API key are eligible for
             sorting. In addition, sort can also be applied to the `_doc` field to sort
             by index order.
+        :param typed_keys: Determines whether aggregation names are prefixed by their
+            respective types in the response.
         :param with_limited_by: Return the snapshot of the owner user's role descriptors
             associated with the API key. An API key's actual permission is the intersection
             of its assigned role descriptors and the owner user's role descriptors.
+        :param with_profile_uid: Determines whether to also retrieve the profile uid,
+            for the API key owner principal, if it exists.
         """
         __path = "/_security/_query/api_key"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
@@ -398,61 +419,71 @@
         ):
             __query["sort"] = sort
             sort = None
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_ is not None:
-            __body["from"] = from_
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if search_after is not None:
-            __body["search_after"] = search_after
-        if size is not None:
-            __body["size"] = size
-        if sort is not None:
-            __body["sort"] = sort
+        if typed_keys is not None:
+            __query["typed_keys"] = typed_keys
         if with_limited_by is not None:
             __query["with_limited_by"] = with_limited_by
+        if with_profile_uid is not None:
+            __query["with_profile_uid"] = with_profile_uid
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if from_ is not None:
+                __body["from"] = from_
+            if query is not None:
+                __body["query"] = query
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if size is not None:
+                __body["size"] = size
+            if sort is not None:
+                __body["sort"] = sort
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("expiration", "metadata", "role_descriptors"),
     )
     async def update_api_key(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        expiration: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         metadata: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         role_descriptors: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates attributes of an existing API key.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-update-api-key.html>`_
 
         :param id: The ID of the API key to update.
+        :param expiration: Expiration time for the API key.
         :param metadata: Arbitrary metadata that you want to associate with the API key.
             It supports nested data structure. Within the metadata object, keys beginning
             with _ are reserved for system usage.
         :param role_descriptors: An array of role descriptors for this API key. This
             parameter is optional. When it is not specified or is an empty array, then
             the API key will have a point in time snapshot of permissions of the authenticated
             user. If you supply role descriptors then the resultant permissions would
@@ -461,27 +492,30 @@
             is the same as the request for create role API. For more details, see create
             or update roles API.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/_security/api_key/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if metadata is not None:
-            __body["metadata"] = metadata
         if pretty is not None:
             __query["pretty"] = pretty
-        if role_descriptors is not None:
-            __body["role_descriptors"] = role_descriptors
+        if not __body:
+            if expiration is not None:
+                __body["expiration"] = expiration
+            if metadata is not None:
+                __body["metadata"] = metadata
+            if role_descriptors is not None:
+                __body["role_descriptors"] = role_descriptors
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/slm.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/search_application.py`

 * *Files 14% similar despite different names*

```diff
@@ -19,359 +19,323 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class SlmClient(NamespacedClient):
+class SearchApplicationClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete_lifecycle(
+    def delete(
         self,
         *,
-        policy_id: str,
+        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes an existing snapshot lifecycle policy.
+        Deletes a search application.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-delete-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-search-application.html>`_
 
-        :param policy_id: The id of the snapshot lifecycle policy to remove
+        :param name: The name of the search application to delete
         """
-        if policy_id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'policy_id'")
-        __path = f"/_slm/policy/{_quote(policy_id)}"
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_application/search_application/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def execute_lifecycle(
+    def delete_behavioral_analytics(
         self,
         *,
-        policy_id: str,
+        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Immediately creates a snapshot according to the lifecycle policy, without waiting
-        for the scheduled time.
+        Delete a behavioral analytics collection.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-execute-lifecycle.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-analytics-collection.html>`_
 
-        :param policy_id: The id of the snapshot lifecycle policy to be executed
+        :param name: The name of the analytics collection to be deleted
         """
-        if policy_id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'policy_id'")
-        __path = f"/_slm/policy/{_quote(policy_id)}/_execute"
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_application/analytics/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def execute_retention(
+    def get(
         self,
         *,
+        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes any snapshots that are expired according to the policy's retention rules.
+        Returns the details about a search application.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-execute-retention.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-search-application.html>`_
+
+        :param name: The name of the search application
         """
-        __path = "/_slm/_execute_retention"
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_application/search_application/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_lifecycle(
+    def get_behavioral_analytics(
         self,
         *,
-        policy_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        name: t.Optional[t.Sequence[str]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieves one or more snapshot lifecycle policy definitions and information about
-        the latest snapshot attempts.
+        Returns the existing behavioral analytics collections.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-get-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/list-analytics-collection.html>`_
 
-        :param policy_id: Comma-separated list of snapshot lifecycle policies to retrieve
+        :param name: A list of analytics collections to limit the returned information
         """
-        if policy_id not in SKIP_IN_PATH:
-            __path = f"/_slm/policy/{_quote(policy_id)}"
+        if name not in SKIP_IN_PATH:
+            __path = f"/_application/analytics/{_quote(name)}"
         else:
-            __path = "/_slm/policy"
+            __path = "/_application/analytics"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    async def get_stats(
+    @_rewrite_parameters(
+        parameter_aliases={"from": "from_"},
+    )
+    def list(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        q: t.Optional[str] = None,
+        size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns global and policy-level statistics about actions taken by snapshot lifecycle
-        management.
+        Returns the existing search applications.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-get-stats.html>`_
-        """
-        __path = "/_slm/stats"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if pretty is not None:
-            __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    async def get_status(
-        self,
-        *,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Retrieves the status of snapshot lifecycle management (SLM).
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/list-search-applications.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-get-status.html>`_
+        :param from_: Starting offset.
+        :param q: Query in the Lucene query string syntax.
+        :param size: Specifies a max number of results to get.
         """
-        __path = "/_slm/status"
+        __path = "/_application/search_application"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if q is not None:
+            __query["q"] = q
+        if size is not None:
+            __query["size"] = size
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_name="search_application",
     )
-    async def put_lifecycle(
+    def put(
         self,
         *,
-        policy_id: str,
-        config: t.Optional[t.Mapping[str, t.Any]] = None,
+        name: str,
+        search_application: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
+        create: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        name: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
-        repository: t.Optional[str] = None,
-        retention: t.Optional[t.Mapping[str, t.Any]] = None,
-        schedule: t.Optional[str] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates or updates a snapshot lifecycle policy.
+        Creates or updates a search application.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-put-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-search-application.html>`_
 
-        :param policy_id: ID for the snapshot lifecycle policy you want to create or
-            update.
-        :param config: Configuration for each snapshot created by the policy.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param name: Name automatically assigned to each snapshot created by the policy.
-            Date math is supported. To prevent conflicting snapshot names, a UUID is
-            automatically appended to each snapshot name.
-        :param repository: Repository used to store snapshots created by this policy.
-            This repository must exist prior to the policy’s creation. You can create
-            a repository using the snapshot repository API.
-        :param retention: Retention rules used to retain and delete snapshots created
-            by the policy.
-        :param schedule: Periodic or absolute schedule at which the policy creates snapshots.
-            SLM applies schedule changes immediately.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if policy_id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'policy_id'")
-        __path = f"/_slm/policy/{_quote(policy_id)}"
-        __body: t.Dict[str, t.Any] = {}
+        :param name: The name of the search application to be created or updated.
+        :param search_application:
+        :param create: If `true`, this request cannot replace or update existing Search
+            Applications.
+        """
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        if search_application is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'search_application' and 'body', one of them should be set."
+            )
+        elif search_application is not None and body is not None:
+            raise ValueError("Cannot set both 'search_application' and 'body'")
+        __path = f"/_application/search_application/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
-        if config is not None:
-            __body["config"] = config
+        if create is not None:
+            __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if name is not None:
-            __body["name"] = name
         if pretty is not None:
             __query["pretty"] = pretty
-        if repository is not None:
-            __body["repository"] = repository
-        if retention is not None:
-            __body["retention"] = retention
-        if schedule is not None:
-            __body["schedule"] = schedule
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if not __body:
-            __body = None  # type: ignore[assignment]
-        __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
+        __body = search_application if search_application is not None else body
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def start(
+    def put_behavioral_analytics(
         self,
         *,
+        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Turns on snapshot lifecycle management (SLM).
+        Creates a behavioral analytics collection.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-start.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-analytics-collection.html>`_
+
+        :param name: The name of the analytics collection to be created or updated.
         """
-        __path = "/_slm/start"
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_application/analytics/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    async def stop(
+    @_rewrite_parameters(
+        body_fields=("params",),
+        ignore_deprecated_options={"params"},
+    )
+    def search(
         self,
         *,
+        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        params: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Turns off snapshot lifecycle management (SLM).
+        Perform a search against a search application
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-application-search.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/slm-api-stop.html>`_
+        :param name: The name of the search application to be searched.
+        :param params: Query parameters specific to this request, which will override
+            any defaults specified in the template.
         """
-        __path = "/_slm/stop"
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_application/search_application/{_quote(name)}/_search"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if params is not None:
+                __body["params"] = params
+        if not __body:
+            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        if __body is not None:
+            __headers["content-type"] = "application/json"
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/snapshot.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/transform.py`

 * *Files 27% similar despite different names*

```diff
@@ -19,755 +19,693 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class SnapshotClient(NamespacedClient):
+class TransformClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def cleanup_repository(
+    def delete_transform(
         self,
         *,
-        name: str,
+        transform_id: str,
+        delete_dest_index: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Removes stale data from repository.
+        Deletes an existing transform.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/clean-up-snapshot-repo-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-transform.html>`_
 
-        :param name: Snapshot repository to clean up.
-        :param master_timeout: Period to wait for a connection to the master node.
-        :param timeout: Period to wait for a response.
+        :param transform_id: Identifier for the transform.
+        :param delete_dest_index: If this value is true, the destination index is deleted
+            together with the transform. If false, the destination index will not be
+            deleted
+        :param force: If this value is false, the transform must be stopped before it
+            can be deleted. If true, the transform is deleted regardless of its current
+            state.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
         """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_snapshot/{_quote(name)}/_cleanup"
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}"
         __query: t.Dict[str, t.Any] = {}
+        if delete_dest_index is not None:
+            __query["delete_dest_index"] = delete_dest_index
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if force is not None:
+            __query["force"] = force
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        parameter_aliases={"from": "from_"},
     )
-    async def clone(
+    def get_transform(
         self,
         *,
-        repository: str,
-        snapshot: str,
-        target_snapshot: str,
-        indices: str,
+        transform_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        exclude_generated: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Clones indices from one snapshot into another snapshot in the same repository.
+        Retrieves configuration information for transforms.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-transform.html>`_
 
-        :param repository: A repository name
-        :param snapshot: The name of the snapshot to clone from
-        :param target_snapshot: The name of the cloned snapshot to create
-        :param indices:
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param timeout:
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        if target_snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'target_snapshot'")
-        if indices is None:
-            raise ValueError("Empty value passed for parameter 'indices'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}/_clone/{_quote(target_snapshot)}"
-        __body: t.Dict[str, t.Any] = {}
+        :param transform_id: Identifier for the transform. It can be a transform identifier
+            or a wildcard expression. You can get information for all transforms by using
+            `_all`, by specifying `*` as the `<transform_id>`, or by omitting the `<transform_id>`.
+        :param allow_no_match: Specifies what to do when the request: 1. Contains wildcard
+            expressions and there are no transforms that match. 2. Contains the _all
+            string or no identifiers and there are no matches. 3. Contains wildcard expressions
+            and there are only partial matches. If this parameter is false, the request
+            returns a 404 status code when there are no matches or only partial matches.
+        :param exclude_generated: Excludes fields that were automatically added when
+            creating the transform. This allows the configuration to be in an acceptable
+            format to be retrieved and then added to another cluster.
+        :param from_: Skips the specified number of transforms.
+        :param size: Specifies the maximum number of transforms to obtain.
+        """
+        if transform_id not in SKIP_IN_PATH:
+            __path = f"/_transform/{_quote(transform_id)}"
+        else:
+            __path = "/_transform"
         __query: t.Dict[str, t.Any] = {}
-        if indices is not None:
-            __body["indices"] = indices
+        if allow_no_match is not None:
+            __query["allow_no_match"] = allow_no_match
         if error_trace is not None:
             __query["error_trace"] = error_trace
+        if exclude_generated is not None:
+            __query["exclude_generated"] = exclude_generated
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
-        __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
+        if size is not None:
+            __query["size"] = size
+        __headers = {"accept": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        parameter_aliases={"from": "from_"},
     )
-    async def create(
+    def get_transform_stats(
         self,
         *,
-        repository: str,
-        snapshot: str,
+        transform_id: t.Union[str, t.Sequence[str]],
+        allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        feature_states: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
-        ignore_unavailable: t.Optional[bool] = None,
-        include_global_state: t.Optional[bool] = None,
-        indices: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        metadata: t.Optional[t.Mapping[str, t.Any]] = None,
-        partial: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        wait_for_completion: t.Optional[bool] = None,
+        size: t.Optional[int] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates a snapshot in a repository.
+        Retrieves usage information for transforms.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-transform-stats.html>`_
 
-        :param repository: Repository for the snapshot.
-        :param snapshot: Name of the snapshot. Must be unique in the repository.
-        :param feature_states: Feature states to include in the snapshot. Each feature
-            state includes one or more system indices containing related data. You can
-            view a list of eligible features using the get features API. If `include_global_state`
-            is `true`, all current feature states are included by default. If `include_global_state`
-            is `false`, no feature states are included by default.
-        :param ignore_unavailable: If `true`, the request ignores data streams and indices
-            in `indices` that are missing or closed. If `false`, the request returns
-            an error for any data stream or index that is missing or closed.
-        :param include_global_state: If `true`, the current cluster state is included
-            in the snapshot. The cluster state includes persistent cluster settings,
-            composable index templates, legacy index templates, ingest pipelines, and
-            ILM policies. It also includes data stored in system indices, such as Watches
-            and task records (configurable via `feature_states`).
-        :param indices: Data streams and indices to include in the snapshot. Supports
-            multi-target syntax. Includes all data streams and indices by default.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param metadata: Optional metadata for the snapshot. May have any contents. Must
-            be less than 1024 bytes. This map is not automatically generated by Elasticsearch.
-        :param partial: If `true`, allows restoring a partial snapshot of indices with
-            unavailable shards. Only shards that were successfully included in the snapshot
-            will be restored. All missing shards will be recreated as empty. If `false`,
-            the entire restore operation will fail if one or more indices included in
-            the snapshot do not have all primary shards available.
-        :param wait_for_completion: If `true`, the request returns a response when the
-            snapshot is complete. If `false`, the request returns a response when the
-            snapshot initializes.
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}"
+        :param transform_id: Identifier for the transform. It can be a transform identifier
+            or a wildcard expression. You can get information for all transforms by using
+            `_all`, by specifying `*` as the `<transform_id>`, or by omitting the `<transform_id>`.
+        :param allow_no_match: Specifies what to do when the request: 1. Contains wildcard
+            expressions and there are no transforms that match. 2. Contains the _all
+            string or no identifiers and there are no matches. 3. Contains wildcard expressions
+            and there are only partial matches. If this parameter is false, the request
+            returns a 404 status code when there are no matches or only partial matches.
+        :param from_: Skips the specified number of transforms.
+        :param size: Specifies the maximum number of transforms to obtain.
+        :param timeout: Controls the time to wait for the stats
+        """
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}/_stats"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        if allow_no_match is not None:
+            __query["allow_no_match"] = allow_no_match
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if feature_states is not None:
-            __body["feature_states"] = feature_states
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
-        if ignore_unavailable is not None:
-            __body["ignore_unavailable"] = ignore_unavailable
-        if include_global_state is not None:
-            __body["include_global_state"] = include_global_state
-        if indices is not None:
-            __body["indices"] = indices
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if metadata is not None:
-            __body["metadata"] = metadata
-        if partial is not None:
-            __body["partial"] = partial
         if pretty is not None:
             __query["pretty"] = pretty
-        if wait_for_completion is not None:
-            __query["wait_for_completion"] = wait_for_completion
-        if not __body:
-            __body = None  # type: ignore[assignment]
+        if size is not None:
+            __query["size"] = size
+        if timeout is not None:
+            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
+        return self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "description",
+            "dest",
+            "frequency",
+            "latest",
+            "pivot",
+            "retention_policy",
+            "settings",
+            "source",
+            "sync",
+        ),
     )
-    async def create_repository(
+    def preview_transform(
         self,
         *,
-        name: str,
-        settings: t.Mapping[str, t.Any],
-        type: str,
+        transform_id: t.Optional[str] = None,
+        description: t.Optional[str] = None,
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
+        latest: t.Optional[t.Mapping[str, t.Any]] = None,
+        pivot: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        repository: t.Optional[t.Mapping[str, t.Any]] = None,
+        retention_policy: t.Optional[t.Mapping[str, t.Any]] = None,
+        settings: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
+        sync: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        verify: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates a repository.
+        Previews a transform.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/preview-transform.html>`_
 
-        :param name: A repository name
-        :param settings:
-        :param type:
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param repository:
-        :param timeout: Explicit operation timeout
-        :param verify: Whether to verify the repository after creation
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        if settings is None:
-            raise ValueError("Empty value passed for parameter 'settings'")
-        if type is None:
-            raise ValueError("Empty value passed for parameter 'type'")
-        __path = f"/_snapshot/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
+        :param transform_id: Identifier for the transform to preview. If you specify
+            this path parameter, you cannot provide transform configuration details in
+            the request body.
+        :param description: Free text description of the transform.
+        :param dest: The destination for the transform.
+        :param frequency: The interval between checks for changes in the source indices
+            when the transform is running continuously. Also determines the retry interval
+            in the event of transient failures while the transform is searching or indexing.
+            The minimum value is 1s and the maximum is 1h.
+        :param latest: The latest method transforms the data by finding the latest document
+            for each unique key.
+        :param pivot: The pivot method transforms the data by aggregating and grouping
+            it. These objects define the group by fields and the aggregation to reduce
+            the data.
+        :param retention_policy: Defines a retention policy for the transform. Data that
+            meets the defined criteria is deleted from the destination index.
+        :param settings: Defines optional transform settings.
+        :param source: The source of the data for the transform.
+        :param sync: Defines the properties transforms require to run continuously.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        """
+        if transform_id not in SKIP_IN_PATH:
+            __path = f"/_transform/{_quote(transform_id)}/_preview"
+        else:
+            __path = "/_transform/_preview"
         __query: t.Dict[str, t.Any] = {}
-        if settings is not None:
-            __body["settings"] = settings
-        if type is not None:
-            __body["type"] = type
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if repository is not None:
-            __body["repository"] = repository
         if timeout is not None:
             __query["timeout"] = timeout
-        if verify is not None:
-            __query["verify"] = verify
-        __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
-        )
-
-    @_rewrite_parameters()
-    async def delete(
-        self,
-        *,
-        repository: str,
-        snapshot: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Deletes one or more snapshots.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
-
-        :param repository: A repository name
-        :param snapshot: A comma-separated list of snapshot names
-        :param master_timeout: Explicit operation timeout for connection to master node
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if pretty is not None:
-            __query["pretty"] = pretty
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if dest is not None:
+                __body["dest"] = dest
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if latest is not None:
+                __body["latest"] = latest
+            if pivot is not None:
+                __body["pivot"] = pivot
+            if retention_policy is not None:
+                __body["retention_policy"] = retention_policy
+            if settings is not None:
+                __body["settings"] = settings
+            if source is not None:
+                __body["source"] = source
+            if sync is not None:
+                __body["sync"] = sync
+        if not __body:
+            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "DELETE", __path, params=__query, headers=__headers
+        if __body is not None:
+            __headers["content-type"] = "application/json"
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters()
-    async def delete_repository(
+    @_rewrite_parameters(
+        body_fields=(
+            "dest",
+            "source",
+            "description",
+            "frequency",
+            "latest",
+            "meta",
+            "pivot",
+            "retention_policy",
+            "settings",
+            "sync",
+        ),
+        parameter_aliases={"_meta": "meta"},
+    )
+    def put_transform(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        transform_id: str,
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
+        defer_validation: t.Optional[bool] = None,
+        description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
+        latest: t.Optional[t.Mapping[str, t.Any]] = None,
+        meta: t.Optional[t.Mapping[str, t.Any]] = None,
+        pivot: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        retention_policy: t.Optional[t.Mapping[str, t.Any]] = None,
+        settings: t.Optional[t.Mapping[str, t.Any]] = None,
+        sync: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes a repository.
+        Instantiates a transform.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-transform.html>`_
 
-        :param name: Name of the snapshot repository to unregister. Wildcard (`*`) patterns
-            are supported.
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param timeout: Explicit operation timeout
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_snapshot/{_quote(name)}"
-        __query: t.Dict[str, t.Any] = {}
+        :param transform_id: Identifier for the transform. This identifier can contain
+            lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.
+            It has a 64 character limit and must start and end with alphanumeric characters.
+        :param dest: The destination for the transform.
+        :param source: The source of the data for the transform.
+        :param defer_validation: When the transform is created, a series of validations
+            occur to ensure its success. For example, there is a check for the existence
+            of the source indices and a check that the destination index is not part
+            of the source index pattern. You can use this parameter to skip the checks,
+            for example when the source index does not exist until after the transform
+            is created. The validations are always run when you start the transform,
+            however, with the exception of privilege checks.
+        :param description: Free text description of the transform.
+        :param frequency: The interval between checks for changes in the source indices
+            when the transform is running continuously. Also determines the retry interval
+            in the event of transient failures while the transform is searching or indexing.
+            The minimum value is `1s` and the maximum is `1h`.
+        :param latest: The latest method transforms the data by finding the latest document
+            for each unique key.
+        :param meta: Defines optional transform metadata.
+        :param pivot: The pivot method transforms the data by aggregating and grouping
+            it. These objects define the group by fields and the aggregation to reduce
+            the data.
+        :param retention_policy: Defines a retention policy for the transform. Data that
+            meets the defined criteria is deleted from the destination index.
+        :param settings: Defines optional transform settings.
+        :param sync: Defines the properties transforms require to run continuously.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        """
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        if dest is None and body is None:
+            raise ValueError("Empty value passed for parameter 'dest'")
+        if source is None and body is None:
+            raise ValueError("Empty value passed for parameter 'source'")
+        __path = f"/_transform/{_quote(transform_id)}"
+        __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
+        if defer_validation is not None:
+            __query["defer_validation"] = defer_validation
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "DELETE", __path, params=__query, headers=__headers
+        if not __body:
+            if dest is not None:
+                __body["dest"] = dest
+            if source is not None:
+                __body["source"] = source
+            if description is not None:
+                __body["description"] = description
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if latest is not None:
+                __body["latest"] = latest
+            if meta is not None:
+                __body["_meta"] = meta
+            if pivot is not None:
+                __body["pivot"] = pivot
+            if retention_policy is not None:
+                __body["retention_policy"] = retention_policy
+            if settings is not None:
+                __body["settings"] = settings
+            if sync is not None:
+                __body["sync"] = sync
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    async def get(
+    def reset_transform(
         self,
         *,
-        repository: str,
-        snapshot: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        after: t.Optional[str] = None,
+        transform_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        from_sort_value: t.Optional[str] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        ignore_unavailable: t.Optional[bool] = None,
-        include_repository: t.Optional[bool] = None,
-        index_details: t.Optional[bool] = None,
-        index_names: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        offset: t.Optional[int] = None,
-        order: t.Optional[t.Union["t.Literal['asc', 'desc']", str]] = None,
         pretty: t.Optional[bool] = None,
-        size: t.Optional[int] = None,
-        slm_policy_filter: t.Optional[str] = None,
-        sort: t.Optional[
-            t.Union[
-                "t.Literal['duration', 'failed_shard_count', 'index_count', 'name', 'repository', 'shard_count', 'start_time']",
-                str,
-            ]
-        ] = None,
-        verbose: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns information about a snapshot.
+        Resets an existing transform.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/reset-transform.html>`_
 
-        :param repository: Comma-separated list of snapshot repository names used to
-            limit the request. Wildcard (*) expressions are supported.
-        :param snapshot: Comma-separated list of snapshot names to retrieve. Also accepts
-            wildcards (*). - To get information about all snapshots in a registered repository,
-            use a wildcard (*) or _all. - To get information about any snapshots that
-            are currently running, use _current.
-        :param after: Offset identifier to start pagination from as returned by the next
-            field in the response body.
-        :param from_sort_value: Value of the current sort column at which to start retrieval.
-            Can either be a string snapshot- or repository name when sorting by snapshot
-            or repository name, a millisecond time value or a number when sorting by
-            index- or shard count.
-        :param ignore_unavailable: If false, the request returns an error for any snapshots
-            that are unavailable.
-        :param include_repository: If true, returns the repository name in each snapshot.
-        :param index_details: If true, returns additional information about each index
-            in the snapshot comprising the number of shards in the index, the total size
-            of the index in bytes, and the maximum number of segments per shard in the
-            index. Defaults to false, meaning that this information is omitted.
-        :param index_names: If true, returns the name of each index in each snapshot.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param offset: Numeric offset to start pagination from based on the snapshots
-            matching this request. Using a non-zero value for this parameter is mutually
-            exclusive with using the after parameter. Defaults to 0.
-        :param order: Sort order. Valid values are asc for ascending and desc for descending
-            order. Defaults to asc, meaning ascending order.
-        :param size: Maximum number of snapshots to return. Defaults to 0 which means
-            return all that match the request without limit.
-        :param slm_policy_filter: Filter snapshots by a comma-separated list of SLM policy
-            names that snapshots belong to. Also accepts wildcards (*) and combinations
-            of wildcards followed by exclude patterns starting with -. To include snapshots
-            not created by an SLM policy you can use the special pattern _none that will
-            match all snapshots without an SLM policy.
-        :param sort: Allows setting a sort order for the result. Defaults to start_time,
-            i.e. sorting by snapshot start time stamp.
-        :param verbose: If true, returns additional information about each snapshot such
-            as the version of Elasticsearch which took the snapshot, the start and end
-            times of the snapshot, and the number of shards snapshotted.
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}"
+        :param transform_id: Identifier for the transform. This identifier can contain
+            lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.
+            It has a 64 character limit and must start and end with alphanumeric characters.
+        :param force: If this value is `true`, the transform is reset regardless of its
+            current state. If it's `false`, the transform must be stopped before it can
+            be reset.
+        """
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}/_reset"
         __query: t.Dict[str, t.Any] = {}
-        if after is not None:
-            __query["after"] = after
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_sort_value is not None:
-            __query["from_sort_value"] = from_sort_value
+        if force is not None:
+            __query["force"] = force
         if human is not None:
             __query["human"] = human
-        if ignore_unavailable is not None:
-            __query["ignore_unavailable"] = ignore_unavailable
-        if include_repository is not None:
-            __query["include_repository"] = include_repository
-        if index_details is not None:
-            __query["index_details"] = index_details
-        if index_names is not None:
-            __query["index_names"] = index_names
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if offset is not None:
-            __query["offset"] = offset
-        if order is not None:
-            __query["order"] = order
         if pretty is not None:
             __query["pretty"] = pretty
-        if size is not None:
-            __query["size"] = size
-        if slm_policy_filter is not None:
-            __query["slm_policy_filter"] = slm_policy_filter
-        if sort is not None:
-            __query["sort"] = sort
-        if verbose is not None:
-            __query["verbose"] = verbose
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_repository(
+    def schedule_now_transform(
         self,
         *,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        transform_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        local: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns information about a repository.
+        Schedules now a transform.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/schedule-now-transform.html>`_
 
-        :param name: A comma-separated list of repository names
-        :param local: Return local information, do not retrieve the state from master
-            node (default: false)
-        :param master_timeout: Explicit operation timeout for connection to master node
+        :param transform_id: Identifier for the transform.
+        :param timeout: Controls the time to wait for the scheduling to take place
         """
-        if name not in SKIP_IN_PATH:
-            __path = f"/_snapshot/{_quote(name)}"
-        else:
-            __path = "/_snapshot"
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}/_schedule_now"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if local is not None:
-            __query["local"] = local
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
+        if timeout is not None:
+            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        parameter_aliases={"from": "from_"},
     )
-    async def restore(
+    def start_transform(
         self,
         *,
-        repository: str,
-        snapshot: str,
+        transform_id: str,
         error_trace: t.Optional[bool] = None,
-        feature_states: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[str] = None,
         human: t.Optional[bool] = None,
-        ignore_index_settings: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
-        ignore_unavailable: t.Optional[bool] = None,
-        include_aliases: t.Optional[bool] = None,
-        include_global_state: t.Optional[bool] = None,
-        index_settings: t.Optional[t.Mapping[str, t.Any]] = None,
-        indices: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        partial: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        rename_pattern: t.Optional[str] = None,
-        rename_replacement: t.Optional[str] = None,
-        wait_for_completion: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Restores a snapshot.
+        Starts one or more transforms.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/start-transform.html>`_
 
-        :param repository: A repository name
-        :param snapshot: A snapshot name
-        :param feature_states:
-        :param ignore_index_settings:
-        :param ignore_unavailable:
-        :param include_aliases:
-        :param include_global_state:
-        :param index_settings:
-        :param indices:
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param partial:
-        :param rename_pattern:
-        :param rename_replacement:
-        :param wait_for_completion: Should this request wait until the operation has
-            completed before returning
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}/_restore"
+        :param transform_id: Identifier for the transform.
+        :param from_: Restricts the set of transformed entities to those changed after
+            this time. Relative times like now-30d are supported. Only applicable for
+            continuous transforms.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        """
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}/_start"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if feature_states is not None:
-            __body["feature_states"] = feature_states
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
-        if ignore_index_settings is not None:
-            __body["ignore_index_settings"] = ignore_index_settings
-        if ignore_unavailable is not None:
-            __body["ignore_unavailable"] = ignore_unavailable
-        if include_aliases is not None:
-            __body["include_aliases"] = include_aliases
-        if include_global_state is not None:
-            __body["include_global_state"] = include_global_state
-        if index_settings is not None:
-            __body["index_settings"] = index_settings
-        if indices is not None:
-            __body["indices"] = indices
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if partial is not None:
-            __body["partial"] = partial
         if pretty is not None:
             __query["pretty"] = pretty
-        if rename_pattern is not None:
-            __body["rename_pattern"] = rename_pattern
-        if rename_replacement is not None:
-            __body["rename_replacement"] = rename_replacement
-        if wait_for_completion is not None:
-            __query["wait_for_completion"] = wait_for_completion
-        if not __body:
-            __body = None  # type: ignore[assignment]
+        if timeout is not None:
+            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def status(
+    def stop_transform(
         self,
         *,
-        repository: t.Optional[str] = None,
-        snapshot: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        transform_id: str,
+        allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        ignore_unavailable: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        wait_for_checkpoint: t.Optional[bool] = None,
+        wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns information about the status of a snapshot.
+        Stops one or more transforms.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/stop-transform.html>`_
 
-        :param repository: A repository name
-        :param snapshot: A comma-separated list of snapshot names
-        :param ignore_unavailable: Whether to ignore unavailable snapshots, defaults
-            to false which means a SnapshotMissingException is thrown
-        :param master_timeout: Explicit operation timeout for connection to master node
-        """
-        if repository not in SKIP_IN_PATH and snapshot not in SKIP_IN_PATH:
-            __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}/_status"
-        elif repository not in SKIP_IN_PATH:
-            __path = f"/_snapshot/{_quote(repository)}/_status"
-        else:
-            __path = "/_snapshot/_status"
+        :param transform_id: Identifier for the transform. To stop multiple transforms,
+            use a comma-separated list or a wildcard expression. To stop all transforms,
+            use `_all` or `*` as the identifier.
+        :param allow_no_match: Specifies what to do when the request: contains wildcard
+            expressions and there are no transforms that match; contains the `_all` string
+            or no identifiers and there are no matches; contains wildcard expressions
+            and there are only partial matches. If it is true, the API returns a successful
+            acknowledgement message when there are no matches. When there are only partial
+            matches, the API stops the appropriate transforms. If it is false, the request
+            returns a 404 status code when there are no matches or only partial matches.
+        :param force: If it is true, the API forcefully stops the transforms.
+        :param timeout: Period to wait for a response when `wait_for_completion` is `true`.
+            If no response is received before the timeout expires, the request returns
+            a timeout exception. However, the request continues processing and eventually
+            moves the transform to a STOPPED state.
+        :param wait_for_checkpoint: If it is true, the transform does not completely
+            stop until the current checkpoint is completed. If it is false, the transform
+            stops as soon as possible.
+        :param wait_for_completion: If it is true, the API blocks until the indexer state
+            completely stops. If it is false, the API returns immediately and the indexer
+            is stopped asynchronously in the background.
+        """
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}/_stop"
         __query: t.Dict[str, t.Any] = {}
+        if allow_no_match is not None:
+            __query["allow_no_match"] = allow_no_match
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if force is not None:
+            __query["force"] = force
         if human is not None:
             __query["human"] = human
-        if ignore_unavailable is not None:
-            __query["ignore_unavailable"] = ignore_unavailable
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
+        if timeout is not None:
+            __query["timeout"] = timeout
+        if wait_for_checkpoint is not None:
+            __query["wait_for_checkpoint"] = wait_for_checkpoint
+        if wait_for_completion is not None:
+            __query["wait_for_completion"] = wait_for_completion
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    async def verify_repository(
+    @_rewrite_parameters(
+        body_fields=(
+            "description",
+            "dest",
+            "frequency",
+            "meta",
+            "retention_policy",
+            "settings",
+            "source",
+            "sync",
+        ),
+        parameter_aliases={"_meta": "meta"},
+    )
+    def update_transform(
         self,
         *,
-        name: str,
+        transform_id: str,
+        defer_validation: t.Optional[bool] = None,
+        description: t.Optional[str] = None,
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
+        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        retention_policy: t.Optional[t.Union[None, t.Mapping[str, t.Any]]] = None,
+        settings: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
+        sync: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Verifies a repository.
+        Updates certain properties of a transform.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/modules-snapshots.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/update-transform.html>`_
 
-        :param name: A repository name
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param timeout: Explicit operation timeout
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_snapshot/{_quote(name)}/_verify"
-        __query: t.Dict[str, t.Any] = {}
+        :param transform_id: Identifier for the transform.
+        :param defer_validation: When true, deferrable validations are not run. This
+            behavior may be desired if the source index does not exist until after the
+            transform is created.
+        :param description: Free text description of the transform.
+        :param dest: The destination for the transform.
+        :param frequency: The interval between checks for changes in the source indices
+            when the transform is running continuously. Also determines the retry interval
+            in the event of transient failures while the transform is searching or indexing.
+            The minimum value is 1s and the maximum is 1h.
+        :param meta: Defines optional transform metadata.
+        :param retention_policy: Defines a retention policy for the transform. Data that
+            meets the defined criteria is deleted from the destination index.
+        :param settings: Defines optional transform settings.
+        :param source: The source of the data for the transform.
+        :param sync: Defines the properties transforms require to run continuously.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        """
+        if transform_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'transform_id'")
+        __path = f"/_transform/{_quote(transform_id)}/_update"
+        __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
+        if defer_validation is not None:
+            __query["defer_validation"] = defer_validation
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
-        __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if dest is not None:
+                __body["dest"] = dest
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if meta is not None:
+                __body["_meta"] = meta
+            if retention_policy is not None:
+                __body["retention_policy"] = retention_policy
+            if settings is not None:
+                __body["settings"] = settings
+            if source is not None:
+                __body["source"] = source
+            if sync is not None:
+                __body["sync"] = sync
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/sql.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/cluster.py`

 * *Files 27% similar despite different names*

```diff
@@ -13,362 +13,302 @@
 #  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 #  KIND, either express or implied.  See the License for the
 #  specific language governing permissions and limitations
 #  under the License.
 
 import typing as t
 
-from elastic_transport import ObjectApiResponse
+from elastic_transport import HeadApiResponse, ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class SqlClient(NamespacedClient):
-    @_rewrite_parameters(
-        body_fields=True,
-    )
-    async def clear_cursor(
+class ClusterClient(NamespacedClient):
+
+    @_rewrite_parameters()
+    def delete_component_template(
         self,
         *,
-        cursor: str,
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        master_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
+        ] = None,
         pretty: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Clears the SQL cursor
+        Deletes a component template
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-sql-cursor-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
 
-        :param cursor: Cursor to clear.
-        """
-        if cursor is None:
-            raise ValueError("Empty value passed for parameter 'cursor'")
-        __path = "/_sql/close"
-        __body: t.Dict[str, t.Any] = {}
+        :param name: Comma-separated list or wildcard expression of component template
+            names used to limit the request.
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        """
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_component_template/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
-        if cursor is not None:
-            __body["cursor"] = cursor
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
+        if master_timeout is not None:
+            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+        if timeout is not None:
+            __query["timeout"] = timeout
+        __headers = {"accept": "application/json"}
+        return self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete_async(
+    def exists_component_template(
         self,
         *,
-        id: str,
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        local: t.Optional[bool] = None,
+        master_timeout: t.Optional[
+            t.Union["t.Literal[-1]", "t.Literal[0]", str]
+        ] = None,
         pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
+    ) -> HeadApiResponse:
         """
-        Deletes an async SQL search or a stored synchronous SQL search. If the search
-        is still running, the API cancels it.
+        Returns information about whether a particular component template exist
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-async-sql-search-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
 
-        :param id: Identifier for the search.
-        """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_sql/async/delete/{_quote(id)}"
+        :param name: Comma-separated list of component template names used to limit the
+            request. Wildcard (*) expressions are supported.
+        :param local: If true, the request retrieves information from the local node
+            only. Defaults to false, which means information is retrieved from the master
+            node.
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        """
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        __path = f"/_component_template/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
+        if local is not None:
+            __query["local"] = local
+        if master_timeout is not None:
+            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "DELETE", __path, params=__query, headers=__headers
+        return self.perform_request(  # type: ignore[return-value]
+            "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_async(
+    def get_component_template(
         self,
         *,
-        id: str,
-        delimiter: t.Optional[str] = None,
+        name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        format: t.Optional[str] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        pretty: t.Optional[bool] = None,
-        wait_for_completion_timeout: t.Optional[
+        include_defaults: t.Optional[bool] = None,
+        local: t.Optional[bool] = None,
+        master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns the current status and available results for an async SQL search or stored
-        synchronous SQL search
+        Returns one or more component templates
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-sql-search-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
 
-        :param id: Identifier for the search.
-        :param delimiter: Separator for CSV results. The API only supports this parameter
-            for CSV responses.
-        :param format: Format for the response. You must specify a format using this
-            parameter or the Accept HTTP header. If you specify both, the API uses this
-            parameter.
-        :param keep_alive: Retention period for the search and its results. Defaults
-            to the `keep_alive` period for the original SQL search.
-        :param wait_for_completion_timeout: Period to wait for complete results. Defaults
-            to no timeout, meaning the request waits for complete search results.
-        """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_sql/async/{_quote(id)}"
+        :param name: Comma-separated list of component template names used to limit the
+            request. Wildcard (`*`) expressions are supported.
+        :param flat_settings: If `true`, returns settings in flat format.
+        :param include_defaults: Return all default configurations for the component
+            template (default: false)
+        :param local: If `true`, the request retrieves information from the local node
+            only. If `false`, information is retrieved from the master node.
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        """
+        if name not in SKIP_IN_PATH:
+            __path = f"/_component_template/{_quote(name)}"
+        else:
+            __path = "/_component_template"
         __query: t.Dict[str, t.Any] = {}
-        if delimiter is not None:
-            __query["delimiter"] = delimiter
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if format is not None:
-            __query["format"] = format
+        if flat_settings is not None:
+            __query["flat_settings"] = flat_settings
         if human is not None:
             __query["human"] = human
-        if keep_alive is not None:
-            __query["keep_alive"] = keep_alive
+        if include_defaults is not None:
+            __query["include_defaults"] = include_defaults
+        if local is not None:
+            __query["local"] = local
+        if master_timeout is not None:
+            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if wait_for_completion_timeout is not None:
-            __query["wait_for_completion_timeout"] = wait_for_completion_timeout
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_async_status(
+    def info(
         self,
         *,
-        id: str,
+        target: t.Union[
+            t.Sequence[
+                t.Union[
+                    "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']", str
+                ]
+            ],
+            t.Union[
+                "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']", str
+            ],
+        ],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns the current status of an async SQL search or a stored synchronous SQL
-        search
+        Returns different information about the cluster.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-async-sql-search-status-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-info.html>`_
 
-        :param id: Identifier for the search.
+        :param target: Limits the information returned to the specific target. Supports
+            a comma-separated list, such as http,ingest.
         """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_sql/async/status/{_quote(id)}"
+        if target in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'target'")
+        __path = f"/_info/{_quote(target)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
-        ignore_deprecated_options={"params", "request_timeout"},
+        body_fields=("template", "allow_auto_create", "meta", "version"),
+        parameter_aliases={"_meta": "meta"},
     )
-    async def query(
+    def put_component_template(
         self,
         *,
-        catalog: t.Optional[str] = None,
-        columnar: t.Optional[bool] = None,
-        cursor: t.Optional[str] = None,
+        name: str,
+        template: t.Optional[t.Mapping[str, t.Any]] = None,
+        allow_auto_create: t.Optional[bool] = None,
+        create: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        fetch_size: t.Optional[int] = None,
-        field_multi_value_leniency: t.Optional[bool] = None,
-        filter: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        format: t.Optional[str] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        index_using_frozen: t.Optional[bool] = None,
-        keep_alive: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        keep_on_completion: t.Optional[bool] = None,
-        page_timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        params: t.Optional[t.Mapping[str, t.Any]] = None,
-        pretty: t.Optional[bool] = None,
-        query: t.Optional[str] = None,
-        request_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
-        time_zone: t.Optional[str] = None,
-        wait_for_completion_timeout: t.Optional[
+        master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Executes a SQL request
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/sql-search-api.html>`_
-
-        :param catalog: Default catalog (cluster) for queries. If unspecified, the queries
-            execute on the data in the local cluster only.
-        :param columnar: If true, the results in a columnar fashion: one row represents
-            all the values of a certain column from the current page of results.
-        :param cursor: Cursor used to retrieve a set of paginated results. If you specify
-            a cursor, the API only uses the `columnar` and `time_zone` request body parameters.
-            It ignores other request body parameters.
-        :param fetch_size: The maximum number of rows (or entries) to return in one response
-        :param field_multi_value_leniency: Throw an exception when encountering multiple
-            values for a field (default) or be lenient and return the first value from
-            the list (without any guarantees of what that will be - typically the first
-            in natural ascending order).
-        :param filter: Elasticsearch query DSL for additional filtering.
-        :param format: Format for the response.
-        :param index_using_frozen: If true, the search can run on frozen indices. Defaults
-            to false.
-        :param keep_alive: Retention period for an async or saved synchronous search.
-        :param keep_on_completion: If true, Elasticsearch stores synchronous searches
-            if you also specify the wait_for_completion_timeout parameter. If false,
-            Elasticsearch only stores async searches that don’t finish before the wait_for_completion_timeout.
-        :param page_timeout: The timeout before a pagination request fails.
-        :param params: Values for parameters in the query.
-        :param query: SQL query to run.
-        :param request_timeout: The timeout before the request fails.
-        :param runtime_mappings: Defines one or more runtime fields in the search request.
-            These fields take precedence over mapped fields with the same name.
-        :param time_zone: ISO-8601 time zone ID for the search.
-        :param wait_for_completion_timeout: Period to wait for complete results. Defaults
-            to no timeout, meaning the request waits for complete search results. If
-            the search doesn’t finish within this period, the search becomes async.
-        """
-        __path = "/_sql"
-        __body: t.Dict[str, t.Any] = {}
-        __query: t.Dict[str, t.Any] = {}
-        if catalog is not None:
-            __body["catalog"] = catalog
-        if columnar is not None:
-            __body["columnar"] = columnar
-        if cursor is not None:
-            __body["cursor"] = cursor
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if fetch_size is not None:
-            __body["fetch_size"] = fetch_size
-        if field_multi_value_leniency is not None:
-            __body["field_multi_value_leniency"] = field_multi_value_leniency
-        if filter is not None:
-            __body["filter"] = filter
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if format is not None:
-            __query["format"] = format
-        if human is not None:
-            __query["human"] = human
-        if index_using_frozen is not None:
-            __body["index_using_frozen"] = index_using_frozen
-        if keep_alive is not None:
-            __body["keep_alive"] = keep_alive
-        if keep_on_completion is not None:
-            __body["keep_on_completion"] = keep_on_completion
-        if page_timeout is not None:
-            __body["page_timeout"] = page_timeout
-        if params is not None:
-            __body["params"] = params
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if request_timeout is not None:
-            __body["request_timeout"] = request_timeout
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if time_zone is not None:
-            __body["time_zone"] = time_zone
-        if wait_for_completion_timeout is not None:
-            __body["wait_for_completion_timeout"] = wait_for_completion_timeout
-        __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
-        )
-
-    @_rewrite_parameters(
-        body_fields=True,
-    )
-    async def translate(
-        self,
-        *,
-        query: str,
-        error_trace: t.Optional[bool] = None,
-        fetch_size: t.Optional[int] = None,
-        filter: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
+        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        time_zone: t.Optional[str] = None,
+        version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Translates SQL into Elasticsearch queries
+        Creates or updates a component template
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/sql-translate-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
 
-        :param query: SQL query to run.
-        :param fetch_size: The maximum number of rows (or entries) to return in one response.
-        :param filter: Elasticsearch query DSL for additional filtering.
-        :param time_zone: ISO-8601 time zone ID for the search.
-        """
-        if query is None:
-            raise ValueError("Empty value passed for parameter 'query'")
-        __path = "/_sql/translate"
-        __body: t.Dict[str, t.Any] = {}
+        :param name: Name of the component template to create. Elasticsearch includes
+            the following built-in component templates: `logs-mappings`; 'logs-settings`;
+            `metrics-mappings`; `metrics-settings`;`synthetics-mapping`; `synthetics-settings`.
+            Elastic Agent uses these templates to configure backing indices for its data
+            streams. If you use Elastic Agent and want to overwrite one of these templates,
+            set the `version` for your replacement template higher than the current version.
+            If you don’t use Elastic Agent and want to disable all built-in component
+            and index templates, set `stack.templates.enabled` to `false` using the cluster
+            update settings API.
+        :param template: The template to be applied which includes mappings, settings,
+            or aliases configuration.
+        :param allow_auto_create: This setting overrides the value of the `action.auto_create_index`
+            cluster setting. If set to `true` in a template, then indices can be automatically
+            created using that template even if auto-creation of indices is disabled
+            via `actions.auto_create_index`. If set to `false` then data streams matching
+            the template must always be explicitly created.
+        :param create: If `true`, this request cannot replace or update existing component
+            templates.
+        :param master_timeout: Period to wait for a connection to the master node. If
+            no response is received before the timeout expires, the request fails and
+            returns an error.
+        :param meta: Optional user metadata about the component template. May have any
+            contents. This map is not automatically generated by Elasticsearch. This
+            information is stored in the cluster state, so keeping it short is preferable.
+            To unset `_meta`, replace the template without specifying this information.
+        :param version: Version number used to manage component templates externally.
+            This number isn't automatically generated or incremented by Elasticsearch.
+            To unset a version, replace the template without specifying a version.
+        """
+        if name in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'name'")
+        if template is None and body is None:
+            raise ValueError("Empty value passed for parameter 'template'")
+        __path = f"/_component_template/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
-        if query is not None:
-            __body["query"] = query
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
+        if create is not None:
+            __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if fetch_size is not None:
-            __body["fetch_size"] = fetch_size
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
+        if master_timeout is not None:
+            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if time_zone is not None:
-            __body["time_zone"] = time_zone
+        if not __body:
+            if template is not None:
+                __body["template"] = template
+            if allow_auto_create is not None:
+                __body["allow_auto_create"] = allow_auto_create
+            if meta is not None:
+                __body["_meta"] = meta
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+        return self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/ssl.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/tasks.py`

 * *Files 21% similar despite different names*

```diff
@@ -16,42 +16,55 @@
 #  under the License.
 
 import typing as t
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
-from .utils import _rewrite_parameters
+from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class SslClient(NamespacedClient):
+class TasksClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def certificates(
+    async def get(
         self,
         *,
+        task_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieves information about the X.509 certificates used to encrypt communications
-        in the cluster.
+        Returns information about a task.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/security-api-ssl.html>`_
+        :param task_id: ID of the task.
+        :param timeout: Period to wait for a response. If no response is received before
+            the timeout expires, the request fails and returns an error.
+        :param wait_for_completion: If `true`, the request blocks until the task has
+            completed.
         """
-        __path = "/_ssl/certificates"
+        if task_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'task_id'")
+        __path = f"/_tasks/{_quote(task_id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if timeout is not None:
+            __query["timeout"] = timeout
+        if wait_for_completion is not None:
+            __query["wait_for_completion"] = wait_for_completion
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/synonyms.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/synonyms.py`

 * *Files 6% similar despite different names*

```diff
@@ -20,23 +20,22 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class SynonymsClient(NamespacedClient):
+
     @_rewrite_parameters()
-    async def delete_synonym(
+    def delete_synonym(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a synonym set
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-synonyms-set.html>`_
@@ -52,28 +51,26 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def delete_synonym_rule(
+    def delete_synonym_rule(
         self,
         *,
         set_id: str,
         rule_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a synonym rule in a synonym set
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-synonym-rule.html>`_
@@ -92,29 +89,27 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
-    async def get_synonym(
+    def get_synonym(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves a synonym set
@@ -138,28 +133,26 @@
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if size is not None:
             __query["size"] = size
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    async def get_synonym_rule(
+    def get_synonym_rule(
         self,
         *,
         set_id: str,
         rule_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves a synonym rule from a synonym set
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-synonym-rule.html>`_
@@ -178,28 +171,26 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
-    async def get_synonyms_sets(
+    def get_synonyms_sets(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves a summary of all defined synonym sets
@@ -220,106 +211,104 @@
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if size is not None:
             __query["size"] = size
         __headers = {"accept": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("synonyms_set",),
     )
-    async def put_synonym(
+    def put_synonym(
         self,
         *,
         id: str,
-        synonyms_set: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        synonyms_set: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a synonyms set
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-synonyms-set.html>`_
 
         :param id: The id of the synonyms set to be created or updated
         :param synonyms_set: The synonym set information to update
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if synonyms_set is None:
+        if synonyms_set is None and body is None:
             raise ValueError("Empty value passed for parameter 'synonyms_set'")
         __path = f"/_synonyms/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if synonyms_set is not None:
-            __body["synonyms_set"] = synonyms_set
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if synonyms_set is not None:
+                __body["synonyms_set"] = synonyms_set
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("synonyms",),
     )
-    async def put_synonym_rule(
+    def put_synonym_rule(
         self,
         *,
         set_id: str,
         rule_id: str,
-        synonyms: t.Union[t.List[str], t.Tuple[str, ...]],
+        synonyms: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a synonym rule in a synonym set
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-synonym-rule.html>`_
 
         :param set_id: The id of the synonym set to be updated with the synonym rule
         :param rule_id: The id of the synonym rule to be updated or created
         :param synonyms:
         """
         if set_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'set_id'")
         if rule_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'rule_id'")
-        if synonyms is None:
+        if synonyms is None and body is None:
             raise ValueError("Empty value passed for parameter 'synonyms'")
         __path = f"/_synonyms/{_quote(set_id)}/{_quote(rule_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if synonyms is not None:
-            __body["synonyms"] = synonyms
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if synonyms is not None:
+                __body["synonyms"] = synonyms
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return await self.perform_request(  # type: ignore[return-value]
+        return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/transform.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/transform.py`

 * *Files 6% similar despite different names*

```diff
@@ -20,44 +20,49 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class TransformClient(NamespacedClient):
+
     @_rewrite_parameters()
     async def delete_transform(
         self,
         *,
         transform_id: str,
+        delete_dest_index: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing transform.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-transform.html>`_
 
         :param transform_id: Identifier for the transform.
+        :param delete_dest_index: If this value is true, the destination index is deleted
+            together with the transform. If false, the destination index will not be
+            deleted
         :param force: If this value is false, the transform must be stopped before it
             can be deleted. If true, the transform is deleted regardless of its current
             state.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if transform_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'transform_id'")
         __path = f"/_transform/{_quote(transform_id)}"
         __query: t.Dict[str, t.Any] = {}
+        if delete_dest_index is not None:
+            __query["delete_dest_index"] = delete_dest_index
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if force is not None:
             __query["force"] = force
         if human is not None:
@@ -73,23 +78,19 @@
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     async def get_transform(
         self,
         *,
-        transform_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        transform_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for transforms.
@@ -138,20 +139,18 @@
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     async def get_transform_stats(
         self,
         *,
-        transform_id: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        transform_id: t.Union[str, t.Sequence[str]],
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -193,36 +192,45 @@
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "description",
+            "dest",
+            "frequency",
+            "latest",
+            "pivot",
+            "retention_policy",
+            "settings",
+            "source",
+            "sync",
+        ),
     )
     async def preview_transform(
         self,
         *,
         transform_id: t.Optional[str] = None,
         description: t.Optional[str] = None,
         dest: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
         latest: t.Optional[t.Mapping[str, t.Any]] = None,
         pivot: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         retention_policy: t.Optional[t.Mapping[str, t.Any]] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         source: t.Optional[t.Mapping[str, t.Any]] = None,
         sync: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Previews a transform.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/preview-transform.html>`_
 
         :param transform_id: Identifier for the transform to preview. If you specify
@@ -247,79 +255,90 @@
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if transform_id not in SKIP_IN_PATH:
             __path = f"/_transform/{_quote(transform_id)}/_preview"
         else:
             __path = "/_transform/_preview"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
-        if dest is not None:
-            __body["dest"] = dest
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
         if human is not None:
             __query["human"] = human
-        if latest is not None:
-            __body["latest"] = latest
-        if pivot is not None:
-            __body["pivot"] = pivot
         if pretty is not None:
             __query["pretty"] = pretty
-        if retention_policy is not None:
-            __body["retention_policy"] = retention_policy
-        if settings is not None:
-            __body["settings"] = settings
-        if source is not None:
-            __body["source"] = source
-        if sync is not None:
-            __body["sync"] = sync
         if timeout is not None:
             __query["timeout"] = timeout
         if not __body:
+            if description is not None:
+                __body["description"] = description
+            if dest is not None:
+                __body["dest"] = dest
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if latest is not None:
+                __body["latest"] = latest
+            if pivot is not None:
+                __body["pivot"] = pivot
+            if retention_policy is not None:
+                __body["retention_policy"] = retention_policy
+            if settings is not None:
+                __body["settings"] = settings
+            if source is not None:
+                __body["source"] = source
+            if sync is not None:
+                __body["sync"] = sync
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "dest",
+            "source",
+            "description",
+            "frequency",
+            "latest",
+            "meta",
+            "pivot",
+            "retention_policy",
+            "settings",
+            "sync",
+        ),
         parameter_aliases={"_meta": "meta"},
     )
     async def put_transform(
         self,
         *,
         transform_id: str,
-        dest: t.Mapping[str, t.Any],
-        source: t.Mapping[str, t.Any],
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
         defer_validation: t.Optional[bool] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
         latest: t.Optional[t.Mapping[str, t.Any]] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pivot: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         retention_policy: t.Optional[t.Mapping[str, t.Any]] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         sync: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a transform.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-transform.html>`_
 
         :param transform_id: Identifier for the transform. This identifier can contain
@@ -350,67 +369,66 @@
         :param settings: Defines optional transform settings.
         :param sync: Defines the properties transforms require to run continuously.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if transform_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'transform_id'")
-        if dest is None:
+        if dest is None and body is None:
             raise ValueError("Empty value passed for parameter 'dest'")
-        if source is None:
+        if source is None and body is None:
             raise ValueError("Empty value passed for parameter 'source'")
         __path = f"/_transform/{_quote(transform_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if dest is not None:
-            __body["dest"] = dest
-        if source is not None:
-            __body["source"] = source
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if defer_validation is not None:
             __query["defer_validation"] = defer_validation
-        if description is not None:
-            __body["description"] = description
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
         if human is not None:
             __query["human"] = human
-        if latest is not None:
-            __body["latest"] = latest
-        if meta is not None:
-            __body["_meta"] = meta
-        if pivot is not None:
-            __body["pivot"] = pivot
         if pretty is not None:
             __query["pretty"] = pretty
-        if retention_policy is not None:
-            __body["retention_policy"] = retention_policy
-        if settings is not None:
-            __body["settings"] = settings
-        if sync is not None:
-            __body["sync"] = sync
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if dest is not None:
+                __body["dest"] = dest
+            if source is not None:
+                __body["source"] = source
+            if description is not None:
+                __body["description"] = description
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if latest is not None:
+                __body["latest"] = latest
+            if meta is not None:
+                __body["_meta"] = meta
+            if pivot is not None:
+                __body["pivot"] = pivot
+            if retention_policy is not None:
+                __body["retention_policy"] = retention_policy
+            if settings is not None:
+                __body["settings"] = settings
+            if sync is not None:
+                __body["sync"] = sync
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     async def reset_transform(
         self,
         *,
         transform_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Resets an existing transform.
 
@@ -444,17 +462,15 @@
 
     @_rewrite_parameters()
     async def schedule_now_transform(
         self,
         *,
         transform_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Schedules now a transform.
 
@@ -486,17 +502,15 @@
         parameter_aliases={"from": "from_"},
     )
     async def start_transform(
         self,
         *,
         transform_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[str] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Starts one or more transforms.
@@ -534,17 +548,15 @@
     @_rewrite_parameters()
     async def stop_transform(
         self,
         *,
         transform_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_checkpoint: t.Optional[bool] = None,
         wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -599,37 +611,45 @@
             __query["wait_for_completion"] = wait_for_completion
         __headers = {"accept": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "description",
+            "dest",
+            "frequency",
+            "meta",
+            "retention_policy",
+            "settings",
+            "source",
+            "sync",
+        ),
         parameter_aliases={"_meta": "meta"},
     )
     async def update_transform(
         self,
         *,
         transform_id: str,
         defer_validation: t.Optional[bool] = None,
         description: t.Optional[str] = None,
         dest: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         retention_policy: t.Optional[t.Union[None, t.Mapping[str, t.Any]]] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         source: t.Optional[t.Mapping[str, t.Any]] = None,
         sync: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of a transform.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/update-transform.html>`_
 
         :param transform_id: Identifier for the transform.
@@ -651,40 +671,41 @@
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if transform_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'transform_id'")
         __path = f"/_transform/{_quote(transform_id)}/_update"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if defer_validation is not None:
             __query["defer_validation"] = defer_validation
-        if description is not None:
-            __body["description"] = description
-        if dest is not None:
-            __body["dest"] = dest
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
         if human is not None:
             __query["human"] = human
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if retention_policy is not None:
-            __body["retention_policy"] = retention_policy
-        if settings is not None:
-            __body["settings"] = settings
-        if source is not None:
-            __body["source"] = source
-        if sync is not None:
-            __body["sync"] = sync
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if dest is not None:
+                __body["dest"] = dest
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if meta is not None:
+                __body["_meta"] = meta
+            if retention_policy is not None:
+                __body["retention_policy"] = retention_policy
+            if settings is not None:
+                __body["settings"] = settings
+            if source is not None:
+                __body["source"] = source
+            if sync is not None:
+                __body["sync"] = sync
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_async/client/utils.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/utils.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/__init__.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_version.py`

 * *Files 25% similar despite different names*

```diff
@@ -10,7 +10,9 @@
 #
 #  Unless required by applicable law or agreed to in writing,
 #  software distributed under the License is distributed on an
 #  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 #  KIND, either express or implied.  See the License for the
 #  specific language governing permissions and limitations
 #  under the License.
+
+__versionstr__ = "0.2.0.20231031"
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/__init__.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -17,81 +17,64 @@
 
 
 import logging
 import typing as t
 import warnings
 
 from elastic_transport import (
+    AsyncTransport,
     BaseNode,
     BinaryApiResponse,
     HeadApiResponse,
     NodePool,
     ObjectApiResponse,
     Serializer,
-    Transport,
 )
 from elastic_transport.client_utils import DEFAULT, DefaultType
 
 from ...exceptions import ApiError, TransportError
 from ...serializer import DEFAULT_SERIALIZERS
 from ._base import BaseClient, resolve_auth_headers
 from .async_search import AsyncSearchClient
-from .autoscaling import AutoscalingClient
 from .cat import CatClient
-from .ccr import CcrClient
 from .cluster import ClusterClient
-from .dangling_indices import DanglingIndicesClient
 from .enrich import EnrichClient
 from .eql import EqlClient
-from .features import FeaturesClient
-from .fleet import FleetClient
 from .graph import GraphClient
-from .ilm import IlmClient
 from .indices import IndicesClient
+from .inference import InferenceClient
 from .ingest import IngestClient
 from .license import LicenseClient
 from .logstash import LogstashClient
-from .migration import MigrationClient
 from .ml import MlClient
-from .monitoring import MonitoringClient
-from .nodes import NodesClient
 from .query_ruleset import QueryRulesetClient
-from .rollup import RollupClient
 from .search_application import SearchApplicationClient
-from .searchable_snapshots import SearchableSnapshotsClient
 from .security import SecurityClient
-from .shutdown import ShutdownClient
-from .slm import SlmClient
-from .snapshot import SnapshotClient
 from .sql import SqlClient
-from .ssl import SslClient
 from .synonyms import SynonymsClient
 from .tasks import TasksClient
-from .text_structure import TextStructureClient
 from .transform import TransformClient
 from .utils import (
     _TYPE_HOST,
     CLIENT_META_SERVICE,
     SKIP_IN_PATH,
     _quote,
     _rewrite_parameters,
     client_node_config,
     is_requests_http_auth,
     is_requests_node_class,
 )
-from .watcher import WatcherClient
-from .xpack import XPackClient
 
 logger = logging.getLogger("elasticsearch")
 
 
-SelfType = t.TypeVar("SelfType", bound="Elasticsearch")
+SelfType = t.TypeVar("SelfType", bound="AsyncElasticsearch")
 
 
-class Elasticsearch(BaseClient):
+class AsyncElasticsearch(BaseClient):
     """
     Elasticsearch low-level client. Provides a straightforward mapping from
     Python to Elasticsearch REST APIs.
 
     The client instance has additional attributes to update APIs in different
     namespaces such as ``async_search``, ``indices``, ``security``, and more:
 
@@ -142,15 +125,15 @@
         client_key: t.Union[DefaultType, str] = DEFAULT,
         ssl_assert_hostname: t.Union[DefaultType, str] = DEFAULT,
         ssl_assert_fingerprint: t.Union[DefaultType, str] = DEFAULT,
         ssl_version: t.Union[DefaultType, int] = DEFAULT,
         ssl_context: t.Union[DefaultType, t.Any] = DEFAULT,
         ssl_show_warn: t.Union[DefaultType, bool] = DEFAULT,
         # Transport
-        transport_class: t.Type[Transport] = Transport,
+        transport_class: t.Type[AsyncTransport] = AsyncTransport,
         request_timeout: t.Union[DefaultType, None, float] = DEFAULT,
         node_class: t.Union[DefaultType, t.Type[BaseNode]] = DEFAULT,
         node_pool_class: t.Union[DefaultType, t.Type[NodePool]] = DEFAULT,
         dead_node_backoff_factor: t.Union[DefaultType, float] = DEFAULT,
         max_dead_node_backoff: t.Union[DefaultType, float] = DEFAULT,
         serializer: t.Optional[Serializer] = None,
         serializers: t.Union[DefaultType, t.Mapping[str, Serializer]] = DEFAULT,
@@ -158,15 +141,15 @@
         max_retries: t.Union[DefaultType, int] = DEFAULT,
         retry_on_status: t.Union[DefaultType, int, t.Collection[int]] = DEFAULT,
         retry_on_timeout: t.Union[DefaultType, bool] = DEFAULT,
         meta_header: t.Union[DefaultType, bool] = DEFAULT,
         timeout: t.Union[DefaultType, None, float] = DEFAULT,
         http_auth: t.Union[DefaultType, t.Any] = DEFAULT,
         # Internal use only
-        _transport: t.Optional[Transport] = None,
+        _transport: t.Optional[AsyncTransport] = None,
     ) -> None:
         if host is not None and hosts is not None:
             raise ValueError("Can't specify both 'host' and 'hosts'")
 
         if hosts is not None:
             if len(hosts) > 1:
                 raise ValueError("Can't specify more than one host in 'hosts'")
@@ -290,73 +273,56 @@
             api_key=api_key,
             basic_auth=basic_auth,
             bearer_auth=bearer_auth,
         )
 
         # namespaced clients for compatibility with API names
         self.async_search = AsyncSearchClient(self)
-        self.autoscaling = AutoscalingClient(self)
         self.cat = CatClient(self)
         self.cluster = ClusterClient(self)
-        self.fleet = FleetClient(self)
-        self.features = FeaturesClient(self)
         self.indices = IndicesClient(self)
+        self.inference = InferenceClient(self)
         self.ingest = IngestClient(self)
-        self.nodes = NodesClient(self)
-        self.snapshot = SnapshotClient(self)
         self.tasks = TasksClient(self)
 
-        self.xpack = XPackClient(self)
-        self.ccr = CcrClient(self)
-        self.dangling_indices = DanglingIndicesClient(self)
         self.enrich = EnrichClient(self)
         self.eql = EqlClient(self)
         self.graph = GraphClient(self)
-        self.ilm = IlmClient(self)
         self.license = LicenseClient(self)
         self.logstash = LogstashClient(self)
-        self.migration = MigrationClient(self)
         self.ml = MlClient(self)
-        self.monitoring = MonitoringClient(self)
         self.query_ruleset = QueryRulesetClient(self)
-        self.rollup = RollupClient(self)
         self.search_application = SearchApplicationClient(self)
-        self.searchable_snapshots = SearchableSnapshotsClient(self)
         self.security = SecurityClient(self)
-        self.slm = SlmClient(self)
-        self.shutdown = ShutdownClient(self)
         self.sql = SqlClient(self)
-        self.ssl = SslClient(self)
         self.synonyms = SynonymsClient(self)
-        self.text_structure = TextStructureClient(self)
         self.transform = TransformClient(self)
-        self.watcher = WatcherClient(self)
 
     def __repr__(self) -> str:
         try:
             # get a list of all connections
             nodes = [node.base_url for node in self.transport.node_pool.all()]
             # truncate to 5 if there are too many
             if len(nodes) > 5:
                 nodes = nodes[:5] + ["..."]
             return f"<{self.__class__.__name__}({nodes})>"
         except Exception:
             # probably operating on custom transport and connection_pool, ignore
             return super().__repr__()
 
-    def __enter__(self) -> "Elasticsearch":
+    async def __aenter__(self) -> "AsyncElasticsearch":
         try:
             # All this to avoid a Mypy error when using unasync.
-            getattr(self.transport, "_async_call")()
+            await getattr(self.transport, "_async_call")()
         except AttributeError:
             pass
         return self
 
-    def __exit__(self, *_: t.Any) -> None:
-        self.close()
+    async def __aexit__(self, *_: t.Any) -> None:
+        await self.close()
 
     def options(
         self: SelfType,
         *,
         opaque_id: t.Union[DefaultType, str] = DEFAULT,
         api_key: t.Union[DefaultType, str, t.Tuple[str, str]] = DEFAULT,
         basic_auth: t.Union[DefaultType, str, t.Tuple[str, str]] = DEFAULT,
@@ -419,20 +385,20 @@
                 raise TypeError("'retry_on_timeout' must be of type 'bool'")
             client._retry_on_timeout = retry_on_timeout
         else:
             client._retry_on_timeout = self._retry_on_timeout
 
         return client
 
-    def close(self) -> None:
+    async def close(self) -> None:
         """Closes the Transport and all internal connections"""
-        self.transport.close()
+        await self.transport.close()
 
     @_rewrite_parameters()
-    def ping(
+    async def ping(
         self,
         *,
         error_trace: t.Optional[bool] = None,
         filter_path: t.Optional[t.Union[t.List[str], str]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> bool:
@@ -454,57 +420,50 @@
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         try:
-            self.perform_request("HEAD", __path, params=__query, headers=__headers)
+            await self.perform_request(
+                "HEAD", __path, params=__query, headers=__headers
+            )
             return True
         except (ApiError, TransportError):
             return False
 
     # AUTO-GENERATED-API-DEFINITIONS #
 
     @_rewrite_parameters(
         body_name="operations",
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def bulk(
+    async def bulk(
         self,
         *,
-        operations: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        operations: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         index: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pipeline: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         require_alias: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to perform multiple index/update/delete operations in a single request.
@@ -533,16 +492,20 @@
             the response.
         :param timeout: Period each action waits for the following operations: automatic
             index creation, dynamic mapping updates, waiting for active shards.
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to all or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
-        if operations is None:
-            raise ValueError("Empty value passed for parameter 'operations'")
+        if operations is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'operations' and 'body', one of them should be set."
+            )
+        elif operations is not None and body is not None:
+            raise ValueError("Cannot set both 'operations' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_bulk"
         else:
             __path = "/_bulk"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
@@ -566,158 +529,145 @@
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
-        __body = operations
+        __body = operations if operations is not None else body
         __headers = {
             "accept": "application/json",
             "content-type": "application/x-ndjson",
         }
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("scroll_id",),
     )
-    def clear_scroll(
+    async def clear_scroll(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        scroll_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        scroll_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Explicitly clears the search context for a scroll.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-scroll-api.html>`_
 
         :param scroll_id: Scroll IDs to clear. To clear all scroll IDs, use `_all`.
         """
         __path = "/_search/scroll"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if scroll_id is not None:
-            __body["scroll_id"] = scroll_id
+        if not __body:
+            if scroll_id is not None:
+                __body["scroll_id"] = scroll_id
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("id",),
     )
-    def close_point_in_time(
+    async def close_point_in_time(
         self,
         *,
-        id: str,
+        id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Close a point in time
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/point-in-time-api.html>`_
 
         :param id: The ID of the point-in-time.
         """
-        if id is None:
+        if id is None and body is None:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = "/_pit"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if id is not None:
-            __body["id"] = id
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if id is not None:
+                __body["id"] = id
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("query",),
     )
-    def count(
+    async def count(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         min_score: t.Optional[float] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         routing: t.Optional[str] = None,
         terminate_after: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns number of documents matching a query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -758,15 +708,15 @@
             Elasticsearch collects documents before sorting.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_count"
         else:
             __path = "/_count"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if default_operator is not None:
@@ -791,42 +741,42 @@
             __query["min_score"] = min_score
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if routing is not None:
             __query["routing"] = routing
         if terminate_after is not None:
             __query["terminate_after"] = terminate_after
         if not __body:
+            if query is not None:
+                __body["query"] = query
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="document",
     )
-    def create(
+    async def create(
         self,
         *,
         index: str,
         id: str,
-        document: t.Mapping[str, t.Any],
+        document: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pipeline: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         routing: t.Optional[str] = None,
@@ -872,16 +822,20 @@
             before proceeding with the operation. Set to `all` or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if document is None:
-            raise ValueError("Empty value passed for parameter 'document'")
+        if document is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'document' and 'body', one of them should be set."
+            )
+        elif document is not None and body is not None:
+            raise ValueError("Cannot set both 'document' and 'body'")
         __path = f"/{_quote(index)}/_create/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
@@ -898,30 +852,28 @@
             __query["timeout"] = timeout
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
-        __body = document
+        __body = document if document is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    def delete(
+    async def delete(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_primary_term: t.Optional[int] = None,
         if_seq_no: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
@@ -987,54 +939,42 @@
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("max_docs", "query", "slice"),
         parameter_aliases={"from": "from_"},
     )
-    def delete_by_query(
+    async def delete_by_query(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         conflicts: t.Optional[t.Union["t.Literal['abort', 'proceed']", str]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         max_docs: t.Optional[int] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
@@ -1050,23 +990,24 @@
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         slices: t.Optional[t.Union[int, t.Union["t.Literal['auto']", str]]] = None,
-        sort: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        sort: t.Optional[t.Sequence[str]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[bool] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
         wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes documents matching the provided query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -1132,15 +1073,15 @@
         :param wait_for_completion: If `true`, the request blocks until the operation
             is complete.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_delete_by_query"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
@@ -1170,24 +1111,20 @@
             __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if lenient is not None:
             __query["lenient"] = lenient
-        if max_docs is not None:
-            __body["max_docs"] = max_docs
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if refresh is not None:
             __query["refresh"] = refresh
         if request_cache is not None:
             __query["request_cache"] = request_cache
         if requests_per_second is not None:
             __query["requests_per_second"] = requests_per_second
         if routing is not None:
@@ -1196,16 +1133,14 @@
             __query["scroll"] = scroll
         if scroll_size is not None:
             __query["scroll_size"] = scroll_size
         if search_timeout is not None:
             __query["search_timeout"] = search_timeout
         if search_type is not None:
             __query["search_type"] = search_type
-        if slice is not None:
-            __body["slice"] = slice
         if slices is not None:
             __query["slices"] = slices
         if sort is not None:
             __query["sort"] = sort
         if stats is not None:
             __query["stats"] = stats
         if terminate_after is not None:
@@ -1214,28 +1149,33 @@
             __query["timeout"] = timeout
         if version is not None:
             __query["version"] = version
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
+        if not __body:
+            if max_docs is not None:
+                __body["max_docs"] = max_docs
+            if query is not None:
+                __body["query"] = query
+            if slice is not None:
+                __body["slice"] = slice
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    def delete_script(
+    async def delete_script(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -1264,52 +1204,42 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def exists(
+    async def exists(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a document exists in an index.
@@ -1370,49 +1300,41 @@
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def exists_source(
+    async def exists_source(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a document source exists in an index.
@@ -1468,58 +1390,49 @@
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("query",),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def explain(
+    async def explain(
         self,
         *,
         index: str,
         id: str,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns information about why a specific matches (or doesn't match) a query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html>`_
 
         :param index: Index names used to limit the request. Only a single index name
@@ -1550,15 +1463,15 @@
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/{_quote(index)}/_explain/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
@@ -1573,76 +1486,65 @@
             __query["lenient"] = lenient
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if routing is not None:
             __query["routing"] = routing
         if source is not None:
             __query["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if not __body:
+            if query is not None:
+                __body["query"] = query
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("fields", "index_filter", "runtime_mappings"),
     )
-    def field_caps(
+    async def field_caps(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         filters: t.Optional[str] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
+        include_empty_fields: t.Optional[bool] = None,
         include_unmapped: t.Optional[bool] = None,
         index_filter: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
-        types: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        types: t.Optional[t.Sequence[str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the information about the capabilities of fields among multiple indices.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases used
@@ -1658,14 +1560,15 @@
             expressions match hidden data streams. Supports comma-separated values, such
             as `open,hidden`.
         :param fields: List of fields to retrieve capabilities for. Wildcard (`*`) expressions
             are supported.
         :param filters: An optional set of filters: can include +metadata,-metadata,-nested,-multifield,-parent
         :param ignore_unavailable: If `true`, missing or closed indices are not included
             in the response.
+        :param include_empty_fields: If false, empty fields are not included in the response.
         :param include_unmapped: If true, unmapped fields are included in the response.
         :param index_filter: Allows to filter indices if the provided query rewrites
             to match_none on every shard.
         :param runtime_mappings: Defines ad-hoc runtime fields in the request similar
             to the way it is done in search requests. These fields exist only as part
             of the query and take precedence over fields defined with the same name in
             the index mappings.
@@ -1673,96 +1576,94 @@
             list
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_field_caps"
         else:
             __path = "/_field_caps"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if filters is not None:
             __query["filters"] = filters
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
+        if include_empty_fields is not None:
+            __query["include_empty_fields"] = include_empty_fields
         if include_unmapped is not None:
             __query["include_unmapped"] = include_unmapped
-        if index_filter is not None:
-            __body["index_filter"] = index_filter
         if pretty is not None:
             __query["pretty"] = pretty
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
         if types is not None:
             __query["types"] = types
         if not __body:
+            if fields is not None:
+                __body["fields"] = fields
+            if index_filter is not None:
+                __body["index_filter"] = index_filter
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def get(
+    async def get(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force_synthetic_source: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns a document.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html>`_
 
         :param index: Name of the index that contains the document.
         :param id: Unique identifier of the document.
+        :param force_synthetic_source: Should this request force synthetic _source? Use
+            this to test if the mapping supports synthetic _source and to get a sense
+            of the worst case performance. Fetches with this enabled will be slower the
+            enabling synthetic source natively in the index.
         :param preference: Specifies the node or shard the operation should be performed
             on. Random by default.
         :param realtime: If `true`, the request is real-time as opposed to near-real-time.
         :param refresh: If true, Elasticsearch refreshes the affected shards to make
             this operation visible to search. If false, do nothing with refreshes.
         :param routing: Target the specified primary shard.
         :param source: True or false to return the _source field or not, or a list of
@@ -1785,14 +1686,16 @@
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/{_quote(index)}/_doc/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if force_synthetic_source is not None:
+            __query["force_synthetic_source"] = force_synthetic_source
         if human is not None:
             __query["human"] = human
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if realtime is not None:
@@ -1810,27 +1713,25 @@
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_script(
+    async def get_script(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -1852,52 +1753,42 @@
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def get_source(
+    async def get_source(
         self,
         *,
         index: str,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the source of a document.
@@ -1955,31 +1846,30 @@
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
         body_name="document",
     )
-    def index(
+    async def index(
         self,
         *,
         index: str,
-        document: t.Mapping[str, t.Any],
+        document: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
         id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_primary_term: t.Optional[int] = None,
         if_seq_no: t.Optional[int] = None,
         op_type: t.Optional[t.Union["t.Literal['create', 'index']", str]] = None,
         pipeline: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
@@ -2032,16 +1922,20 @@
         :param version_type: Specific version type: `external`, `external_gte`.
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to all or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
-        if document is None:
-            raise ValueError("Empty value passed for parameter 'document'")
+        if document is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'document' and 'body', one of them should be set."
+            )
+        elif document is not None and body is not None:
+            raise ValueError("Cannot set both 'document' and 'body'")
         if index not in SKIP_IN_PATH and id not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_doc/{_quote(id)}"
             __method = "PUT"
         elif index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_doc"
             __method = "POST"
         else:
@@ -2073,28 +1967,26 @@
             __query["timeout"] = timeout
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
-        __body = document
+        __body = document if document is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             __method, __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    def info(
+    async def info(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns basic information about the cluster.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/index.html>`_
@@ -2106,66 +1998,60 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "ids"),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def mget(
+    async def mget(
         self,
         *,
         index: t.Optional[str] = None,
-        docs: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force_synthetic_source: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        ids: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        ids: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
-        source: t.Optional[
-            t.Union[bool, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source: t.Optional[t.Union[bool, t.Union[str, t.Sequence[str]]]] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to get multiple documents in one request.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html>`_
 
         :param index: Name of the index to retrieve documents from when `ids` are specified,
             or when a document in the `docs` array does not specify an index.
         :param docs: The documents you want to retrieve. Required if no index is specified
             in the request URI.
+        :param force_synthetic_source: Should this request force synthetic _source? Use
+            this to test if the mapping supports synthetic _source and to get a sense
+            of the worst case performance. Fetches with this enabled will be slower the
+            enabling synthetic source natively in the index.
         :param ids: The IDs of the documents you want to retrieve. Allowed when the index
             is specified in the request URI.
         :param preference: Specifies the node or shard the operation should be performed
             on. Random by default.
         :param realtime: If `true`, the request is real-time as opposed to near-real-time.
         :param refresh: If `true`, the request refreshes relevant shards before retrieving
             documents.
@@ -2183,26 +2069,24 @@
         :param stored_fields: If `true`, retrieves the document fields stored in the
             index rather than the document `_source`.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_mget"
         else:
             __path = "/_mget"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if force_synthetic_source is not None:
+            __query["force_synthetic_source"] = force_synthetic_source
         if human is not None:
             __query["human"] = human
-        if ids is not None:
-            __body["ids"] = ids
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if realtime is not None:
             __query["realtime"] = realtime
         if refresh is not None:
@@ -2213,53 +2097,45 @@
             __query["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if stored_fields is not None:
             __query["stored_fields"] = stored_fields
+        if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if ids is not None:
+                __body["ids"] = ids
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="searches",
     )
-    def msearch(
+    async def msearch(
         self,
         *,
-        searches: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        searches: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         max_concurrent_searches: t.Optional[int] = None,
         max_concurrent_shard_requests: t.Optional[int] = None,
         pre_filter_shard_size: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
@@ -2307,16 +2183,20 @@
         :param routing: Custom routing value used to route search operations to a specific
             shard.
         :param search_type: Indicates whether global term and document frequencies should
             be used when scoring returned documents.
         :param typed_keys: Specifies whether aggregation and suggester names should be
             prefixed by their respective types in the response.
         """
-        if searches is None:
-            raise ValueError("Empty value passed for parameter 'searches'")
+        if searches is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'searches' and 'body', one of them should be set."
+            )
+        elif searches is not None and body is not None:
+            raise ValueError("Cannot set both 'searches' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_msearch"
         else:
             __path = "/_msearch"
         __query: t.Dict[str, t.Any] = {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
@@ -2346,38 +2226,35 @@
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
         if search_type is not None:
             __query["search_type"] = search_type
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        __body = searches
+        __body = searches if searches is not None else body
         __headers = {
             "accept": "application/json",
             "content-type": "application/x-ndjson",
         }
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="search_templates",
     )
-    def msearch_template(
+    async def msearch_template(
         self,
         *,
-        search_templates: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        search_templates: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_concurrent_searches: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
@@ -2399,16 +2276,20 @@
         :param rest_total_hits_as_int: If `true`, the response returns `hits.total` as
             an integer. If `false`, it returns `hits.total` as an object.
         :param search_type: The type of the search operation. Available options: `query_then_fetch`,
             `dfs_query_then_fetch`.
         :param typed_keys: If `true`, the response prefixes aggregation and suggester
             names with their respective types.
         """
-        if search_templates is None:
-            raise ValueError("Empty value passed for parameter 'search_templates'")
+        if search_templates is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'search_templates' and 'body', one of them should be set."
+            )
+        elif search_templates is not None and body is not None:
+            raise ValueError("Cannot set both 'search_templates' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_msearch/template"
         else:
             __path = "/_msearch/template"
         __query: t.Dict[str, t.Any] = {}
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
@@ -2424,55 +2305,50 @@
             __query["pretty"] = pretty
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if search_type is not None:
             __query["search_type"] = search_type
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        __body = search_templates
+        __body = search_templates if search_templates is not None else body
         __headers = {
             "accept": "application/json",
             "content-type": "application/x-ndjson",
         }
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "ids"),
     )
-    def mtermvectors(
+    async def mtermvectors(
         self,
         *,
         index: t.Optional[str] = None,
-        docs: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
         field_statistics: t.Optional[bool] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ids: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        ids: t.Optional[t.Sequence[str]] = None,
         offsets: t.Optional[bool] = None,
         payloads: t.Optional[bool] = None,
         positions: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         term_statistics: t.Optional[bool] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns multiple termvectors in one request.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html>`_
 
         :param index: Name of the index that contains the documents.
@@ -2496,30 +2372,26 @@
         :param version: If `true`, returns the document version as part of a hit.
         :param version_type: Specific version type.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_mtermvectors"
         else:
             __path = "/_mtermvectors"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if field_statistics is not None:
             __query["field_statistics"] = field_statistics
         if fields is not None:
             __query["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ids is not None:
-            __body["ids"] = ids
         if offsets is not None:
             __query["offsets"] = offsets
         if payloads is not None:
             __query["payloads"] = payloads
         if positions is not None:
             __query["positions"] = positions
         if preference is not None:
@@ -2533,50 +2405,43 @@
         if term_statistics is not None:
             __query["term_statistics"] = term_statistics
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if ids is not None:
+                __body["ids"] = ids
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    def open_point_in_time(
+    async def open_point_in_time(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         keep_alive: t.Union["t.Literal[-1]", "t.Literal[0]", str],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -2618,37 +2483,36 @@
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if routing is not None:
             __query["routing"] = routing
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("script",),
     )
-    def put_script(
+    async def put_script(
         self,
         *,
         id: str,
-        script: t.Mapping[str, t.Any],
+        script: t.Optional[t.Mapping[str, t.Any]] = None,
         context: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates a script.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html>`_
 
         :param id: Identifier for the stored script or search template. Must be unique
@@ -2662,81 +2526,69 @@
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if script is None:
+        if script is None and body is None:
             raise ValueError("Empty value passed for parameter 'script'")
         if id not in SKIP_IN_PATH and context not in SKIP_IN_PATH:
             __path = f"/_scripts/{_quote(id)}/{_quote(context)}"
         elif id not in SKIP_IN_PATH:
             __path = f"/_scripts/{_quote(id)}"
         else:
             raise ValueError("Couldn't find a path for the given parameters")
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if script is not None:
-            __body["script"] = script
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if script is not None:
+                __body["script"] = script
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("requests", "metric"),
     )
-    def rank_eval(
+    async def rank_eval(
         self,
         *,
-        requests: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        requests: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         metric: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         search_type: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to evaluate the quality of ranked search results over a set of typical
         search queries
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-rank-eval.html>`_
 
@@ -2754,60 +2606,59 @@
         :param expand_wildcards: Whether to expand wildcard expression to concrete indices
             that are open, closed or both.
         :param ignore_unavailable: If `true`, missing or closed indices are not included
             in the response.
         :param metric: Definition of the evaluation metric to calculate.
         :param search_type: Search operation type
         """
-        if requests is None:
+        if requests is None and body is None:
             raise ValueError("Empty value passed for parameter 'requests'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_rank_eval"
         else:
             __path = "/_rank_eval"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if requests is not None:
-            __body["requests"] = requests
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if metric is not None:
-            __body["metric"] = metric
         if pretty is not None:
             __query["pretty"] = pretty
         if search_type is not None:
             __query["search_type"] = search_type
+        if not __body:
+            if requests is not None:
+                __body["requests"] = requests
+            if metric is not None:
+                __body["metric"] = metric
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("dest", "source", "conflicts", "max_docs", "script", "size"),
     )
-    def reindex(
+    async def reindex(
         self,
         *,
-        dest: t.Mapping[str, t.Any],
-        source: t.Mapping[str, t.Any],
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
         conflicts: t.Optional[t.Union["t.Literal['abort', 'proceed']", str]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_docs: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[bool] = None,
         requests_per_second: t.Optional[float] = None,
         require_alias: t.Optional[bool] = None,
         script: t.Optional[t.Mapping[str, t.Any]] = None,
@@ -2815,14 +2666,15 @@
         size: t.Optional[int] = None,
         slices: t.Optional[t.Union[int, t.Union["t.Literal['auto']", str]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
         wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to copy documents from one index to another, optionally filtering the
         source documents by a query, changing the destination index settings, or fetching
         the documents from a remote cluster.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html>`_
@@ -2847,79 +2699,79 @@
             mapping updates, and waiting for active shards.
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to `all` or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         :param wait_for_completion: If `true`, the request blocks until the operation
             is complete.
         """
-        if dest is None:
+        if dest is None and body is None:
             raise ValueError("Empty value passed for parameter 'dest'")
-        if source is None:
+        if source is None and body is None:
             raise ValueError("Empty value passed for parameter 'source'")
         __path = "/_reindex"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if dest is not None:
-            __body["dest"] = dest
-        if source is not None:
-            __body["source"] = source
-        if conflicts is not None:
-            __body["conflicts"] = conflicts
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if max_docs is not None:
-            __body["max_docs"] = max_docs
         if pretty is not None:
             __query["pretty"] = pretty
         if refresh is not None:
             __query["refresh"] = refresh
         if requests_per_second is not None:
             __query["requests_per_second"] = requests_per_second
         if require_alias is not None:
             __query["require_alias"] = require_alias
-        if script is not None:
-            __body["script"] = script
         if scroll is not None:
             __query["scroll"] = scroll
-        if size is not None:
-            __body["size"] = size
         if slices is not None:
             __query["slices"] = slices
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
+        if not __body:
+            if dest is not None:
+                __body["dest"] = dest
+            if source is not None:
+                __body["source"] = source
+            if conflicts is not None:
+                __body["conflicts"] = conflicts
+            if max_docs is not None:
+                __body["max_docs"] = max_docs
+            if script is not None:
+                __body["script"] = script
+            if size is not None:
+                __body["size"] = size
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("file", "params", "source"),
         ignore_deprecated_options={"params"},
     )
-    def render_search_template(
+    async def render_search_template(
         self,
         *,
         id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         file: t.Optional[str] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         params: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         source: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to use the Mustache language to pre-render a search definition.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/render-search-template-api.html>`_
 
         :param id: ID of the search template to render. If no `source` is specified,
@@ -2932,213 +2784,227 @@
             If no `id` or `<templated-id>` is specified, this parameter is required.
         """
         if id not in SKIP_IN_PATH:
             __path = f"/_render/template/{_quote(id)}"
         else:
             __path = "/_render/template"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if file is not None:
-            __body["file"] = file
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if params is not None:
-            __body["params"] = params
         if pretty is not None:
             __query["pretty"] = pretty
-        if source is not None:
-            __body["source"] = source
+        if not __body:
+            if file is not None:
+                __body["file"] = file
+            if params is not None:
+                __body["params"] = params
+            if source is not None:
+                __body["source"] = source
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("context", "context_setup", "script"),
     )
-    def scripts_painless_execute(
+    async def scripts_painless_execute(
         self,
         *,
         context: t.Optional[str] = None,
         context_setup: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         script: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows an arbitrary script to be executed and a result to be returned
 
         `<https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html>`_
 
         :param context: The context that the script should run in.
         :param context_setup: Additional parameters for the `context`.
         :param script: The Painless script to execute.
         """
         __path = "/_scripts/painless/_execute"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if context is not None:
-            __body["context"] = context
-        if context_setup is not None:
-            __body["context_setup"] = context_setup
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if script is not None:
-            __body["script"] = script
+        if not __body:
+            if context is not None:
+                __body["context"] = context
+            if context_setup is not None:
+                __body["context_setup"] = context_setup
+            if script is not None:
+                __body["script"] = script
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("scroll_id", "scroll"),
     )
-    def scroll(
+    async def scroll(
         self,
         *,
-        scroll_id: str,
+        scroll_id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to retrieve a large numbers of results from a single search request.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll>`_
 
         :param scroll_id: Scroll ID of the search.
         :param rest_total_hits_as_int: If true, the API response’s hit.total property
             is returned as an integer. If false, the API response’s hit.total property
             is returned as an object.
         :param scroll: Period to retain the search context for scrolling.
         """
-        if scroll_id is None:
+        if scroll_id is None and body is None:
             raise ValueError("Empty value passed for parameter 'scroll_id'")
         __path = "/_search/scroll"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if scroll_id is not None:
-            __body["scroll_id"] = scroll_id
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
-        if scroll is not None:
-            __body["scroll"] = scroll
+        if not __body:
+            if scroll_id is not None:
+                __body["scroll_id"] = scroll_id
+            if scroll is not None:
+                __body["scroll"] = scroll
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "aggs",
+            "collapse",
+            "docvalue_fields",
+            "explain",
+            "ext",
+            "fields",
+            "from_",
+            "highlight",
+            "indices_boost",
+            "knn",
+            "min_score",
+            "pit",
+            "post_filter",
+            "profile",
+            "query",
+            "rank",
+            "rescore",
+            "runtime_mappings",
+            "script_fields",
+            "search_after",
+            "seq_no_primary_term",
+            "size",
+            "slice",
+            "sort",
+            "source",
+            "stats",
+            "stored_fields",
+            "suggest",
+            "terminate_after",
+            "timeout",
+            "track_scores",
+            "track_total_hits",
+            "version",
+        ),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
             "from": "from_",
         },
     )
-    def search(
+    async def search(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         allow_partial_search_results: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         batched_reduce_size: t.Optional[int] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         collapse: t.Optional[t.Mapping[str, t.Any]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
-        docvalue_fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        docvalue_fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
         ext: t.Optional[t.Mapping[str, t.Any]] = None,
-        fields: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        force_synthetic_source: t.Optional[bool] = None,
         from_: t.Optional[int] = None,
         highlight: t.Optional[t.Mapping[str, t.Any]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indices_boost: t.Optional[
-            t.Union[t.List[t.Mapping[str, float]], t.Tuple[t.Mapping[str, float], ...]]
-        ] = None,
+        indices_boost: t.Optional[t.Sequence[t.Mapping[str, float]]] = None,
         knn: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         lenient: t.Optional[bool] = None,
         max_concurrent_shard_requests: t.Optional[int] = None,
         min_compatible_shard_node: t.Optional[str] = None,
         min_score: t.Optional[float] = None,
         pit: t.Optional[t.Mapping[str, t.Any]] = None,
         post_filter: t.Optional[t.Mapping[str, t.Any]] = None,
@@ -3147,71 +3013,55 @@
         pretty: t.Optional[bool] = None,
         profile: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         rank: t.Optional[t.Mapping[str, t.Any]] = None,
         request_cache: t.Optional[bool] = None,
         rescore: t.Optional[
-            t.Union[
-                t.Mapping[str, t.Any],
-                t.Union[
-                    t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-                ],
-            ]
+            t.Union[t.Mapping[str, t.Any], t.Sequence[t.Mapping[str, t.Any]]]
         ] = None,
         rest_total_hits_as_int: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         search_after: t.Optional[
-            t.Union[
-                t.List[t.Union[None, bool, float, int, str, t.Any]],
-                t.Tuple[t.Union[None, bool, float, int, str, t.Any], ...],
-            ]
+            t.Sequence[t.Union[None, bool, float, int, str, t.Any]]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         seq_no_primary_term: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
         source: t.Optional[t.Union[bool, t.Mapping[str, t.Any]]] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stored_fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
+        stored_fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         suggest: t.Optional[t.Mapping[str, t.Any]] = None,
         suggest_field: t.Optional[str] = None,
         suggest_mode: t.Optional[
             t.Union["t.Literal['always', 'missing', 'popular']", str]
         ] = None,
         suggest_size: t.Optional[int] = None,
         suggest_text: t.Optional[str] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[str] = None,
         track_scores: t.Optional[bool] = None,
         track_total_hits: t.Optional[t.Union[bool, int]] = None,
         typed_keys: t.Optional[bool] = None,
         version: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns results matching a query.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -3255,14 +3105,18 @@
             as `open,hidden`.
         :param explain: If true, returns detailed information about score computation
             as part of a hit.
         :param ext: Configuration of search extensions defined by Elasticsearch plugins.
         :param fields: Array of wildcard (`*`) patterns. The request returns values for
             field names matching these patterns in the `hits.fields` property of the
             response.
+        :param force_synthetic_source: Should this request force synthetic _source? Use
+            this to test if the mapping supports synthetic _source and to get a sense
+            of the worst case performance. Fetches with this enabled will be slower the
+            enabling synthetic source natively in the index.
         :param from_: Starting document offset. Needs to be non-negative. By default,
             you cannot page through more than 10,000 hits using the `from` and `size`
             parameters. To page through more hits, use the `search_after` parameter.
         :param highlight: Specifies the highlighter to use for retrieving highlighted
             snippets from one or more fields in your search results.
         :param ignore_throttled: If `true`, concrete, expanded or aliased indices will
             be ignored when frozen.
@@ -3396,213 +3250,225 @@
             by their respective types in the response.
         :param version: If true, returns document version as part of a hit.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_search"
         else:
             __path = "/_search"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
             )
         ):
             __query["sort"] = sort
             sort = None
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
-        if aggs is not None:
-            __body["aggs"] = aggs
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if allow_partial_search_results is not None:
             __query["allow_partial_search_results"] = allow_partial_search_results
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
         if batched_reduce_size is not None:
             __query["batched_reduce_size"] = batched_reduce_size
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
-        if collapse is not None:
-            __body["collapse"] = collapse
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
             __query["df"] = df
-        if docvalue_fields is not None:
-            __body["docvalue_fields"] = docvalue_fields
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if explain is not None:
-            __body["explain"] = explain
-        if ext is not None:
-            __body["ext"] = ext
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_ is not None:
-            __body["from"] = from_
-        if highlight is not None:
-            __body["highlight"] = highlight
+        if force_synthetic_source is not None:
+            __query["force_synthetic_source"] = force_synthetic_source
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indices_boost is not None:
-            __body["indices_boost"] = indices_boost
-        if knn is not None:
-            __body["knn"] = knn
         if lenient is not None:
             __query["lenient"] = lenient
         if max_concurrent_shard_requests is not None:
             __query["max_concurrent_shard_requests"] = max_concurrent_shard_requests
         if min_compatible_shard_node is not None:
             __query["min_compatible_shard_node"] = min_compatible_shard_node
-        if min_score is not None:
-            __body["min_score"] = min_score
-        if pit is not None:
-            __body["pit"] = pit
-        if post_filter is not None:
-            __body["post_filter"] = post_filter
         if pre_filter_shard_size is not None:
             __query["pre_filter_shard_size"] = pre_filter_shard_size
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if profile is not None:
-            __body["profile"] = profile
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
-        if rank is not None:
-            __body["rank"] = rank
         if request_cache is not None:
             __query["request_cache"] = request_cache
-        if rescore is not None:
-            __body["rescore"] = rescore
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
         if scroll is not None:
             __query["scroll"] = scroll
-        if search_after is not None:
-            __body["search_after"] = search_after
         if search_type is not None:
             __query["search_type"] = search_type
-        if seq_no_primary_term is not None:
-            __body["seq_no_primary_term"] = seq_no_primary_term
-        if size is not None:
-            __body["size"] = size
-        if slice is not None:
-            __body["slice"] = slice
-        if sort is not None:
-            __body["sort"] = sort
-        if source is not None:
-            __body["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
-        if stats is not None:
-            __body["stats"] = stats
-        if stored_fields is not None:
-            __body["stored_fields"] = stored_fields
-        if suggest is not None:
-            __body["suggest"] = suggest
         if suggest_field is not None:
             __query["suggest_field"] = suggest_field
         if suggest_mode is not None:
             __query["suggest_mode"] = suggest_mode
         if suggest_size is not None:
             __query["suggest_size"] = suggest_size
         if suggest_text is not None:
             __query["suggest_text"] = suggest_text
-        if terminate_after is not None:
-            __body["terminate_after"] = terminate_after
-        if timeout is not None:
-            __body["timeout"] = timeout
-        if track_scores is not None:
-            __body["track_scores"] = track_scores
-        if track_total_hits is not None:
-            __body["track_total_hits"] = track_total_hits
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if collapse is not None:
+                __body["collapse"] = collapse
+            if docvalue_fields is not None:
+                __body["docvalue_fields"] = docvalue_fields
+            if explain is not None:
+                __body["explain"] = explain
+            if ext is not None:
+                __body["ext"] = ext
+            if fields is not None:
+                __body["fields"] = fields
+            if from_ is not None:
+                __body["from"] = from_
+            if highlight is not None:
+                __body["highlight"] = highlight
+            if indices_boost is not None:
+                __body["indices_boost"] = indices_boost
+            if knn is not None:
+                __body["knn"] = knn
+            if min_score is not None:
+                __body["min_score"] = min_score
+            if pit is not None:
+                __body["pit"] = pit
+            if post_filter is not None:
+                __body["post_filter"] = post_filter
+            if profile is not None:
+                __body["profile"] = profile
+            if query is not None:
+                __body["query"] = query
+            if rank is not None:
+                __body["rank"] = rank
+            if rescore is not None:
+                __body["rescore"] = rescore
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if seq_no_primary_term is not None:
+                __body["seq_no_primary_term"] = seq_no_primary_term
+            if size is not None:
+                __body["size"] = size
+            if slice is not None:
+                __body["slice"] = slice
+            if sort is not None:
+                __body["sort"] = sort
+            if source is not None:
+                __body["_source"] = source
+            if stats is not None:
+                __body["stats"] = stats
+            if stored_fields is not None:
+                __body["stored_fields"] = stored_fields
+            if suggest is not None:
+                __body["suggest"] = suggest
+            if terminate_after is not None:
+                __body["terminate_after"] = terminate_after
+            if timeout is not None:
+                __body["timeout"] = timeout
+            if track_scores is not None:
+                __body["track_scores"] = track_scores
+            if track_total_hits is not None:
+                __body["track_total_hits"] = track_total_hits
+            if version is not None:
+                __body["version"] = version
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggs",
+            "buffer",
+            "exact_bounds",
+            "extent",
+            "fields",
+            "grid_agg",
+            "grid_precision",
+            "grid_type",
+            "query",
+            "runtime_mappings",
+            "size",
+            "sort",
+            "track_total_hits",
+            "with_labels",
+        ),
     )
-    def search_mvt(
+    async def search_mvt(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         field: str,
         zoom: int,
         x: int,
         y: int,
         aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         buffer: t.Optional[int] = None,
         error_trace: t.Optional[bool] = None,
         exact_bounds: t.Optional[bool] = None,
         extent: t.Optional[int] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         grid_agg: t.Optional[t.Union["t.Literal['geohex', 'geotile']", str]] = None,
         grid_precision: t.Optional[int] = None,
         grid_type: t.Optional[
             t.Union["t.Literal['centroid', 'grid', 'point']", str]
         ] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         size: t.Optional[int] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
         track_total_hits: t.Optional[t.Union[bool, int]] = None,
         with_labels: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> BinaryApiResponse:
         """
         Searches a vector tile for geospatial values. Returns results as a binary Mapbox
         vector tile.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-vector-tile-api.html>`_
 
@@ -3656,105 +3522,94 @@
         if zoom in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'zoom'")
         if x in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'x'")
         if y in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'y'")
         __path = f"/{_quote(index)}/_mvt/{_quote(field)}/{_quote(zoom)}/{_quote(x)}/{_quote(y)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
             )
         ):
             __query["sort"] = sort
             sort = None
-        if aggs is not None:
-            __body["aggs"] = aggs
-        if buffer is not None:
-            __body["buffer"] = buffer
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if exact_bounds is not None:
-            __body["exact_bounds"] = exact_bounds
-        if extent is not None:
-            __body["extent"] = extent
-        if fields is not None:
-            __body["fields"] = fields
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if grid_agg is not None:
-            __body["grid_agg"] = grid_agg
-        if grid_precision is not None:
-            __body["grid_precision"] = grid_precision
-        if grid_type is not None:
-            __body["grid_type"] = grid_type
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if size is not None:
-            __body["size"] = size
-        if sort is not None:
-            __body["sort"] = sort
-        if track_total_hits is not None:
-            __body["track_total_hits"] = track_total_hits
-        if with_labels is not None:
-            __body["with_labels"] = with_labels
+        if not __body:
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if buffer is not None:
+                __body["buffer"] = buffer
+            if exact_bounds is not None:
+                __body["exact_bounds"] = exact_bounds
+            if extent is not None:
+                __body["extent"] = extent
+            if fields is not None:
+                __body["fields"] = fields
+            if grid_agg is not None:
+                __body["grid_agg"] = grid_agg
+            if grid_precision is not None:
+                __body["grid_precision"] = grid_precision
+            if grid_type is not None:
+                __body["grid_type"] = grid_type
+            if query is not None:
+                __body["query"] = query
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if size is not None:
+                __body["size"] = size
+            if sort is not None:
+                __body["sort"] = sort
+            if track_total_hits is not None:
+                __body["track_total_hits"] = track_total_hits
+            if with_labels is not None:
+                __body["with_labels"] = with_labels
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/vnd.mapbox-vector-tile"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("explain", "id", "params", "profile", "source"),
         ignore_deprecated_options={"params"},
     )
-    def search_template(
+    async def search_template(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         ccs_minimize_roundtrips: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         id: t.Optional[str] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         params: t.Optional[t.Mapping[str, t.Any]] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
@@ -3763,14 +3618,15 @@
         routing: t.Optional[str] = None,
         scroll: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         source: t.Optional[str] = None,
         typed_keys: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows to use the Mustache language to pre-render a search definition.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -3812,80 +3668,88 @@
             names with their respective types.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_search/template"
         else:
             __path = "/_search/template"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if ccs_minimize_roundtrips is not None:
             __query["ccs_minimize_roundtrips"] = ccs_minimize_roundtrips
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if explain is not None:
-            __body["explain"] = explain
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if id is not None:
-            __body["id"] = id
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if params is not None:
-            __body["params"] = params
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if profile is not None:
-            __body["profile"] = profile
         if rest_total_hits_as_int is not None:
             __query["rest_total_hits_as_int"] = rest_total_hits_as_int
         if routing is not None:
             __query["routing"] = routing
         if scroll is not None:
             __query["scroll"] = scroll
         if search_type is not None:
             __query["search_type"] = search_type
-        if source is not None:
-            __body["source"] = source
         if typed_keys is not None:
             __query["typed_keys"] = typed_keys
+        if not __body:
+            if explain is not None:
+                __body["explain"] = explain
+            if id is not None:
+                __body["id"] = id
+            if params is not None:
+                __body["params"] = params
+            if profile is not None:
+                __body["profile"] = profile
+            if source is not None:
+                __body["source"] = source
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "field",
+            "case_insensitive",
+            "index_filter",
+            "search_after",
+            "size",
+            "string",
+            "timeout",
+        ),
     )
-    def terms_enum(
+    async def terms_enum(
         self,
         *,
         index: str,
-        field: str,
+        field: t.Optional[str] = None,
         case_insensitive: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         index_filter: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         search_after: t.Optional[str] = None,
         size: t.Optional[int] = None,
         string: t.Optional[str] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         The terms enum API can be used to discover terms in the index that begin with
         the provided string. It is designed for low-latency look-ups used in auto-complete
         scenarios.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-terms-enum.html>`_
@@ -3905,82 +3769,80 @@
             as the search_after parameter for a subsequent request.
         :param timeout: The maximum length of time to spend collecting results. Defaults
             to "1s" (one second). If the timeout is exceeded the complete flag set to
             false in the response and the results may be partial or empty.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
-        if field is None:
+        if field is None and body is None:
             raise ValueError("Empty value passed for parameter 'field'")
         __path = f"/{_quote(index)}/_terms_enum"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if field is not None:
-            __body["field"] = field
-        if case_insensitive is not None:
-            __body["case_insensitive"] = case_insensitive
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index_filter is not None:
-            __body["index_filter"] = index_filter
         if pretty is not None:
             __query["pretty"] = pretty
-        if search_after is not None:
-            __body["search_after"] = search_after
-        if size is not None:
-            __body["size"] = size
-        if string is not None:
-            __body["string"] = string
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if field is not None:
+                __body["field"] = field
+            if case_insensitive is not None:
+                __body["case_insensitive"] = case_insensitive
+            if index_filter is not None:
+                __body["index_filter"] = index_filter
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if size is not None:
+                __body["size"] = size
+            if string is not None:
+                __body["string"] = string
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("doc", "filter", "per_field_analyzer"),
     )
-    def termvectors(
+    async def termvectors(
         self,
         *,
         index: str,
         id: t.Optional[str] = None,
         doc: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         field_statistics: t.Optional[bool] = None,
-        fields: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        fields: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         filter: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         offsets: t.Optional[bool] = None,
         payloads: t.Optional[bool] = None,
         per_field_analyzer: t.Optional[t.Mapping[str, str]] = None,
         positions: t.Optional[bool] = None,
         preference: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         realtime: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         term_statistics: t.Optional[bool] = None,
         version: t.Optional[int] = None,
         version_type: t.Optional[
             t.Union["t.Literal['external', 'external_gte', 'force', 'internal']", str]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns information and statistics about terms in the fields of a particular
         document.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html>`_
 
@@ -4011,36 +3873,30 @@
             raise ValueError("Empty value passed for parameter 'index'")
         if index not in SKIP_IN_PATH and id not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_termvectors/{_quote(id)}"
         elif index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_termvectors"
         else:
             raise ValueError("Couldn't find a path for the given parameters")
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if doc is not None:
-            __body["doc"] = doc
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if field_statistics is not None:
             __query["field_statistics"] = field_statistics
         if fields is not None:
             __query["fields"] = fields
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if offsets is not None:
             __query["offsets"] = offsets
         if payloads is not None:
             __query["payloads"] = payloads
-        if per_field_analyzer is not None:
-            __body["per_field_analyzer"] = per_field_analyzer
         if positions is not None:
             __query["positions"] = positions
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
         if realtime is not None:
@@ -4050,67 +3906,77 @@
         if term_statistics is not None:
             __query["term_statistics"] = term_statistics
         if version is not None:
             __query["version"] = version
         if version_type is not None:
             __query["version_type"] = version_type
         if not __body:
+            if doc is not None:
+                __body["doc"] = doc
+            if filter is not None:
+                __body["filter"] = filter
+            if per_field_analyzer is not None:
+                __body["per_field_analyzer"] = per_field_analyzer
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "detect_noop",
+            "doc",
+            "doc_as_upsert",
+            "script",
+            "scripted_upsert",
+            "source",
+            "upsert",
+        ),
         parameter_aliases={
             "_source": "source",
             "_source_excludes": "source_excludes",
             "_source_includes": "source_includes",
         },
     )
-    def update(
+    async def update(
         self,
         *,
         index: str,
         id: str,
         detect_noop: t.Optional[bool] = None,
         doc: t.Optional[t.Mapping[str, t.Any]] = None,
         doc_as_upsert: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         if_primary_term: t.Optional[int] = None,
         if_seq_no: t.Optional[int] = None,
         lang: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         require_alias: t.Optional[bool] = None,
         retry_on_conflict: t.Optional[int] = None,
         routing: t.Optional[str] = None,
         script: t.Optional[t.Mapping[str, t.Any]] = None,
         scripted_upsert: t.Optional[bool] = None,
         source: t.Optional[t.Union[bool, t.Mapping[str, t.Any]]] = None,
-        source_excludes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        source_includes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        source_excludes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        source_includes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         upsert: t.Optional[t.Mapping[str, t.Any]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates a document with a script or partial document.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html>`_
 
         :param index: The name of the index
@@ -4150,22 +4016,16 @@
             to 1 meaning the primary shard.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/{_quote(index)}/_update/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if detect_noop is not None:
-            __body["detect_noop"] = detect_noop
-        if doc is not None:
-            __body["doc"] = doc
-        if doc_as_upsert is not None:
-            __body["doc_as_upsert"] = doc_as_upsert
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if if_primary_term is not None:
@@ -4180,71 +4040,66 @@
             __query["refresh"] = refresh
         if require_alias is not None:
             __query["require_alias"] = require_alias
         if retry_on_conflict is not None:
             __query["retry_on_conflict"] = retry_on_conflict
         if routing is not None:
             __query["routing"] = routing
-        if script is not None:
-            __body["script"] = script
-        if scripted_upsert is not None:
-            __body["scripted_upsert"] = scripted_upsert
-        if source is not None:
-            __body["_source"] = source
         if source_excludes is not None:
             __query["_source_excludes"] = source_excludes
         if source_includes is not None:
             __query["_source_includes"] = source_includes
         if timeout is not None:
             __query["timeout"] = timeout
-        if upsert is not None:
-            __body["upsert"] = upsert
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
+        if not __body:
+            if detect_noop is not None:
+                __body["detect_noop"] = detect_noop
+            if doc is not None:
+                __body["doc"] = doc
+            if doc_as_upsert is not None:
+                __body["doc_as_upsert"] = doc_as_upsert
+            if script is not None:
+                __body["script"] = script
+            if scripted_upsert is not None:
+                __body["scripted_upsert"] = scripted_upsert
+            if source is not None:
+                __body["_source"] = source
+            if upsert is not None:
+                __body["upsert"] = upsert
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("conflicts", "max_docs", "query", "script", "slice"),
         parameter_aliases={"from": "from_"},
     )
-    def update_by_query(
+    async def update_by_query(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         conflicts: t.Optional[t.Union["t.Literal['abort', 'proceed']", str]] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         max_docs: t.Optional[int] = None,
         pipeline: t.Optional[str] = None,
         preference: t.Optional[str] = None,
@@ -4261,28 +4116,30 @@
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         search_type: t.Optional[
             t.Union["t.Literal['dfs_query_then_fetch', 'query_then_fetch']", str]
         ] = None,
         slice: t.Optional[t.Mapping[str, t.Any]] = None,
         slices: t.Optional[t.Union[int, t.Union["t.Literal['auto']", str]]] = None,
-        sort: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        stats: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        sort: t.Optional[t.Sequence[str]] = None,
+        stats: t.Optional[t.Sequence[str]] = None,
         terminate_after: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[bool] = None,
         version_type: t.Optional[bool] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
         wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Performs an update on every document in the index without changing the source,
-        for example to pick up a mapping change.
+        Updates documents that match the specified query. If no query is specified, performs
+        an update on every document in the index without changing the source, for example
+        to pick up a mapping change.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
             Supports wildcards (`*`). To search all data streams or indices, omit this
             parameter or use `*` or `_all`.
         :param allow_no_indices: If `false`, the request returns an error if any wildcard
@@ -4352,15 +4209,15 @@
         :param wait_for_completion: If `true`, the request blocks until the operation
             is complete.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_update_by_query"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
@@ -4370,16 +4227,14 @@
             sort = None
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
             __query["analyzer"] = analyzer
-        if conflicts is not None:
-            __body["conflicts"] = conflicts
         if default_operator is not None:
             __query["default_operator"] = default_operator
         if df is not None:
             __query["df"] = df
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
@@ -4390,44 +4245,36 @@
             __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if lenient is not None:
             __query["lenient"] = lenient
-        if max_docs is not None:
-            __body["max_docs"] = max_docs
         if pipeline is not None:
             __query["pipeline"] = pipeline
         if preference is not None:
             __query["preference"] = preference
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
         if refresh is not None:
             __query["refresh"] = refresh
         if request_cache is not None:
             __query["request_cache"] = request_cache
         if requests_per_second is not None:
             __query["requests_per_second"] = requests_per_second
         if routing is not None:
             __query["routing"] = routing
-        if script is not None:
-            __body["script"] = script
         if scroll is not None:
             __query["scroll"] = scroll
         if scroll_size is not None:
             __query["scroll_size"] = scroll_size
         if search_timeout is not None:
             __query["search_timeout"] = search_timeout
         if search_type is not None:
             __query["search_type"] = search_type
-        if slice is not None:
-            __body["slice"] = slice
         if slices is not None:
             __query["slices"] = slices
         if sort is not None:
             __query["sort"] = sort
         if stats is not None:
             __query["stats"] = stats
         if terminate_after is not None:
@@ -4439,14 +4286,25 @@
         if version_type is not None:
             __query["version_type"] = version_type
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if wait_for_completion is not None:
             __query["wait_for_completion"] = wait_for_completion
         if not __body:
+            if conflicts is not None:
+                __body["conflicts"] = conflicts
+            if max_docs is not None:
+                __body["max_docs"] = max_docs
+            if query is not None:
+                __body["query"] = query
+            if script is not None:
+                __body["script"] = script
+            if slice is not None:
+                __body["slice"] = slice
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/_base.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/_base.py`

 * *Files 10% similar despite different names*

```diff
@@ -17,37 +17,34 @@
 
 import re
 import warnings
 from typing import Any, Collection, Iterable, Mapping, Optional, Tuple, Union
 
 from elastic_transport import (
     ApiResponse,
+    AsyncTransport,
     BinaryApiResponse,
     HeadApiResponse,
     HttpHeaders,
     ListApiResponse,
     ObjectApiResponse,
     TextApiResponse,
-    Transport,
 )
 from elastic_transport.client_utils import DEFAULT, DefaultType
 
 from ...compat import warn_stacklevel
 from ...exceptions import (
     HTTP_EXCEPTIONS,
     ApiError,
     ElasticsearchWarning,
     UnsupportedProductError,
 )
 from .utils import _base64_auth_header, _quote_query
 
 _WARNING_RE = re.compile(r"\"([^\"]*)\"")
-_COMPAT_MIMETYPE_TEMPLATE = "application/vnd.elasticsearch+%s; compatible-with=8"
-_COMPAT_MIMETYPE_RE = re.compile(r"application/(json|x-ndjson|vnd\.mapbox-vector-tile)")
-_COMPAT_MIMETYPE_SUB = _COMPAT_MIMETYPE_TEMPLATE % (r"\g<1>",)
 
 
 def resolve_auth_headers(
     headers: Optional[Mapping[str, str]],
     http_auth: Union[DefaultType, None, Tuple[str, str], str] = DEFAULT,
     api_key: Union[DefaultType, None, Tuple[str, str], str] = DEFAULT,
     basic_auth: Union[DefaultType, None, Tuple[str, str], str] = DEFAULT,
@@ -104,73 +101,60 @@
         if headers and headers.get("authorization", None) is not None:
             raise ValueError(
                 "Can't set 'Authorization' HTTP header with other authentication options"
             )
         if resolved_api_key:
             headers["authorization"] = f"ApiKey {_base64_auth_header(resolved_api_key)}"
         if resolved_basic_auth:
-            headers[
-                "authorization"
-            ] = f"Basic {_base64_auth_header(resolved_basic_auth)}"
+            headers["authorization"] = (
+                f"Basic {_base64_auth_header(resolved_basic_auth)}"
+            )
         if resolved_bearer_auth:
             headers["authorization"] = f"Bearer {resolved_bearer_auth}"
 
     return headers
 
 
 class BaseClient:
-    def __init__(self, _transport: Transport) -> None:
+    def __init__(self, _transport: AsyncTransport) -> None:
         self._transport = _transport
         self._client_meta: Union[DefaultType, Tuple[Tuple[str, str], ...]] = DEFAULT
         self._headers = HttpHeaders()
         self._request_timeout: Union[DefaultType, Optional[float]] = DEFAULT
         self._ignore_status: Union[DefaultType, Collection[int]] = DEFAULT
         self._max_retries: Union[DefaultType, int] = DEFAULT
         self._retry_on_timeout: Union[DefaultType, bool] = DEFAULT
         self._retry_on_status: Union[DefaultType, Collection[int]] = DEFAULT
         self._verified_elasticsearch = False
 
     @property
-    def transport(self) -> Transport:
+    def transport(self) -> AsyncTransport:
         return self._transport
 
-    def perform_request(
+    async def perform_request(
         self,
         method: str,
         path: str,
         *,
         params: Optional[Mapping[str, Any]] = None,
         headers: Optional[Mapping[str, str]] = None,
         body: Optional[Any] = None,
     ) -> ApiResponse[Any]:
         if headers:
             request_headers = self._headers.copy()
             request_headers.update(headers)
         else:
             request_headers = self._headers
 
-        def mimetype_header_to_compat(header: str) -> None:
-            # Converts all parts of a Accept/Content-Type headers
-            # from application/X -> application/vnd.elasticsearch+X
-            nonlocal request_headers
-            mimetype = request_headers.get(header, None)
-            if mimetype:
-                request_headers[header] = _COMPAT_MIMETYPE_RE.sub(
-                    _COMPAT_MIMETYPE_SUB, mimetype
-                )
-
-        mimetype_header_to_compat("Accept")
-        mimetype_header_to_compat("Content-Type")
-
         if params:
             target = f"{path}?{_quote_query(params)}"
         else:
             target = path
 
-        meta, resp_body = self.transport.perform_request(
+        meta, resp_body = await self.transport.perform_request(
             method,
             target,
             headers=request_headers,
             body=body,
             request_timeout=self._request_timeout,
             max_retries=self._max_retries,
             retry_on_status=self._retry_on_status,
@@ -255,21 +239,21 @@
 
 
 class NamespacedClient(BaseClient):
     def __init__(self, client: "BaseClient") -> None:
         self._client = client
         super().__init__(self._client.transport)
 
-    def perform_request(
+    async def perform_request(
         self,
         method: str,
         path: str,
         *,
         params: Optional[Mapping[str, Any]] = None,
         headers: Optional[Mapping[str, str]] = None,
         body: Optional[Any] = None,
     ) -> ApiResponse[Any]:
         # Use the internal clients .perform_request() implementation
         # so we take advantage of their transport options.
-        return self._client.perform_request(
+        return await self._client.perform_request(
             method, path, params=params, headers=headers, body=body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/autoscaling.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/query_ruleset.py`

 * *Files 27% similar despite different names*

```diff
@@ -19,38 +19,36 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class AutoscalingClient(NamespacedClient):
+class QueryRulesetClient(NamespacedClient):
+
     @_rewrite_parameters()
-    def delete_autoscaling_policy(
+    def delete(
         self,
         *,
-        name: str,
+        ruleset_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes an autoscaling policy. Designed for indirect use by ECE/ESS and ECK.
-        Direct use is not supported.
+        Deletes a query ruleset.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-delete-autoscaling-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-query-ruleset.html>`_
 
-        :param name: the name of the autoscaling policy
+        :param ruleset_id: The unique identifier of the query ruleset to delete
         """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_autoscaling/policy/{_quote(name)}"
+        if ruleset_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'ruleset_id'")
+        __path = f"/_query_rules/{_quote(ruleset_id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
@@ -58,118 +56,125 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_autoscaling_capacity(
+    def get(
         self,
         *,
+        ruleset_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Gets the current autoscaling capacity based on the configured autoscaling policy.
-        Designed for indirect use by ECE/ESS and ECK. Direct use is not supported.
+        Returns the details about a query ruleset.
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-query-ruleset.html>`_
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-get-autoscaling-capacity.html>`_
+        :param ruleset_id: The unique identifier of the query ruleset
         """
-        __path = "/_autoscaling/capacity"
+        if ruleset_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'ruleset_id'")
+        __path = f"/_query_rules/{_quote(ruleset_id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    def get_autoscaling_policy(
+    @_rewrite_parameters(
+        parameter_aliases={"from": "from_"},
+    )
+    def list(
         self,
         *,
-        name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieves an autoscaling policy. Designed for indirect use by ECE/ESS and ECK.
-        Direct use is not supported.
+        Lists query rulesets.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-get-autoscaling-capacity.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/list-query-rulesets.html>`_
 
-        :param name: the name of the autoscaling policy
+        :param from_: Starting offset (default: 0)
+        :param size: specifies a max number of results to get
         """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_autoscaling/policy/{_quote(name)}"
+        __path = "/_query_rules"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if size is not None:
+            __query["size"] = size
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_name="policy",
+        body_fields=("rules",),
     )
-    def put_autoscaling_policy(
+    def put(
         self,
         *,
-        name: str,
-        policy: t.Mapping[str, t.Any],
+        ruleset_id: str,
+        rules: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates a new autoscaling policy. Designed for indirect use by ECE/ESS and ECK.
-        Direct use is not supported.
+        Creates or updates a query ruleset.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/autoscaling-put-autoscaling-policy.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-query-ruleset.html>`_
 
-        :param name: the name of the autoscaling policy
-        :param policy:
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        if policy is None:
-            raise ValueError("Empty value passed for parameter 'policy'")
-        __path = f"/_autoscaling/policy/{_quote(name)}"
+        :param ruleset_id: The unique identifier of the query ruleset to be created or
+            updated
+        :param rules:
+        """
+        if ruleset_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'ruleset_id'")
+        if rules is None and body is None:
+            raise ValueError("Empty value passed for parameter 'rules'")
+        __path = f"/_query_rules/{_quote(ruleset_id)}"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = policy
+        if not __body:
+            if rules is not None:
+                __body["rules"] = rules
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/cat.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/cat.py`

 * *Files 17% similar despite different names*

```diff
@@ -20,51 +20,40 @@
 from elastic_transport import ObjectApiResponse, TextApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class CatClient(NamespacedClient):
+
     @_rewrite_parameters()
     def aliases(
         self,
         *,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Shows information about currently configured aliases to indices including filter
         and routing infos.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html>`_
@@ -124,27 +113,25 @@
 
     @_rewrite_parameters()
     def component_templates(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Returns information about existing component_templates templates.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-component-templates.html>`_
 
@@ -197,29 +184,27 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     def count(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Provides quick access to the document count of the entire cluster, or individual
         indices.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html>`_
@@ -275,27 +260,25 @@
         )
 
     @_rewrite_parameters()
     def help(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         v: t.Optional[bool] = None,
     ) -> TextApiResponse:
         """
         Returns help for the Cat APIs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html>`_
 
@@ -343,53 +326,41 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     def indices(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
-        h: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        h: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         health: t.Optional[t.Union["t.Literal['green', 'red', 'yellow']", str]] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         include_unloaded_segments: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         pri: t.Optional[bool] = None,
-        s: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        s: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Returns information about indices: number of primaries and replicas, document
@@ -473,69 +444,49 @@
         *,
         id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'create_time', 'description', 'dest_index', 'failure_reason', 'id', 'model_memory_limit', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'progress', 'source_index', 'state', 'type', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         time: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Gets configuration and usage information about data frame analytics jobs.
@@ -602,69 +553,49 @@
     @_rewrite_parameters()
     def ml_datafeeds(
         self,
         *,
         datafeed_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['ae', 'bc', 'id', 'na', 'ne', 'ni', 'nn', 's', 'sba', 'sc', 'seah', 'st']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
@@ -739,69 +670,49 @@
         *,
         job_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['assignment_explanation', 'buckets.count', 'buckets.time.exp_avg', 'buckets.time.exp_avg_hour', 'buckets.time.max', 'buckets.time.min', 'buckets.time.total', 'data.buckets', 'data.earliest_record', 'data.empty_buckets', 'data.input_bytes', 'data.input_fields', 'data.input_records', 'data.invalid_dates', 'data.last', 'data.last_empty_bucket', 'data.last_sparse_bucket', 'data.latest_record', 'data.missing_fields', 'data.out_of_order_timestamps', 'data.processed_fields', 'data.processed_records', 'data.sparse_buckets', 'forecasts.memory.avg', 'forecasts.memory.max', 'forecasts.memory.min', 'forecasts.memory.total', 'forecasts.records.avg', 'forecasts.records.max', 'forecasts.records.min', 'forecasts.records.total', 'forecasts.time.avg', 'forecasts.time.max', 'forecasts.time.min', 'forecasts.time.total', 'forecasts.total', 'id', 'model.bucket_allocation_failures', 'model.by_fields', 'model.bytes', 'model.bytes_exceeded', 'model.categorization_status', 'model.categorized_doc_count', 'model.dead_category_count', 'model.failed_category_count', 'model.frequent_category_count', 'model.log_time', 'model.memory_limit', 'model.memory_status', 'model.over_fields', 'model.partition_fields', 'model.rare_category_count', 'model.timestamp', 'model.total_category_count', 'node.address', 'node.ephemeral_id', 'node.id', 'node.name', 'opened_time', 'state']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
@@ -880,70 +791,50 @@
         *,
         model_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         bytes: t.Optional[
             t.Union["t.Literal['b', 'gb', 'kb', 'mb', 'pb', 'tb']", str]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         from_: t.Optional[int] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['create_time', 'created_by', 'data_frame_analytics_id', 'description', 'heap_size', 'id', 'ingest.count', 'ingest.current', 'ingest.failed', 'ingest.pipelines', 'ingest.time', 'license', 'operations', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         size: t.Optional[int] = None,
         v: t.Optional[bool] = None,
     ) -> t.Union[ObjectApiResponse[t.Any], TextApiResponse]:
         """
         Gets configuration and usage information about inference trained models.
@@ -1020,70 +911,50 @@
     )
     def transforms(
         self,
         *,
         transform_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         format: t.Optional[str] = None,
         from_: t.Optional[int] = None,
         h: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         help: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         s: t.Optional[
             t.Union[
+                t.Sequence[
+                    t.Union[
+                        "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
+                        str,
+                    ]
+                ],
                 t.Union[
                     "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
                     str,
                 ],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['changes_last_detection_time', 'checkpoint', 'checkpoint_duration_time_exp_avg', 'checkpoint_progress', 'create_time', 'delete_time', 'description', 'dest_index', 'docs_per_second', 'documents_deleted', 'documents_indexed', 'documents_processed', 'frequency', 'id', 'index_failure', 'index_time', 'index_total', 'indexed_documents_exp_avg', 'last_search_time', 'max_page_search_size', 'pages_processed', 'pipeline', 'processed_documents_exp_avg', 'processing_time', 'reason', 'search_failure', 'search_time', 'search_total', 'source_index', 'state', 'transform_type', 'trigger_count', 'version']",
-                            str,
-                        ],
-                        ...,
-                    ],
-                ],
             ]
         ] = None,
         size: t.Optional[int] = None,
         time: t.Optional[
             t.Union["t.Literal['d', 'h', 'm', 'micros', 'ms', 'nanos', 's']", str]
         ] = None,
         v: t.Optional[bool] = None,
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/cluster.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/synonyms.py`

 * *Files 24% similar despite different names*

```diff
@@ -13,319 +13,302 @@
 #  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 #  KIND, either express or implied.  See the License for the
 #  specific language governing permissions and limitations
 #  under the License.
 
 import typing as t
 
-from elastic_transport import HeadApiResponse, ObjectApiResponse
+from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class ClusterClient(NamespacedClient):
+class SynonymsClient(NamespacedClient):
+
     @_rewrite_parameters()
-    def delete_component_template(
+    async def delete_synonym(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes a component template
+        Deletes a synonym set
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-synonyms-set.html>`_
 
-        :param name: Comma-separated list or wildcard expression of component template
-            names used to limit the request.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_component_template/{_quote(name)}"
+        :param id: The id of the synonyms set to be deleted
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_synonyms/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def exists_component_template(
+    async def delete_synonym_rule(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        set_id: str,
+        rule_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        local: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-    ) -> HeadApiResponse:
+    ) -> ObjectApiResponse[t.Any]:
         """
-        Returns information about whether a particular component template exist
+        Deletes a synonym rule in a synonym set
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-synonym-rule.html>`_
 
-        :param name: Comma-separated list of component template names used to limit the
-            request. Wildcard (*) expressions are supported.
-        :param local: If true, the request retrieves information from the local node
-            only. Defaults to false, which means information is retrieved from the master
-            node.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        __path = f"/_component_template/{_quote(name)}"
+        :param set_id: The id of the synonym set to be updated
+        :param rule_id: The id of the synonym rule to be deleted
+        """
+        if set_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'set_id'")
+        if rule_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'rule_id'")
+        __path = f"/_synonyms/{_quote(set_id)}/{_quote(rule_id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if local is not None:
-            __query["local"] = local
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
-            "HEAD", __path, params=__query, headers=__headers
+        return await self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
         )
 
-    @_rewrite_parameters()
-    def get_component_template(
+    @_rewrite_parameters(
+        parameter_aliases={"from": "from_"},
+    )
+    async def get_synonym(
         self,
         *,
-        name: t.Optional[str] = None,
+        id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        flat_settings: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
-        include_defaults: t.Optional[bool] = None,
-        local: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
+        size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns one or more component templates
+        Retrieves a synonym set
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-synonyms-set.html>`_
 
-        :param name: Comma-separated list of component template names used to limit the
-            request. Wildcard (`*`) expressions are supported.
-        :param flat_settings: If `true`, returns settings in flat format.
-        :param include_defaults: Return all default configurations for the component
-            template (default: false)
-        :param local: If `true`, the request retrieves information from the local node
-            only. If `false`, information is retrieved from the master node.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        """
-        if name not in SKIP_IN_PATH:
-            __path = f"/_component_template/{_quote(name)}"
-        else:
-            __path = "/_component_template"
+        :param id: "The id of the synonyms set to be retrieved
+        :param from_: Starting offset for query rules to be retrieved
+        :param size: specifies a max number of query rules to retrieve
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        __path = f"/_synonyms/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if flat_settings is not None:
-            __query["flat_settings"] = flat_settings
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
-        if include_defaults is not None:
-            __query["include_defaults"] = include_defaults
-        if local is not None:
-            __query["local"] = local
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
+        if size is not None:
+            __query["size"] = size
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def info(
+    async def get_synonym_rule(
+        self,
+        *,
+        set_id: str,
+        rule_id: str,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        human: t.Optional[bool] = None,
+        pretty: t.Optional[bool] = None,
+    ) -> ObjectApiResponse[t.Any]:
+        """
+        Retrieves a synonym rule from a synonym set
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-synonym-rule.html>`_
+
+        :param set_id: The id of the synonym set to retrieve the synonym rule from
+        :param rule_id: The id of the synonym rule to retrieve
+        """
+        if set_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'set_id'")
+        if rule_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'rule_id'")
+        __path = f"/_synonyms/{_quote(set_id)}/{_quote(rule_id)}"
+        __query: t.Dict[str, t.Any] = {}
+        if error_trace is not None:
+            __query["error_trace"] = error_trace
+        if filter_path is not None:
+            __query["filter_path"] = filter_path
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        __headers = {"accept": "application/json"}
+        return await self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
+        )
+
+    @_rewrite_parameters(
+        parameter_aliases={"from": "from_"},
+    )
+    async def get_synonyms_sets(
         self,
         *,
-        target: t.Union[
-            t.Union[
-                "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']", str
-            ],
-            t.Union[
-                t.List[
-                    t.Union[
-                        "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']",
-                        str,
-                    ]
-                ],
-                t.Tuple[
-                    t.Union[
-                        "t.Literal['_all', 'http', 'ingest', 'script', 'thread_pool']",
-                        str,
-                    ],
-                    ...,
-                ],
-            ],
-        ],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns different information about the cluster.
+        Retrieves a summary of all defined synonym sets
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-info.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/list-synonyms-sets.html>`_
 
-        :param target: Limits the information returned to the specific target. Supports
-            a comma-separated list, such as http,ingest.
+        :param from_: Starting offset
+        :param size: specifies a max number of results to get
         """
-        if target in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'target'")
-        __path = f"/_info/{_quote(target)}"
+        __path = "/_synonyms"
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
+        if from_ is not None:
+            __query["from"] = from_
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if size is not None:
+            __query["size"] = size
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
-        parameter_aliases={"_meta": "meta"},
+        body_fields=("synonyms_set",),
+    )
+    async def put_synonym(
+        self,
+        *,
+        id: str,
+        synonyms_set: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        human: t.Optional[bool] = None,
+        pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
+    ) -> ObjectApiResponse[t.Any]:
+        """
+        Creates or updates a synonyms set
+
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-synonyms-set.html>`_
+
+        :param id: The id of the synonyms set to be created or updated
+        :param synonyms_set: The synonym set information to update
+        """
+        if id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'id'")
+        if synonyms_set is None and body is None:
+            raise ValueError("Empty value passed for parameter 'synonyms_set'")
+        __path = f"/_synonyms/{_quote(id)}"
+        __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
+        if error_trace is not None:
+            __query["error_trace"] = error_trace
+        if filter_path is not None:
+            __query["filter_path"] = filter_path
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        if not __body:
+            if synonyms_set is not None:
+                __body["synonyms_set"] = synonyms_set
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return await self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers, body=__body
+        )
+
+    @_rewrite_parameters(
+        body_fields=("synonyms",),
     )
-    def put_component_template(
+    async def put_synonym_rule(
         self,
         *,
-        name: str,
-        template: t.Mapping[str, t.Any],
-        allow_auto_create: t.Optional[bool] = None,
-        create: t.Optional[bool] = None,
+        set_id: str,
+        rule_id: str,
+        synonyms: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates or updates a component template
+        Creates or updates a synonym rule in a synonym set
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-component-template.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-synonym-rule.html>`_
 
-        :param name: Name of the component template to create. Elasticsearch includes
-            the following built-in component templates: `logs-mappings`; 'logs-settings`;
-            `metrics-mappings`; `metrics-settings`;`synthetics-mapping`; `synthetics-settings`.
-            Elastic Agent uses these templates to configure backing indices for its data
-            streams. If you use Elastic Agent and want to overwrite one of these templates,
-            set the `version` for your replacement template higher than the current version.
-            If you don’t use Elastic Agent and want to disable all built-in component
-            and index templates, set `stack.templates.enabled` to `false` using the cluster
-            update settings API.
-        :param template: The template to be applied which includes mappings, settings,
-            or aliases configuration.
-        :param allow_auto_create: This setting overrides the value of the `action.auto_create_index`
-            cluster setting. If set to `true` in a template, then indices can be automatically
-            created using that template even if auto-creation of indices is disabled
-            via `actions.auto_create_index`. If set to `false` then data streams matching
-            the template must always be explicitly created.
-        :param create: If `true`, this request cannot replace or update existing component
-            templates.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param meta: Optional user metadata about the component template. May have any
-            contents. This map is not automatically generated by Elasticsearch. This
-            information is stored in the cluster state, so keeping it short is preferable.
-            To unset `_meta`, replace the template without specifying this information.
-        :param version: Version number used to manage component templates externally.
-            This number isn't automatically generated or incremented by Elasticsearch.
-            To unset a version, replace the template without specifying a version.
-        """
-        if name in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'name'")
-        if template is None:
-            raise ValueError("Empty value passed for parameter 'template'")
-        __path = f"/_component_template/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
+        :param set_id: The id of the synonym set to be updated with the synonym rule
+        :param rule_id: The id of the synonym rule to be updated or created
+        :param synonyms:
+        """
+        if set_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'set_id'")
+        if rule_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'rule_id'")
+        if synonyms is None and body is None:
+            raise ValueError("Empty value passed for parameter 'synonyms'")
+        __path = f"/_synonyms/{_quote(set_id)}/{_quote(rule_id)}"
         __query: t.Dict[str, t.Any] = {}
-        if template is not None:
-            __body["template"] = template
-        if allow_auto_create is not None:
-            __body["allow_auto_create"] = allow_auto_create
-        if create is not None:
-            __query["create"] = create
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if synonyms is not None:
+                __body["synonyms"] = synonyms
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/indices.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/indices.py`

 * *Files 8% similar despite different names*

```diff
@@ -20,43 +20,32 @@
 from elastic_transport import HeadApiResponse, ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class IndicesClient(NamespacedClient):
+
     @_rewrite_parameters()
-    def add_block(
+    async def add_block(
         self,
         *,
         index: str,
         block: t.Union["t.Literal['metadata', 'read', 'read_only', 'write']", str],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
@@ -99,50 +88,49 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analyzer",
+            "attributes",
+            "char_filter",
+            "explain",
+            "field",
+            "filter",
+            "normalizer",
+            "text",
+            "tokenizer",
+        ),
     )
-    def analyze(
+    async def analyze(
         self,
         *,
         index: t.Optional[str] = None,
         analyzer: t.Optional[str] = None,
-        attributes: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        char_filter: t.Optional[
-            t.Union[
-                t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-            ]
-        ] = None,
+        attributes: t.Optional[t.Sequence[str]] = None,
+        char_filter: t.Optional[t.Sequence[t.Union[str, t.Mapping[str, t.Any]]]] = None,
         error_trace: t.Optional[bool] = None,
         explain: t.Optional[bool] = None,
         field: t.Optional[str] = None,
-        filter: t.Optional[
-            t.Union[
-                t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-            ]
-        ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter: t.Optional[t.Sequence[t.Union[str, t.Mapping[str, t.Any]]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         normalizer: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
-        text: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        text: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         tokenizer: t.Optional[t.Union[str, t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Performs the analysis process on a text and return the tokens breakdown of the
         text.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html>`_
 
@@ -167,74 +155,74 @@
             as a multi-value field.
         :param tokenizer: Tokenizer to use to convert text into tokens.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_analyze"
         else:
             __path = "/_analyze"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analyzer is not None:
-            __body["analyzer"] = analyzer
-        if attributes is not None:
-            __body["attributes"] = attributes
-        if char_filter is not None:
-            __body["char_filter"] = char_filter
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if explain is not None:
-            __body["explain"] = explain
-        if field is not None:
-            __body["field"] = field
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if normalizer is not None:
-            __body["normalizer"] = normalizer
         if pretty is not None:
             __query["pretty"] = pretty
-        if text is not None:
-            __body["text"] = text
-        if tokenizer is not None:
-            __body["tokenizer"] = tokenizer
+        if not __body:
+            if analyzer is not None:
+                __body["analyzer"] = analyzer
+            if attributes is not None:
+                __body["attributes"] = attributes
+            if char_filter is not None:
+                __body["char_filter"] = char_filter
+            if explain is not None:
+                __body["explain"] = explain
+            if field is not None:
+                __body["field"] = field
+            if filter is not None:
+                __body["filter"] = filter
+            if normalizer is not None:
+                __body["normalizer"] = normalizer
+            if text is not None:
+                __body["text"] = text
+            if tokenizer is not None:
+                __body["tokenizer"] = tokenizer
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("aliases", "mappings", "settings"),
     )
-    def create(
+    async def create(
         self,
         *,
         index: str,
         aliases: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         mappings: t.Optional[t.Mapping[str, t.Any]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates an index with optional settings and mappings.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html>`_
 
         :param index: Name of the index you wish to create.
@@ -250,54 +238,53 @@
         :param wait_for_active_shards: The number of shard copies that must be active
             before proceeding with the operation. Set to `all` or any positive integer
             up to the total number of shards in the index (`number_of_replicas+1`).
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aliases is not None:
-            __body["aliases"] = aliases
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if mappings is not None:
-            __body["mappings"] = mappings
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if settings is not None:
-            __body["settings"] = settings
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if not __body:
+            if aliases is not None:
+                __body["aliases"] = aliases
+            if mappings is not None:
+                __body["mappings"] = mappings
+            if settings is not None:
+                __body["settings"] = settings
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    def create_data_stream(
+    async def create_data_stream(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a data stream
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -317,45 +304,33 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def data_streams_stats(
+    async def data_streams_stats(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Provides statistics on operations happening in a data stream.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -378,46 +353,34 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def delete(
+    async def delete(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
@@ -465,28 +428,26 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def delete_alias(
+    async def delete_alias(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -520,45 +481,33 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def delete_data_lifecycle(
+    async def delete_data_lifecycle(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -589,45 +538,33 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def delete_data_stream(
+    async def delete_data_stream(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a data stream.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -648,38 +585,36 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def delete_index_template(
+    async def delete_index_template(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-template.html>`_
 
         :param name: Comma-separated list of index template names used to limit the request.
             Wildcard (*) expressions are supported.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
@@ -698,46 +633,34 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def exists(
+    async def exists(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
@@ -783,47 +706,35 @@
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def exists_alias(
+    async def exists_alias(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Union[str, t.Sequence[str]],
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a particular alias exists.
@@ -868,37 +779,35 @@
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def exists_index_template(
+    async def exists_index_template(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> HeadApiResponse:
         """
         Returns information about whether a particular index template exists.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/index-templates.html>`_
 
         :param name: Comma-separated list of index template names used to limit the request.
             Wildcard (*) expressions are supported.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         """
@@ -913,27 +822,25 @@
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "HEAD", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def explain_data_lifecycle(
+    async def explain_data_lifecycle(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -961,60 +868,42 @@
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get(
+    async def get(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         features: t.Optional[
             t.Union[
-                t.Union["t.Literal['aliases', 'mappings', 'settings']", str],
-                t.Union[
-                    t.List[
-                        t.Union["t.Literal['aliases', 'mappings', 'settings']", str]
-                    ],
-                    t.Tuple[
-                        t.Union["t.Literal['aliases', 'mappings', 'settings']", str],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['aliases', 'mappings', 'settings']", str]
                 ],
+                t.Union["t.Literal['aliases', 'mappings', 'settings']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
@@ -1074,47 +963,35 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_alias(
+    async def get_alias(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns an alias.
@@ -1160,45 +1037,33 @@
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if local is not None:
             __query["local"] = local
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_data_lifecycle(
+    async def get_data_lifecycle(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns the data stream lifecycle of the selected data streams.
 
@@ -1225,45 +1090,33 @@
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_data_stream(
+    async def get_data_stream(
         self,
         *,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns data streams.
 
@@ -1291,40 +1144,38 @@
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_index_template(
+    async def get_index_template(
         self,
         *,
         name: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-template.html>`_
 
         :param name: Comma-separated list of index template names used to limit the request.
             Wildcard (*) expressions are supported.
         :param flat_settings: If true, returns settings in flat format.
         :param include_defaults: If true, returns all relevant default configurations
             for the index template.
         :param local: If true, the request retrieves information from the local node
@@ -1352,46 +1203,34 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_mapping(
+    async def get_mapping(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
@@ -1439,47 +1278,35 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_settings(
+    async def get_settings(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        name: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        name: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
         local: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
@@ -1542,27 +1369,25 @@
         if local is not None:
             __query["local"] = local
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def migrate_to_data_stream(
+    async def migrate_to_data_stream(
         self,
         *,
         name: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Migrates an alias to a data stream
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
@@ -1578,84 +1403,87 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("actions",),
     )
-    def modify_data_stream(
+    async def modify_data_stream(
         self,
         *,
-        actions: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        actions: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Modifies a data stream
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html>`_
 
         :param actions: Actions to perform.
         """
-        if actions is None:
+        if actions is None and body is None:
             raise ValueError("Empty value passed for parameter 'actions'")
         __path = "/_data_stream/_modify"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if actions is not None:
-            __body["actions"] = actions
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if actions is not None:
+                __body["actions"] = actions
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "filter",
+            "index_routing",
+            "is_write_index",
+            "routing",
+            "search_routing",
+        ),
     )
-    def put_alias(
+    async def put_alias(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         name: str,
         error_trace: t.Optional[bool] = None,
         filter: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         index_routing: t.Optional[str] = None,
         is_write_index: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         routing: t.Optional[str] = None,
         search_routing: t.Optional[str] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates an alias.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html>`_
 
         :param index: Comma-separated list of data streams or indices to add. Supports
@@ -1686,85 +1514,75 @@
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/{_quote(index)}/_alias/{_quote(name)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if filter is not None:
-            __body["filter"] = filter
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index_routing is not None:
-            __body["index_routing"] = index_routing
-        if is_write_index is not None:
-            __body["is_write_index"] = is_write_index
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if routing is not None:
-            __body["routing"] = routing
-        if search_routing is not None:
-            __body["search_routing"] = search_routing
         if timeout is not None:
             __query["timeout"] = timeout
         if not __body:
+            if filter is not None:
+                __body["filter"] = filter
+            if index_routing is not None:
+                __body["index_routing"] = index_routing
+            if is_write_index is not None:
+                __body["is_write_index"] = is_write_index
+            if routing is not None:
+                __body["routing"] = routing
+            if search_routing is not None:
+                __body["search_routing"] = search_routing
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("data_retention", "downsampling"),
     )
-    def put_data_lifecycle(
+    async def put_data_lifecycle(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         data_retention: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         downsampling: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates the data stream lifecycle of the selected data streams.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams-put-lifecycle.html>`_
 
         :param name: Comma-separated list of data streams used to limit the request.
@@ -1784,20 +1602,16 @@
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_data_stream/{_quote(name)}/_lifecycle"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if data_retention is not None:
-            __body["data_retention"] = data_retention
-        if downsampling is not None:
-            __body["downsampling"] = downsampling
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
@@ -1805,51 +1619,61 @@
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
         if not __body:
+            if data_retention is not None:
+                __body["data_retention"] = data_retention
+            if downsampling is not None:
+                __body["downsampling"] = downsampling
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "composed_of",
+            "data_stream",
+            "index_patterns",
+            "meta",
+            "priority",
+            "template",
+            "version",
+        ),
         parameter_aliases={"_meta": "meta"},
     )
-    def put_index_template(
+    async def put_index_template(
         self,
         *,
         name: str,
-        composed_of: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        composed_of: t.Optional[t.Sequence[str]] = None,
         create: t.Optional[bool] = None,
         data_stream: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        index_patterns: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        index_patterns: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         priority: t.Optional[int] = None,
         template: t.Optional[t.Mapping[str, t.Any]] = None,
         version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-template.html>`_
 
         :param name: Index or template name
         :param composed_of: An ordered list of component template names. Component templates
             are merged in the order specified, meaning that the last component template
             specified has the highest precedence.
         :param create: If `true`, this request cannot replace or update existing index
             templates.
@@ -1868,112 +1692,109 @@
             `mappings`, or `settings` configuration.
         :param version: Version number used to manage index templates externally. This
             number is not automatically generated by Elasticsearch.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_index_template/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if composed_of is not None:
-            __body["composed_of"] = composed_of
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
-        if data_stream is not None:
-            __body["data_stream"] = data_stream
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index_patterns is not None:
-            __body["index_patterns"] = index_patterns
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if priority is not None:
-            __body["priority"] = priority
-        if template is not None:
-            __body["template"] = template
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if composed_of is not None:
+                __body["composed_of"] = composed_of
+            if data_stream is not None:
+                __body["data_stream"] = data_stream
+            if index_patterns is not None:
+                __body["index_patterns"] = index_patterns
+            if meta is not None:
+                __body["_meta"] = meta
+            if priority is not None:
+                __body["priority"] = priority
+            if template is not None:
+                __body["template"] = template
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "date_detection",
+            "dynamic",
+            "dynamic_date_formats",
+            "dynamic_templates",
+            "field_names",
+            "meta",
+            "numeric_detection",
+            "properties",
+            "routing",
+            "runtime",
+            "source",
+        ),
         parameter_aliases={
             "_field_names": "field_names",
             "_meta": "meta",
             "_routing": "routing",
             "_source": "source",
         },
     )
-    def put_mapping(
+    async def put_mapping(
         self,
         *,
-        index: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        index: t.Union[str, t.Sequence[str]],
         allow_no_indices: t.Optional[bool] = None,
         date_detection: t.Optional[bool] = None,
         dynamic: t.Optional[
             t.Union["t.Literal['false', 'runtime', 'strict', 'true']", str]
         ] = None,
-        dynamic_date_formats: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
+        dynamic_date_formats: t.Optional[t.Sequence[str]] = None,
         dynamic_templates: t.Optional[
             t.Union[
                 t.Mapping[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Mapping[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Mapping[str, t.Mapping[str, t.Any]], ...],
-                ],
+                t.Sequence[t.Mapping[str, t.Mapping[str, t.Any]]],
             ]
         ] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         field_names: t.Optional[t.Mapping[str, t.Any]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         meta: t.Optional[t.Mapping[str, t.Any]] = None,
         numeric_detection: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         properties: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         routing: t.Optional[t.Mapping[str, t.Any]] = None,
         runtime: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         source: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         write_index_only: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates the index mappings.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html>`_
 
         :param index: A comma-separated list of index names the mapping should be added
@@ -2012,93 +1833,83 @@
         :param write_index_only: If `true`, the mappings are applied only to the current
             write index for the target.
         """
         if index in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = f"/{_quote(index)}/_mapping"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if date_detection is not None:
-            __body["date_detection"] = date_detection
-        if dynamic is not None:
-            __body["dynamic"] = dynamic
-        if dynamic_date_formats is not None:
-            __body["dynamic_date_formats"] = dynamic_date_formats
-        if dynamic_templates is not None:
-            __body["dynamic_templates"] = dynamic_templates
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
-        if field_names is not None:
-            __body["_field_names"] = field_names
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
-        if numeric_detection is not None:
-            __body["numeric_detection"] = numeric_detection
         if pretty is not None:
             __query["pretty"] = pretty
-        if properties is not None:
-            __body["properties"] = properties
-        if routing is not None:
-            __body["_routing"] = routing
-        if runtime is not None:
-            __body["runtime"] = runtime
-        if source is not None:
-            __body["_source"] = source
         if timeout is not None:
             __query["timeout"] = timeout
         if write_index_only is not None:
             __query["write_index_only"] = write_index_only
+        if not __body:
+            if date_detection is not None:
+                __body["date_detection"] = date_detection
+            if dynamic is not None:
+                __body["dynamic"] = dynamic
+            if dynamic_date_formats is not None:
+                __body["dynamic_date_formats"] = dynamic_date_formats
+            if dynamic_templates is not None:
+                __body["dynamic_templates"] = dynamic_templates
+            if field_names is not None:
+                __body["_field_names"] = field_names
+            if meta is not None:
+                __body["_meta"] = meta
+            if numeric_detection is not None:
+                __body["numeric_detection"] = numeric_detection
+            if properties is not None:
+                __body["properties"] = properties
+            if routing is not None:
+                __body["_routing"] = routing
+            if runtime is not None:
+                __body["runtime"] = runtime
+            if source is not None:
+                __body["_source"] = source
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
         body_name="settings",
     )
-    def put_settings(
+    async def put_settings(
         self,
         *,
-        settings: t.Mapping[str, t.Any],
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        settings: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         preserve_existing: t.Optional[bool] = None,
@@ -2128,16 +1939,20 @@
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param preserve_existing: If `true`, existing index settings remain unchanged.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
-        if settings is None:
-            raise ValueError("Empty value passed for parameter 'settings'")
+        if settings is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'settings' and 'body', one of them should be set."
+            )
+        elif settings is not None and body is not None:
+            raise ValueError("Cannot set both 'settings' and 'body'")
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_settings"
         else:
             __path = "/_settings"
         __query: t.Dict[str, t.Any] = {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
@@ -2157,52 +1972,56 @@
             __query["master_timeout"] = master_timeout
         if preserve_existing is not None:
             __query["preserve_existing"] = preserve_existing
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
-        __body = settings
+        __body = settings if settings is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aliases",
+            "index_patterns",
+            "mappings",
+            "order",
+            "settings",
+            "version",
+        ),
     )
-    def put_template(
+    async def put_template(
         self,
         *,
         name: str,
         aliases: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         create: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         flat_settings: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
-        index_patterns: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        index_patterns: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         mappings: t.Optional[t.Mapping[str, t.Any]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         order: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates or updates an index template.
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates-v1.html>`_
 
         :param name: The name of the template
         :param aliases: Aliases for the index.
         :param create: If true, this request cannot replace or update existing index
             templates.
         :param flat_settings: If `true`, returns settings in flat format.
         :param index_patterns: Array of wildcard expressions used to match the names
@@ -2220,77 +2039,66 @@
             the timeout expires, the request fails and returns an error.
         :param version: Version number used to manage index templates externally. This
             number is not automatically generated by Elasticsearch.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_template/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aliases is not None:
-            __body["aliases"] = aliases
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if flat_settings is not None:
             __query["flat_settings"] = flat_settings
         if human is not None:
             __query["human"] = human
-        if index_patterns is not None:
-            __body["index_patterns"] = index_patterns
-        if mappings is not None:
-            __body["mappings"] = mappings
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if order is not None:
-            __body["order"] = order
         if pretty is not None:
             __query["pretty"] = pretty
-        if settings is not None:
-            __body["settings"] = settings
         if timeout is not None:
             __query["timeout"] = timeout
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if aliases is not None:
+                __body["aliases"] = aliases
+            if index_patterns is not None:
+                __body["index_patterns"] = index_patterns
+            if mappings is not None:
+                __body["mappings"] = mappings
+            if order is not None:
+                __body["order"] = order
+            if settings is not None:
+                __body["settings"] = settings
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
-    def refresh(
+    async def refresh(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Performs the refresh operation in one or more indices.
 
@@ -2325,45 +2133,33 @@
         if human is not None:
             __query["human"] = human
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def resolve_index(
+    async def resolve_index(
         self,
         *,
-        name: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        name: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Returns information about any matching indices, aliases, and data streams
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-resolve-index-api.html>`_
@@ -2387,44 +2183,43 @@
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("aliases", "conditions", "mappings", "settings"),
     )
-    def rollover(
+    async def rollover(
         self,
         *,
         alias: str,
         new_index: t.Optional[str] = None,
         aliases: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         conditions: t.Optional[t.Mapping[str, t.Any]] = None,
         dry_run: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         mappings: t.Optional[t.Mapping[str, t.Any]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         settings: t.Optional[t.Mapping[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         wait_for_active_shards: t.Optional[
             t.Union[int, t.Union["t.Literal['all', 'index-setting']", str]]
         ] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates an alias to point to a new index when the existing index is considered
         to be too large or too old.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html>`_
 
@@ -2458,329 +2253,315 @@
             raise ValueError("Empty value passed for parameter 'alias'")
         if alias not in SKIP_IN_PATH and new_index not in SKIP_IN_PATH:
             __path = f"/{_quote(alias)}/_rollover/{_quote(new_index)}"
         elif alias not in SKIP_IN_PATH:
             __path = f"/{_quote(alias)}/_rollover"
         else:
             raise ValueError("Couldn't find a path for the given parameters")
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aliases is not None:
-            __body["aliases"] = aliases
-        if conditions is not None:
-            __body["conditions"] = conditions
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if dry_run is not None:
             __query["dry_run"] = dry_run
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if mappings is not None:
-            __body["mappings"] = mappings
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if settings is not None:
-            __body["settings"] = settings
         if timeout is not None:
             __query["timeout"] = timeout
         if wait_for_active_shards is not None:
             __query["wait_for_active_shards"] = wait_for_active_shards
         if not __body:
+            if aliases is not None:
+                __body["aliases"] = aliases
+            if conditions is not None:
+                __body["conditions"] = conditions
+            if mappings is not None:
+                __body["mappings"] = mappings
+            if settings is not None:
+                __body["settings"] = settings
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters(
-        body_fields=True,
-        parameter_aliases={"_meta": "meta"},
-    )
-    def simulate_index_template(
+    @_rewrite_parameters()
+    async def simulate_index_template(
         self,
         *,
         name: str,
-        allow_auto_create: t.Optional[bool] = None,
-        composed_of: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        create: t.Optional[bool] = None,
-        data_stream: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         include_defaults: t.Optional[bool] = None,
-        index_patterns: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        priority: t.Optional[int] = None,
-        template: t.Optional[t.Mapping[str, t.Any]] = None,
-        version: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Simulate matching the given index name against the index templates in the system
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-simulate-index.html>`_
 
-        :param name: Index or template name to simulate
-        :param allow_auto_create: This setting overrides the value of the `action.auto_create_index`
-            cluster setting. If set to `true` in a template, then indices can be automatically
-            created using that template even if auto-creation of indices is disabled
-            via `actions.auto_create_index`. If set to `false`, then indices or data
-            streams matching the template must always be explicitly created, and may
-            never be automatically created.
-        :param composed_of: An ordered list of component template names. Component templates
-            are merged in the order specified, meaning that the last component template
-            specified has the highest precedence.
-        :param create: If `true`, the template passed in the body is only used if no
-            existing templates match the same index patterns. If `false`, the simulation
-            uses the template with the highest priority. Note that the template is not
-            permanently added or updated in either case; it is only used for the simulation.
-        :param data_stream: If this object is included, the template is used to create
-            data streams and their backing indices. Supports an empty object. Data streams
-            require a matching index template with a `data_stream` object.
+        :param name: Name of the index to simulate
         :param include_defaults: If true, returns all relevant default configurations
             for the index template.
-        :param index_patterns: Array of wildcard (`*`) expressions used to match the
-            names of data streams and indices during creation.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
-        :param meta: Optional user metadata about the index template. May have any contents.
-            This map is not automatically generated by Elasticsearch.
-        :param priority: Priority to determine index template precedence when a new data
-            stream or index is created. The index template with the highest priority
-            is chosen. If no priority is specified the template is treated as though
-            it is of priority 0 (lowest priority). This number is not automatically generated
-            by Elasticsearch.
-        :param template: Template to be applied. It may optionally include an `aliases`,
-            `mappings`, or `settings` configuration.
-        :param version: Version number used to manage index templates externally. This
-            number is not automatically generated by Elasticsearch.
         """
         if name in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'name'")
         __path = f"/_index_template/_simulate_index/{_quote(name)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_auto_create is not None:
-            __body["allow_auto_create"] = allow_auto_create
-        if composed_of is not None:
-            __body["composed_of"] = composed_of
-        if create is not None:
-            __query["create"] = create
-        if data_stream is not None:
-            __body["data_stream"] = data_stream
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
-        if index_patterns is not None:
-            __body["index_patterns"] = index_patterns
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
         if pretty is not None:
             __query["pretty"] = pretty
-        if priority is not None:
-            __body["priority"] = priority
-        if template is not None:
-            __body["template"] = template
-        if version is not None:
-            __body["version"] = version
-        if not __body:
-            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
-        if __body is not None:
-            __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+        return await self.perform_request(  # type: ignore[return-value]
+            "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_name="template",
+        body_fields=(
+            "allow_auto_create",
+            "composed_of",
+            "data_stream",
+            "ignore_missing_component_templates",
+            "index_patterns",
+            "meta",
+            "priority",
+            "template",
+            "version",
+        ),
+        parameter_aliases={"_meta": "meta"},
     )
-    def simulate_template(
+    async def simulate_template(
         self,
         *,
         name: t.Optional[str] = None,
+        allow_auto_create: t.Optional[bool] = None,
+        composed_of: t.Optional[t.Sequence[str]] = None,
         create: t.Optional[bool] = None,
+        data_stream: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
+        ignore_missing_component_templates: t.Optional[t.Sequence[str]] = None,
         include_defaults: t.Optional[bool] = None,
+        index_patterns: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
+        meta: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
+        priority: t.Optional[int] = None,
         template: t.Optional[t.Mapping[str, t.Any]] = None,
+        version: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Simulate resolving the given template name or body
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-simulate-template.html>`_
 
         :param name: Name of the index template to simulate. To test a template configuration
             before you add it to the cluster, omit this parameter and specify the template
             configuration in the request body.
+        :param allow_auto_create: This setting overrides the value of the `action.auto_create_index`
+            cluster setting. If set to `true` in a template, then indices can be automatically
+            created using that template even if auto-creation of indices is disabled
+            via `actions.auto_create_index`. If set to `false`, then indices or data
+            streams matching the template must always be explicitly created, and may
+            never be automatically created.
+        :param composed_of: An ordered list of component template names. Component templates
+            are merged in the order specified, meaning that the last component template
+            specified has the highest precedence.
         :param create: If true, the template passed in the body is only used if no existing
             templates match the same index patterns. If false, the simulation uses the
             template with the highest priority. Note that the template is not permanently
             added or updated in either case; it is only used for the simulation.
+        :param data_stream: If this object is included, the template is used to create
+            data streams and their backing indices. Supports an empty object. Data streams
+            require a matching index template with a `data_stream` object.
+        :param ignore_missing_component_templates: The configuration option ignore_missing_component_templates
+            can be used when an index template references a component template that might
+            not exist
         :param include_defaults: If true, returns all relevant default configurations
             for the index template.
+        :param index_patterns: Array of wildcard (`*`) expressions used to match the
+            names of data streams and indices during creation.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
-        :param template:
+        :param meta: Optional user metadata about the index template. May have any contents.
+            This map is not automatically generated by Elasticsearch.
+        :param priority: Priority to determine index template precedence when a new data
+            stream or index is created. The index template with the highest priority
+            is chosen. If no priority is specified the template is treated as though
+            it is of priority 0 (lowest priority). This number is not automatically generated
+            by Elasticsearch.
+        :param template: Template to be applied. It may optionally include an `aliases`,
+            `mappings`, or `settings` configuration.
+        :param version: Version number used to manage index templates externally. This
+            number is not automatically generated by Elasticsearch.
         """
         if name not in SKIP_IN_PATH:
             __path = f"/_index_template/_simulate/{_quote(name)}"
         else:
             __path = "/_index_template/_simulate"
         __query: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if create is not None:
             __query["create"] = create
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if include_defaults is not None:
             __query["include_defaults"] = include_defaults
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        __body = template
         if not __body:
-            __body = None
+            if allow_auto_create is not None:
+                __body["allow_auto_create"] = allow_auto_create
+            if composed_of is not None:
+                __body["composed_of"] = composed_of
+            if data_stream is not None:
+                __body["data_stream"] = data_stream
+            if ignore_missing_component_templates is not None:
+                __body["ignore_missing_component_templates"] = (
+                    ignore_missing_component_templates
+                )
+            if index_patterns is not None:
+                __body["index_patterns"] = index_patterns
+            if meta is not None:
+                __body["_meta"] = meta
+            if priority is not None:
+                __body["priority"] = priority
+            if template is not None:
+                __body["template"] = template
+            if version is not None:
+                __body["version"] = version
+        if not __body:
+            __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("actions",),
     )
-    def update_aliases(
+    async def update_aliases(
         self,
         *,
-        actions: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        actions: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         master_timeout: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates index aliases.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html>`_
 
         :param actions: Actions to perform.
         :param master_timeout: Period to wait for a connection to the master node. If
             no response is received before the timeout expires, the request fails and
             returns an error.
         :param timeout: Period to wait for a response. If no response is received before
             the timeout expires, the request fails and returns an error.
         """
         __path = "/_aliases"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if actions is not None:
-            __body["actions"] = actions
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if master_timeout is not None:
             __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if actions is not None:
+                __body["actions"] = actions
         __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("query",),
     )
-    def validate_query(
+    async def validate_query(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
+        index: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         all_shards: t.Optional[bool] = None,
         allow_no_indices: t.Optional[bool] = None,
         analyze_wildcard: t.Optional[bool] = None,
         analyzer: t.Optional[str] = None,
         default_operator: t.Optional[t.Union["t.Literal['and', 'or']", str]] = None,
         df: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
         explain: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
         lenient: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         q: t.Optional[str] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         rewrite: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Allows a user to validate a potentially expensive query without executing it.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html>`_
 
         :param index: Comma-separated list of data streams, indices, and aliases to search.
@@ -2815,15 +2596,15 @@
             Lucene query that will be executed.
         """
         if index not in SKIP_IN_PATH:
             __path = f"/{_quote(index)}/_validate/query"
         else:
             __path = "/_validate/query"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if all_shards is not None:
             __query["all_shards"] = all_shards
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
         if analyze_wildcard is not None:
             __query["analyze_wildcard"] = analyze_wildcard
         if analyzer is not None:
@@ -2846,19 +2627,20 @@
             __query["ignore_unavailable"] = ignore_unavailable
         if lenient is not None:
             __query["lenient"] = lenient
         if pretty is not None:
             __query["pretty"] = pretty
         if q is not None:
             __query["q"] = q
-        if query is not None:
-            __body["query"] = query
         if rewrite is not None:
             __query["rewrite"] = rewrite
         if not __body:
+            if query is not None:
+                __body["query"] = query
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
-        return self.perform_request(  # type: ignore[return-value]
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ingest.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/inference.py`

 * *Files 26% similar despite different names*

```diff
@@ -19,132 +19,94 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class IngestClient(NamespacedClient):
+class InferenceClient(NamespacedClient):
+
     @_rewrite_parameters()
-    def delete_pipeline(
+    def delete_model(
         self,
         *,
-        id: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        inference_id: str,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Deletes a pipeline.
+        Delete model in the Inference API
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-pipeline-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-inference-api.html>`_
 
-        :param id: Pipeline ID or wildcard expression of pipeline IDs used to limit the
-            request. To delete all ingest pipelines in a cluster, use a value of `*`.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
+        :param inference_id: The inference Id
+        :param task_type: The task type
         """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_ingest/pipeline/{_quote(id)}"
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
+        else:
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def get_pipeline(
+    def get_model(
         self,
         *,
-        id: t.Optional[str] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        inference_id: str,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        summary: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Returns a pipeline.
+        Get a model in the Inference API
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-pipeline-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-inference-api.html>`_
 
-        :param id: Comma-separated list of pipeline IDs to retrieve. Wildcard (`*`) expressions
-            are supported. To get all ingest pipelines, omit this parameter or use `*`.
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param summary: Return pipelines without their definitions (default: false)
+        :param inference_id: The inference Id
+        :param task_type: The task type
         """
-        if id not in SKIP_IN_PATH:
-            __path = f"/_ingest/pipeline/{_quote(id)}"
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
         else:
-            __path = "/_ingest/pipeline"
-        __query: t.Dict[str, t.Any] = {}
-        if error_trace is not None:
-            __query["error_trace"] = error_trace
-        if filter_path is not None:
-            __query["filter_path"] = filter_path
-        if human is not None:
-            __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if summary is not None:
-            __query["summary"] = summary
-        __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
-        )
-
-    @_rewrite_parameters()
-    def processor_grok(
-        self,
-        *,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        human: t.Optional[bool] = None,
-        pretty: t.Optional[bool] = None,
-    ) -> ObjectApiResponse[t.Any]:
-        """
-        Returns a list of the built-in patterns.
-
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/grok-processor.html>`_
-        """
-        __path = "/_ingest/processor/grok"
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
@@ -152,154 +114,132 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
-        parameter_aliases={"_meta": "meta"},
+        body_fields=("input", "query", "task_settings"),
     )
-    def put_pipeline(
+    def inference(
         self,
         *,
-        id: str,
-        description: t.Optional[str] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        inference_id: str,
+        input: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        if_version: t.Optional[int] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
-        meta: t.Optional[t.Mapping[str, t.Any]] = None,
-        on_failure: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        processors: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
-        timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        version: t.Optional[int] = None,
+        query: t.Optional[str] = None,
+        task_settings: t.Optional[t.Any] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Creates or updates a pipeline.
+        Perform inference on a model
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ingest.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/post-inference-api.html>`_
 
-        :param id: ID of the ingest pipeline to create or update.
-        :param description: Description of the ingest pipeline.
-        :param if_version: Required version for optimistic concurrency control for pipeline
-            updates
-        :param master_timeout: Period to wait for a connection to the master node. If
-            no response is received before the timeout expires, the request fails and
-            returns an error.
-        :param meta: Optional metadata about the ingest pipeline. May have any contents.
-            This map is not automatically generated by Elasticsearch.
-        :param on_failure: Processors to run immediately after a processor failure. Each
-            processor supports a processor-level `on_failure` value. If a processor without
-            an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter
-            as a fallback. The processors in this parameter run sequentially in the order
-            specified. Elasticsearch will not attempt to run the pipeline's remaining
-            processors.
-        :param processors: Processors used to perform transformations on documents before
-            indexing. Processors run sequentially in the order specified.
-        :param timeout: Period to wait for a response. If no response is received before
-            the timeout expires, the request fails and returns an error.
-        :param version: Version number used by external systems to track ingest pipelines.
-            This parameter is intended for external systems only. Elasticsearch does
-            not use or validate pipeline version numbers.
-        """
-        if id in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'id'")
-        __path = f"/_ingest/pipeline/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
+        :param inference_id: The inference Id
+        :param input: Text input to the model. Either a string or an array of strings.
+        :param task_type: The task type
+        :param query: Query input, required for rerank task. Not required for other tasks.
+        :param task_settings: Optional task settings
+        """
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if input is None and body is None:
+            raise ValueError("Empty value passed for parameter 'input'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
+        else:
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if if_version is not None:
-            __query["if_version"] = if_version
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
-        if meta is not None:
-            __body["_meta"] = meta
-        if on_failure is not None:
-            __body["on_failure"] = on_failure
         if pretty is not None:
             __query["pretty"] = pretty
-        if processors is not None:
-            __body["processors"] = processors
-        if timeout is not None:
-            __query["timeout"] = timeout
-        if version is not None:
-            __body["version"] = version
-        __headers = {"accept": "application/json", "content-type": "application/json"}
+        if not __body:
+            if input is not None:
+                __body["input"] = input
+            if query is not None:
+                __body["query"] = query
+            if task_settings is not None:
+                __body["task_settings"] = task_settings
+        if not __body:
+            __body = None  # type: ignore[assignment]
+        __headers = {"accept": "application/json"}
+        if __body is not None:
+            __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
-            "PUT", __path, params=__query, headers=__headers, body=__body
+            "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_name="model_config",
     )
-    def simulate(
+    def put_model(
         self,
         *,
-        id: t.Optional[str] = None,
-        docs: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
+        inference_id: str,
+        model_config: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        pipeline: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        verbose: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Allows to simulate a pipeline with example documents.
+        Configure a model for use in the Inference API
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-inference-api.html>`_
 
-        :param id: Pipeline to test. If you don’t specify a `pipeline` in the request
-            body, this parameter is required.
-        :param docs: Sample documents to test in the pipeline.
-        :param pipeline: Pipeline to test. If you don’t specify the `pipeline` request
-            path parameter, this parameter is required. If you specify both this and
-            the request path parameter, the API only uses the request path parameter.
-        :param verbose: If `true`, the response includes output data for each processor
-            in the executed pipeline.
-        """
-        if id not in SKIP_IN_PATH:
-            __path = f"/_ingest/pipeline/{_quote(id)}/_simulate"
+        :param inference_id: The inference Id
+        :param model_config:
+        :param task_type: The task type
+        """
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if model_config is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'model_config' and 'body', one of them should be set."
+            )
+        elif model_config is not None and body is not None:
+            raise ValueError("Cannot set both 'model_config' and 'body'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
         else:
-            __path = "/_ingest/pipeline/_simulate"
-        __body: t.Dict[str, t.Any] = {}
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if pipeline is not None:
-            __body["pipeline"] = pipeline
         if pretty is not None:
             __query["pretty"] = pretty
-        if verbose is not None:
-            __query["verbose"] = verbose
+        __body = model_config if model_config is not None else body
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers, body=__body
+            "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/ml.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/ml.py`

 * *Files 4% similar despite different names*

```diff
@@ -20,30 +20,30 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class MlClient(NamespacedClient):
+
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("allow_no_match", "force", "timeout"),
     )
     def close_job(
         self,
         *,
         job_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Closes one or more anomaly detection jobs. A job can be opened and closed multiple
         times throughout its lifecycle.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-close-job.html>`_
 
@@ -56,30 +56,31 @@
             parameter.
         :param force: Refer to the descriptiion for the `force` query parameter.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_close"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_match is not None:
-            __body["allow_no_match"] = allow_no_match
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if force is not None:
-            __body["force"] = force
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if allow_no_match is not None:
+                __body["allow_no_match"] = allow_no_match
+            if force is not None:
+                __body["force"] = force
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -87,17 +88,15 @@
 
     @_rewrite_parameters()
     def delete_calendar(
         self,
         *,
         calendar_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-calendar.html>`_
@@ -124,17 +123,15 @@
     @_rewrite_parameters()
     def delete_calendar_event(
         self,
         *,
         calendar_id: str,
         event_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes scheduled events from a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-calendar-event.html>`_
@@ -163,19 +160,17 @@
         )
 
     @_rewrite_parameters()
     def delete_calendar_job(
         self,
         *,
         calendar_id: str,
-        job_id: t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]],
+        job_id: t.Union[str, t.Sequence[str]],
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes anomaly detection jobs from a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-calendar-job.html>`_
@@ -205,17 +200,15 @@
 
     @_rewrite_parameters()
     def delete_data_frame_analytics(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing data frame analytics job.
@@ -250,17 +243,15 @@
 
     @_rewrite_parameters()
     def delete_datafeed(
         self,
         *,
         datafeed_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing datafeed.
 
@@ -294,17 +285,15 @@
 
     @_rewrite_parameters()
     def delete_filter(
         self,
         *,
         filter_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a filter.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-delete-filter.html>`_
@@ -331,17 +320,15 @@
     @_rewrite_parameters()
     def delete_job(
         self,
         *,
         job_id: str,
         delete_user_annotations: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing anomaly detection job.
@@ -382,17 +369,15 @@
 
     @_rewrite_parameters()
     def delete_trained_model(
         self,
         *,
         model_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes an existing trained inference model that is currently not referenced
         by an ingest pipeline.
@@ -425,17 +410,15 @@
     @_rewrite_parameters()
     def delete_trained_model_alias(
         self,
         *,
         model_id: str,
         model_alias: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Deletes a model alias that refers to the trained model
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-trained-models-aliases.html>`_
@@ -459,28 +442,31 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analysis_config",
+            "max_bucket_cardinality",
+            "overall_cardinality",
+        ),
     )
     def estimate_model_memory(
         self,
         *,
         analysis_config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_bucket_cardinality: t.Optional[t.Mapping[str, int]] = None,
         overall_cardinality: t.Optional[t.Mapping[str, int]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Estimates the model memory
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-apis.html>`_
 
         :param analysis_config: For a list of the properties that you can specify in
@@ -495,105 +481,105 @@
             a good answer, values must be provided for fields referenced in the `by_field_name`,
             `over_field_name` and `partition_field_name` of any detectors. Providing
             values for other fields has no effect on the estimation. It can be omitted
             from the request if no detectors have a `by_field_name`, `over_field_name`
             or `partition_field_name`.
         """
         __path = "/_ml/anomaly_detectors/_estimate_model_memory"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analysis_config is not None:
-            __body["analysis_config"] = analysis_config
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if max_bucket_cardinality is not None:
-            __body["max_bucket_cardinality"] = max_bucket_cardinality
-        if overall_cardinality is not None:
-            __body["overall_cardinality"] = overall_cardinality
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if analysis_config is not None:
+                __body["analysis_config"] = analysis_config
+            if max_bucket_cardinality is not None:
+                __body["max_bucket_cardinality"] = max_bucket_cardinality
+            if overall_cardinality is not None:
+                __body["overall_cardinality"] = overall_cardinality
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("evaluation", "index", "query"),
     )
     def evaluate_data_frame(
         self,
         *,
-        evaluation: t.Mapping[str, t.Any],
-        index: str,
+        evaluation: t.Optional[t.Mapping[str, t.Any]] = None,
+        index: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Evaluates the data frame analytics for an annotated index.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/evaluate-dfanalytics.html>`_
 
         :param evaluation: Defines the type of evaluation you want to perform.
         :param index: Defines the `index` in which the evaluation will be performed.
         :param query: A query clause that retrieves a subset of data from the source
             index.
         """
-        if evaluation is None:
+        if evaluation is None and body is None:
             raise ValueError("Empty value passed for parameter 'evaluation'")
-        if index is None:
+        if index is None and body is None:
             raise ValueError("Empty value passed for parameter 'index'")
         __path = "/_ml/data_frame/_evaluate"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if evaluation is not None:
-            __body["evaluation"] = evaluation
-        if index is not None:
-            __body["index"] = index
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
+        if not __body:
+            if evaluation is not None:
+                __body["evaluation"] = evaluation
+            if index is not None:
+                __body["index"] = index
+            if query is not None:
+                __body["query"] = query
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("advance_time", "calc_interim", "end", "skip_time", "start"),
     )
     def flush_job(
         self,
         *,
         job_id: str,
         advance_time: t.Optional[t.Union[str, t.Any]] = None,
         calc_interim: t.Optional[bool] = None,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         skip_time: t.Optional[t.Union[str, t.Any]] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Forces any buffered data to be processed by the job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-flush-job.html>`_
 
         :param job_id: Identifier for the anomaly detection job.
@@ -602,34 +588,35 @@
         :param end: Refer to the description for the `end` query parameter.
         :param skip_time: Refer to the description for the `skip_time` query parameter.
         :param start: Refer to the description for the `start` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_flush"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if advance_time is not None:
-            __body["advance_time"] = advance_time
-        if calc_interim is not None:
-            __body["calc_interim"] = calc_interim
-        if end is not None:
-            __body["end"] = end
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if skip_time is not None:
-            __body["skip_time"] = skip_time
-        if start is not None:
-            __body["start"] = start
+        if not __body:
+            if advance_time is not None:
+                __body["advance_time"] = advance_time
+            if calc_interim is not None:
+                __body["calc_interim"] = calc_interim
+            if end is not None:
+                __body["end"] = end
+            if skip_time is not None:
+                __body["skip_time"] = skip_time
+            if start is not None:
+                __body["start"] = start
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -640,17 +627,15 @@
     )
     def get_calendar_events(
         self,
         *,
         calendar_id: str,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         job_id: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
@@ -694,30 +679,29 @@
             __query["start"] = start
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("page",),
         parameter_aliases={"from": "from_"},
     )
     def get_calendars(
         self,
         *,
         calendar_id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         page: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for calendars.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-calendar.html>`_
 
         :param calendar_id: A string that uniquely identifies a calendar. You can get
@@ -731,30 +715,31 @@
             is supported only when you omit the calendar identifier.
         """
         if calendar_id not in SKIP_IN_PATH:
             __path = f"/_ml/calendars/{_quote(calendar_id)}"
         else:
             __path = "/_ml/calendars"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if from_ is not None:
             __query["from"] = from_
         if human is not None:
             __query["human"] = human
-        if page is not None:
-            __body["page"] = page
         if pretty is not None:
             __query["pretty"] = pretty
         if size is not None:
             __query["size"] = size
         if not __body:
+            if page is not None:
+                __body["page"] = page
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
@@ -765,17 +750,15 @@
     def get_data_frame_analytics(
         self,
         *,
         id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for data frame analytics jobs.
@@ -830,17 +813,15 @@
     )
     def get_data_frame_analytics_stats(
         self,
         *,
         id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
         verbose: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
@@ -889,22 +870,18 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     def get_datafeed_stats(
         self,
         *,
-        datafeed_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        datafeed_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves usage information for datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-datafeed-stats.html>`_
@@ -940,23 +917,19 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     def get_datafeeds(
         self,
         *,
-        datafeed_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        datafeed_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-datafeed.html>`_
@@ -999,21 +972,17 @@
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     def get_filters(
         self,
         *,
-        filter_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves filters.
@@ -1049,17 +1018,15 @@
     @_rewrite_parameters()
     def get_job_stats(
         self,
         *,
         job_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves usage information for anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-job-stats.html>`_
@@ -1096,23 +1063,19 @@
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
     def get_jobs(
         self,
         *,
-        job_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        job_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves configuration information for anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-job.html>`_
@@ -1150,33 +1113,40 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "allow_no_match",
+            "bucket_span",
+            "end",
+            "exclude_interim",
+            "overall_score",
+            "start",
+            "top_n",
+        ),
     )
     def get_overall_buckets(
         self,
         *,
         job_id: str,
         allow_no_match: t.Optional[bool] = None,
         bucket_span: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         exclude_interim: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         overall_score: t.Optional[t.Union[float, str]] = None,
         pretty: t.Optional[bool] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
         top_n: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves overall bucket results that summarize the bucket results of multiple
         anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-get-overall-buckets.html>`_
 
@@ -1194,38 +1164,39 @@
             parameter.
         :param start: Refer to the description for the `start` query parameter.
         :param top_n: Refer to the description for the `top_n` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/results/overall_buckets"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_match is not None:
-            __body["allow_no_match"] = allow_no_match
-        if bucket_span is not None:
-            __body["bucket_span"] = bucket_span
-        if end is not None:
-            __body["end"] = end
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if exclude_interim is not None:
-            __body["exclude_interim"] = exclude_interim
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if overall_score is not None:
-            __body["overall_score"] = overall_score
         if pretty is not None:
             __query["pretty"] = pretty
-        if start is not None:
-            __body["start"] = start
-        if top_n is not None:
-            __body["top_n"] = top_n
+        if not __body:
+            if allow_no_match is not None:
+                __body["allow_no_match"] = allow_no_match
+            if bucket_span is not None:
+                __body["bucket_span"] = bucket_span
+            if end is not None:
+                __body["end"] = end
+            if exclude_interim is not None:
+                __body["exclude_interim"] = exclude_interim
+            if overall_score is not None:
+                __body["overall_score"] = overall_score
+            if start is not None:
+                __body["start"] = start
+            if top_n is not None:
+                __body["top_n"] = top_n
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -1238,17 +1209,15 @@
         self,
         *,
         model_id: t.Optional[str] = None,
         allow_no_match: t.Optional[bool] = None,
         decompress_definition: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
         exclude_generated: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         include: t.Optional[
             t.Union[
                 "t.Literal['definition', 'definition_status', 'feature_importance_baseline', 'hyperparameters', 'total_feature_importance']",
                 str,
             ]
@@ -1316,22 +1285,18 @@
 
     @_rewrite_parameters(
         parameter_aliases={"from": "from_"},
     )
     def get_trained_models_stats(
         self,
         *,
-        model_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        model_id: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         size: t.Optional[int] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves usage information for trained inference models.
@@ -1369,31 +1334,28 @@
             __query["size"] = size
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("docs", "inference_config"),
     )
     def infer_trained_model(
         self,
         *,
         model_id: str,
-        docs: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        docs: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         inference_config: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Evaluate a trained model.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/infer-trained-model.html>`_
 
         :param model_id: The unique identifier of the trained model.
@@ -1403,148 +1365,146 @@
             only a single value is allowed.
         :param inference_config: The inference configuration updates to apply on the
             API call
         :param timeout: Controls the amount of time to wait for inference results.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
-        if docs is None:
+        if docs is None and body is None:
             raise ValueError("Empty value passed for parameter 'docs'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/_infer"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if docs is not None:
-            __body["docs"] = docs
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if inference_config is not None:
-            __body["inference_config"] = inference_config
         if pretty is not None:
             __query["pretty"] = pretty
         if timeout is not None:
             __query["timeout"] = timeout
+        if not __body:
+            if docs is not None:
+                __body["docs"] = docs
+            if inference_config is not None:
+                __body["inference_config"] = inference_config
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("timeout",),
     )
     def open_job(
         self,
         *,
         job_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Opens one or more anomaly detection jobs.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-open-job.html>`_
 
         :param job_id: Identifier for the anomaly detection job.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_open"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("events",),
     )
     def post_calendar_events(
         self,
         *,
         calendar_id: str,
-        events: t.Union[
-            t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]
-        ],
+        events: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Posts scheduled events in a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-post-calendar-event.html>`_
 
         :param calendar_id: A string that uniquely identifies a calendar.
         :param events: A list of one of more scheduled events. The event’s start and
             end times can be specified as integer milliseconds since the epoch or as
             a string in ISO 8601 format.
         """
         if calendar_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'calendar_id'")
-        if events is None:
+        if events is None and body is None:
             raise ValueError("Empty value passed for parameter 'events'")
         __path = f"/_ml/calendars/{_quote(calendar_id)}/events"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if events is not None:
-            __body["events"] = events
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if events is not None:
+                __body["events"] = events
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("config",),
     )
     def preview_data_frame_analytics(
         self,
         *,
         id: t.Optional[str] = None,
         config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Previews that will be analyzed given a data frame analytics config.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/preview-dfanalytics.html>`_
 
         :param id: Identifier for the data frame analytics job.
@@ -1552,52 +1512,52 @@
             analytics jobs. Note that `id` and `dest` don’t need to be provided in the
             context of this API.
         """
         if id not in SKIP_IN_PATH:
             __path = f"/_ml/data_frame/analytics/{_quote(id)}/_preview"
         else:
             __path = "/_ml/data_frame/analytics/_preview"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if config is not None:
-            __body["config"] = config
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if config is not None:
+                __body["config"] = config
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("datafeed_config", "job_config"),
     )
     def preview_datafeed(
         self,
         *,
         datafeed_id: t.Optional[str] = None,
         datafeed_config: t.Optional[t.Mapping[str, t.Any]] = None,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         job_config: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Previews a datafeed.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-preview-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -1615,84 +1575,85 @@
             object unless you also supply a `datafeed_config` object.
         :param start: The start time from where the datafeed preview should begin
         """
         if datafeed_id not in SKIP_IN_PATH:
             __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_preview"
         else:
             __path = "/_ml/datafeeds/_preview"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if datafeed_config is not None:
-            __body["datafeed_config"] = datafeed_config
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if end is not None:
             __query["end"] = end
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if job_config is not None:
-            __body["job_config"] = job_config
         if pretty is not None:
             __query["pretty"] = pretty
         if start is not None:
             __query["start"] = start
         if not __body:
+            if datafeed_config is not None:
+                __body["datafeed_config"] = datafeed_config
+            if job_config is not None:
+                __body["job_config"] = job_config
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("description", "job_ids"),
     )
     def put_calendar(
         self,
         *,
         calendar_id: str,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        job_ids: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        job_ids: t.Optional[t.Sequence[str]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-calendar.html>`_
 
         :param calendar_id: A string that uniquely identifies a calendar.
         :param description: A description of the calendar.
         :param job_ids: An array of anomaly detection job identifiers.
         """
         if calendar_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'calendar_id'")
         __path = f"/_ml/calendars/{_quote(calendar_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if job_ids is not None:
-            __body["job_ids"] = job_ids
         if pretty is not None:
             __query["pretty"] = pretty
         if not __body:
+            if description is not None:
+                __body["description"] = description
+            if job_ids is not None:
+                __body["job_ids"] = job_ids
+        if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
@@ -1700,17 +1661,15 @@
     @_rewrite_parameters()
     def put_calendar_job(
         self,
         *,
         calendar_id: str,
         job_id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Adds an anomaly detection job to a calendar.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-calendar-job.html>`_
@@ -1735,39 +1694,47 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analysis",
+            "dest",
+            "source",
+            "allow_lazy_start",
+            "analyzed_fields",
+            "description",
+            "headers",
+            "max_num_threads",
+            "model_memory_limit",
+            "version",
+        ),
         ignore_deprecated_options={"headers"},
     )
     def put_data_frame_analytics(
         self,
         *,
         id: str,
-        analysis: t.Mapping[str, t.Any],
-        dest: t.Mapping[str, t.Any],
-        source: t.Mapping[str, t.Any],
+        analysis: t.Optional[t.Mapping[str, t.Any]] = None,
+        dest: t.Optional[t.Mapping[str, t.Any]] = None,
+        source: t.Optional[t.Mapping[str, t.Any]] = None,
         allow_lazy_start: t.Optional[bool] = None,
         analyzed_fields: t.Optional[t.Mapping[str, t.Any]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        headers: t.Optional[
-            t.Mapping[str, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        headers: t.Optional[t.Mapping[str, t.Union[str, t.Sequence[str]]]] = None,
         human: t.Optional[bool] = None,
         max_num_threads: t.Optional[int] = None,
         model_memory_limit: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         version: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a data frame analytics job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-dfanalytics.html>`_
 
         :param id: Identifier for the data frame analytics job. This identifier can contain
@@ -1823,112 +1790,112 @@
             file contains an `xpack.ml.max_model_memory_limit` setting, an error occurs
             when you try to create data frame analytics jobs that have `model_memory_limit`
             values greater than that setting.
         :param version:
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
-        if analysis is None:
+        if analysis is None and body is None:
             raise ValueError("Empty value passed for parameter 'analysis'")
-        if dest is None:
+        if dest is None and body is None:
             raise ValueError("Empty value passed for parameter 'dest'")
-        if source is None:
+        if source is None and body is None:
             raise ValueError("Empty value passed for parameter 'source'")
         __path = f"/_ml/data_frame/analytics/{_quote(id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analysis is not None:
-            __body["analysis"] = analysis
-        if dest is not None:
-            __body["dest"] = dest
-        if source is not None:
-            __body["source"] = source
-        if allow_lazy_start is not None:
-            __body["allow_lazy_start"] = allow_lazy_start
-        if analyzed_fields is not None:
-            __body["analyzed_fields"] = analyzed_fields
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if headers is not None:
-            __body["headers"] = headers
         if human is not None:
             __query["human"] = human
-        if max_num_threads is not None:
-            __body["max_num_threads"] = max_num_threads
-        if model_memory_limit is not None:
-            __body["model_memory_limit"] = model_memory_limit
         if pretty is not None:
             __query["pretty"] = pretty
-        if version is not None:
-            __body["version"] = version
+        if not __body:
+            if analysis is not None:
+                __body["analysis"] = analysis
+            if dest is not None:
+                __body["dest"] = dest
+            if source is not None:
+                __body["source"] = source
+            if allow_lazy_start is not None:
+                __body["allow_lazy_start"] = allow_lazy_start
+            if analyzed_fields is not None:
+                __body["analyzed_fields"] = analyzed_fields
+            if description is not None:
+                __body["description"] = description
+            if headers is not None:
+                __body["headers"] = headers
+            if max_num_threads is not None:
+                __body["max_num_threads"] = max_num_threads
+            if model_memory_limit is not None:
+                __body["model_memory_limit"] = model_memory_limit
+            if version is not None:
+                __body["version"] = version
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "chunking_config",
+            "delayed_data_check_config",
+            "frequency",
+            "headers",
+            "indexes",
+            "indices",
+            "indices_options",
+            "job_id",
+            "max_empty_searches",
+            "query",
+            "query_delay",
+            "runtime_mappings",
+            "script_fields",
+            "scroll_size",
+        ),
         ignore_deprecated_options={"headers"},
     )
     def put_datafeed(
         self,
         *,
         datafeed_id: str,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         chunking_config: t.Optional[t.Mapping[str, t.Any]] = None,
         delayed_data_check_config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        headers: t.Optional[
-            t.Mapping[str, t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]]
-        ] = None,
+        headers: t.Optional[t.Mapping[str, t.Union[str, t.Sequence[str]]]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indexes: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        indices: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        indexes: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        indices: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         indices_options: t.Optional[t.Mapping[str, t.Any]] = None,
         job_id: t.Optional[str] = None,
         max_empty_searches: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         query_delay: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll_size: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a datafeed.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -1999,145 +1966,161 @@
         :param scroll_size: The size parameter that is used in Elasticsearch searches
             when the datafeed does not use aggregations. The maximum value is the value
             of `index.max_result_window`, which is 10,000 by default.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if chunking_config is not None:
-            __body["chunking_config"] = chunking_config
-        if delayed_data_check_config is not None:
-            __body["delayed_data_check_config"] = delayed_data_check_config
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
-        if headers is not None:
-            __body["headers"] = headers
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indexes is not None:
-            __body["indexes"] = indexes
-        if indices is not None:
-            __body["indices"] = indices
-        if indices_options is not None:
-            __body["indices_options"] = indices_options
-        if job_id is not None:
-            __body["job_id"] = job_id
-        if max_empty_searches is not None:
-            __body["max_empty_searches"] = max_empty_searches
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if query_delay is not None:
-            __body["query_delay"] = query_delay
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
-        if scroll_size is not None:
-            __body["scroll_size"] = scroll_size
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if chunking_config is not None:
+                __body["chunking_config"] = chunking_config
+            if delayed_data_check_config is not None:
+                __body["delayed_data_check_config"] = delayed_data_check_config
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if headers is not None:
+                __body["headers"] = headers
+            if indexes is not None:
+                __body["indexes"] = indexes
+            if indices is not None:
+                __body["indices"] = indices
+            if indices_options is not None:
+                __body["indices_options"] = indices_options
+            if job_id is not None:
+                __body["job_id"] = job_id
+            if max_empty_searches is not None:
+                __body["max_empty_searches"] = max_empty_searches
+            if query is not None:
+                __body["query"] = query
+            if query_delay is not None:
+                __body["query_delay"] = query_delay
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if scroll_size is not None:
+                __body["scroll_size"] = scroll_size
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("description", "items"),
     )
     def put_filter(
         self,
         *,
         filter_id: str,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        items: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        items: t.Optional[t.Sequence[str]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates a filter.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-filter.html>`_
 
         :param filter_id: A string that uniquely identifies a filter.
         :param description: A description of the filter.
         :param items: The items of the filter. A wildcard `*` can be used at the beginning
             or the end of an item. Up to 10000 items are allowed in each filter.
         """
         if filter_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'filter_id'")
         __path = f"/_ml/filters/{_quote(filter_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if items is not None:
-            __body["items"] = items
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if description is not None:
+                __body["description"] = description
+            if items is not None:
+                __body["items"] = items
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "analysis_config",
+            "data_description",
+            "allow_lazy_open",
+            "analysis_limits",
+            "background_persist_interval",
+            "custom_settings",
+            "daily_model_snapshot_retention_after_days",
+            "datafeed_config",
+            "description",
+            "groups",
+            "model_plot_config",
+            "model_snapshot_retention_days",
+            "renormalization_window_days",
+            "results_index_name",
+            "results_retention_days",
+        ),
     )
     def put_job(
         self,
         *,
         job_id: str,
-        analysis_config: t.Mapping[str, t.Any],
-        data_description: t.Mapping[str, t.Any],
+        analysis_config: t.Optional[t.Mapping[str, t.Any]] = None,
+        data_description: t.Optional[t.Mapping[str, t.Any]] = None,
         allow_lazy_open: t.Optional[bool] = None,
         analysis_limits: t.Optional[t.Mapping[str, t.Any]] = None,
         background_persist_interval: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         custom_settings: t.Optional[t.Any] = None,
         daily_model_snapshot_retention_after_days: t.Optional[int] = None,
         datafeed_config: t.Optional[t.Mapping[str, t.Any]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        groups: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        groups: t.Optional[t.Sequence[str]] = None,
         human: t.Optional[bool] = None,
         model_plot_config: t.Optional[t.Mapping[str, t.Any]] = None,
         model_snapshot_retention_days: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         renormalization_window_days: t.Optional[int] = None,
         results_index_name: t.Optional[str] = None,
         results_retention_days: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Instantiates an anomaly detection job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-put-job.html>`_
 
         :param job_id: The identifier for the anomaly detection job. This identifier
@@ -2211,91 +2194,106 @@
             The default value is null, which means all results are retained. Annotations
             generated by the system also count as results for retention purposes; they
             are deleted after the same number of days as results. Annotations added by
             users are retained forever.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
-        if analysis_config is None:
+        if analysis_config is None and body is None:
             raise ValueError("Empty value passed for parameter 'analysis_config'")
-        if data_description is None:
+        if data_description is None and body is None:
             raise ValueError("Empty value passed for parameter 'data_description'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if analysis_config is not None:
-            __body["analysis_config"] = analysis_config
-        if data_description is not None:
-            __body["data_description"] = data_description
-        if allow_lazy_open is not None:
-            __body["allow_lazy_open"] = allow_lazy_open
-        if analysis_limits is not None:
-            __body["analysis_limits"] = analysis_limits
-        if background_persist_interval is not None:
-            __body["background_persist_interval"] = background_persist_interval
-        if custom_settings is not None:
-            __body["custom_settings"] = custom_settings
-        if daily_model_snapshot_retention_after_days is not None:
-            __body[
-                "daily_model_snapshot_retention_after_days"
-            ] = daily_model_snapshot_retention_after_days
-        if datafeed_config is not None:
-            __body["datafeed_config"] = datafeed_config
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if groups is not None:
-            __body["groups"] = groups
-        if human is not None:
-            __query["human"] = human
-        if model_plot_config is not None:
-            __body["model_plot_config"] = model_plot_config
-        if model_snapshot_retention_days is not None:
-            __body["model_snapshot_retention_days"] = model_snapshot_retention_days
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if renormalization_window_days is not None:
-            __body["renormalization_window_days"] = renormalization_window_days
-        if results_index_name is not None:
-            __body["results_index_name"] = results_index_name
-        if results_retention_days is not None:
-            __body["results_retention_days"] = results_retention_days
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        if not __body:
+            if analysis_config is not None:
+                __body["analysis_config"] = analysis_config
+            if data_description is not None:
+                __body["data_description"] = data_description
+            if allow_lazy_open is not None:
+                __body["allow_lazy_open"] = allow_lazy_open
+            if analysis_limits is not None:
+                __body["analysis_limits"] = analysis_limits
+            if background_persist_interval is not None:
+                __body["background_persist_interval"] = background_persist_interval
+            if custom_settings is not None:
+                __body["custom_settings"] = custom_settings
+            if daily_model_snapshot_retention_after_days is not None:
+                __body["daily_model_snapshot_retention_after_days"] = (
+                    daily_model_snapshot_retention_after_days
+                )
+            if datafeed_config is not None:
+                __body["datafeed_config"] = datafeed_config
+            if description is not None:
+                __body["description"] = description
+            if groups is not None:
+                __body["groups"] = groups
+            if model_plot_config is not None:
+                __body["model_plot_config"] = model_plot_config
+            if model_snapshot_retention_days is not None:
+                __body["model_snapshot_retention_days"] = model_snapshot_retention_days
+            if renormalization_window_days is not None:
+                __body["renormalization_window_days"] = renormalization_window_days
+            if results_index_name is not None:
+                __body["results_index_name"] = results_index_name
+            if results_retention_days is not None:
+                __body["results_retention_days"] = results_retention_days
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "compressed_definition",
+            "definition",
+            "description",
+            "inference_config",
+            "input",
+            "metadata",
+            "model_size_bytes",
+            "model_type",
+            "platform_architecture",
+            "prefix_strings",
+            "tags",
+        ),
     )
     def put_trained_model(
         self,
         *,
         model_id: str,
         compressed_definition: t.Optional[str] = None,
         defer_definition_decompression: t.Optional[bool] = None,
         definition: t.Optional[t.Mapping[str, t.Any]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         inference_config: t.Optional[t.Mapping[str, t.Any]] = None,
         input: t.Optional[t.Mapping[str, t.Any]] = None,
         metadata: t.Optional[t.Any] = None,
         model_size_bytes: t.Optional[int] = None,
         model_type: t.Optional[
             t.Union["t.Literal['lang_ident', 'pytorch', 'tree_ensemble']", str]
         ] = None,
+        platform_architecture: t.Optional[str] = None,
+        prefix_strings: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
-        tags: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        tags: t.Optional[t.Sequence[str]] = None,
+        wait_for_completion: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates an inference trained model.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-trained-models.html>`_
 
         :param model_id: The unique identifier of the trained model.
@@ -2314,64 +2312,80 @@
             the config is not required.
         :param input: The input field names for the model definition.
         :param metadata: An object map that contains metadata about the model.
         :param model_size_bytes: The estimated memory usage in bytes to keep the trained
             model in memory. This property is supported only if defer_definition_decompression
             is true or the model definition is not supplied.
         :param model_type: The model type.
+        :param platform_architecture: The platform architecture (if applicable) of the
+            trained mode. If the model only works on one platform, because it is heavily
+            optimized for a particular processor architecture and OS combination, then
+            this field specifies which. The format of the string must match the platform
+            identifiers used by Elasticsearch, so one of, `linux-x86_64`, `linux-aarch64`,
+            `darwin-x86_64`, `darwin-aarch64`, or `windows-x86_64`. For portable models
+            (those that work independent of processor architecture or OS features), leave
+            this field unset.
+        :param prefix_strings: Optional prefix strings applied at inference
         :param tags: An array of tags to organize the model.
+        :param wait_for_completion: Whether to wait for all child operations (e.g. model
+            download) to complete.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
         __path = f"/_ml/trained_models/{_quote(model_id)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if compressed_definition is not None:
-            __body["compressed_definition"] = compressed_definition
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if defer_definition_decompression is not None:
             __query["defer_definition_decompression"] = defer_definition_decompression
-        if definition is not None:
-            __body["definition"] = definition
-        if description is not None:
-            __body["description"] = description
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if inference_config is not None:
-            __body["inference_config"] = inference_config
-        if input is not None:
-            __body["input"] = input
-        if metadata is not None:
-            __body["metadata"] = metadata
-        if model_size_bytes is not None:
-            __body["model_size_bytes"] = model_size_bytes
-        if model_type is not None:
-            __body["model_type"] = model_type
         if pretty is not None:
             __query["pretty"] = pretty
-        if tags is not None:
-            __body["tags"] = tags
+        if wait_for_completion is not None:
+            __query["wait_for_completion"] = wait_for_completion
+        if not __body:
+            if compressed_definition is not None:
+                __body["compressed_definition"] = compressed_definition
+            if definition is not None:
+                __body["definition"] = definition
+            if description is not None:
+                __body["description"] = description
+            if inference_config is not None:
+                __body["inference_config"] = inference_config
+            if input is not None:
+                __body["input"] = input
+            if metadata is not None:
+                __body["metadata"] = metadata
+            if model_size_bytes is not None:
+                __body["model_size_bytes"] = model_size_bytes
+            if model_type is not None:
+                __body["model_type"] = model_type
+            if platform_architecture is not None:
+                __body["platform_architecture"] = platform_architecture
+            if prefix_strings is not None:
+                __body["prefix_strings"] = prefix_strings
+            if tags is not None:
+                __body["tags"] = tags
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     def put_trained_model_alias(
         self,
         *,
         model_id: str,
         model_alias: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         reassign: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a new model alias (or reassigns an existing one) to refer to the trained
         model
@@ -2402,30 +2416,29 @@
             __query["reassign"] = reassign
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("definition", "total_definition_length", "total_parts"),
     )
     def put_trained_model_definition_part(
         self,
         *,
         model_id: str,
         part: int,
-        definition: str,
-        total_definition_length: int,
-        total_parts: int,
+        definition: t.Optional[str] = None,
+        total_definition_length: t.Optional[int] = None,
+        total_parts: t.Optional[int] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates part of a trained model definition
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-trained-model-definition-part.html>`_
 
         :param model_id: The unique identifier of the trained model.
@@ -2439,103 +2452,106 @@
         :param total_parts: The total number of parts that will be uploaded. Must be
             greater than 0.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
         if part in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'part'")
-        if definition is None:
+        if definition is None and body is None:
             raise ValueError("Empty value passed for parameter 'definition'")
-        if total_definition_length is None:
+        if total_definition_length is None and body is None:
             raise ValueError(
                 "Empty value passed for parameter 'total_definition_length'"
             )
-        if total_parts is None:
+        if total_parts is None and body is None:
             raise ValueError("Empty value passed for parameter 'total_parts'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/definition/{_quote(part)}"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if definition is not None:
-            __body["definition"] = definition
-        if total_definition_length is not None:
-            __body["total_definition_length"] = total_definition_length
-        if total_parts is not None:
-            __body["total_parts"] = total_parts
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if definition is not None:
+                __body["definition"] = definition
+            if total_definition_length is not None:
+                __body["total_definition_length"] = total_definition_length
+            if total_parts is not None:
+                __body["total_parts"] = total_parts
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("vocabulary", "merges", "scores"),
     )
     def put_trained_model_vocabulary(
         self,
         *,
         model_id: str,
-        vocabulary: t.Union[t.List[str], t.Tuple[str, ...]],
+        vocabulary: t.Optional[t.Sequence[str]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        merges: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        merges: t.Optional[t.Sequence[str]] = None,
         pretty: t.Optional[bool] = None,
+        scores: t.Optional[t.Sequence[float]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates a trained model vocabulary
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-trained-model-vocabulary.html>`_
 
         :param model_id: The unique identifier of the trained model.
         :param vocabulary: The model vocabulary, which must not be empty.
         :param merges: The optional model merges if required by the tokenizer.
+        :param scores: The optional vocabulary value scores if required by the tokenizer.
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
-        if vocabulary is None:
+        if vocabulary is None and body is None:
             raise ValueError("Empty value passed for parameter 'vocabulary'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/vocabulary"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if vocabulary is not None:
-            __body["vocabulary"] = vocabulary
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if merges is not None:
-            __body["merges"] = merges
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if vocabulary is not None:
+                __body["vocabulary"] = vocabulary
+            if merges is not None:
+                __body["merges"] = merges
+            if scores is not None:
+                __body["scores"] = scores
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     def reset_job(
         self,
         *,
         job_id: str,
         delete_user_annotations: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         wait_for_completion: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Resets an existing anomaly detection job.
 
@@ -2571,17 +2587,15 @@
 
     @_rewrite_parameters()
     def start_data_frame_analytics(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Starts a data frame analytics job.
 
@@ -2609,29 +2623,28 @@
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("end", "start", "timeout"),
     )
     def start_datafeed(
         self,
         *,
         datafeed_id: str,
         end: t.Optional[t.Union[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         start: t.Optional[t.Union[str, t.Any]] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Starts one or more datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-start-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -2641,30 +2654,31 @@
         :param end: Refer to the description for the `end` query parameter.
         :param start: Refer to the description for the `start` query parameter.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_start"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if end is not None:
-            __body["end"] = end
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if start is not None:
-            __body["start"] = start
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if end is not None:
+                __body["end"] = end
+            if start is not None:
+                __body["start"] = start
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -2672,18 +2686,17 @@
 
     @_rewrite_parameters()
     def start_trained_model_deployment(
         self,
         *,
         model_id: str,
         cache_size: t.Optional[t.Union[int, str]] = None,
+        deployment_id: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         number_of_allocations: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         priority: t.Optional[t.Union["t.Literal['low', 'normal']", str]] = None,
         queue_capacity: t.Optional[int] = None,
         threads_per_allocation: t.Optional[int] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
@@ -2697,14 +2710,15 @@
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/start-trained-model-deployment.html>`_
 
         :param model_id: The unique identifier of the trained model. Currently, only
             PyTorch models are supported.
         :param cache_size: The inference cache size (in memory outside the JVM heap)
             per node for the model. The default value is the same size as the `model_size_bytes`.
             To disable the cache, `0b` can be provided.
+        :param deployment_id: A unique identifier for the deployment of the model.
         :param number_of_allocations: The number of model allocations on each node where
             the model is deployed. All allocations on a node share the same copy of the
             model in memory but use a separate set of threads to evaluate the model.
             Increasing this value generally increases the throughput. If this setting
             is greater than the number of hardware threads it will automatically be changed
             to a value less than the number of hardware threads.
         :param priority: The deployment priority.
@@ -2723,14 +2737,16 @@
         """
         if model_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'model_id'")
         __path = f"/_ml/trained_models/{_quote(model_id)}/deployment/_start"
         __query: t.Dict[str, t.Any] = {}
         if cache_size is not None:
             __query["cache_size"] = cache_size
+        if deployment_id is not None:
+            __query["deployment_id"] = deployment_id
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if number_of_allocations is not None:
@@ -2755,17 +2771,15 @@
     @_rewrite_parameters()
     def stop_data_frame_analytics(
         self,
         *,
         id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Stops one or more data frame analytics jobs.
@@ -2807,29 +2821,28 @@
             __query["timeout"] = timeout
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("allow_no_match", "force", "timeout"),
     )
     def stop_datafeed(
         self,
         *,
         datafeed_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         timeout: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Stops one or more datafeeds.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-stop-datafeed.html>`_
 
         :param datafeed_id: Identifier for the datafeed. You can stop multiple datafeeds
@@ -2840,30 +2853,31 @@
             parameter.
         :param force: Refer to the description for the `force` query parameter.
         :param timeout: Refer to the description for the `timeout` query parameter.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_stop"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_match is not None:
-            __body["allow_no_match"] = allow_no_match
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if force is not None:
-            __body["force"] = force
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if timeout is not None:
-            __body["timeout"] = timeout
+        if not __body:
+            if allow_no_match is not None:
+                __body["allow_no_match"] = allow_no_match
+            if force is not None:
+                __body["force"] = force
+            if timeout is not None:
+                __body["timeout"] = timeout
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
@@ -2872,17 +2886,15 @@
     @_rewrite_parameters()
     def stop_trained_model_deployment(
         self,
         *,
         model_id: str,
         allow_no_match: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         force: t.Optional[bool] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Stop a trained model deployment.
 
@@ -2917,30 +2929,34 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "allow_lazy_start",
+            "description",
+            "max_num_threads",
+            "model_memory_limit",
+        ),
     )
     def update_data_frame_analytics(
         self,
         *,
         id: str,
         allow_lazy_start: t.Optional[bool] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         max_num_threads: t.Optional[int] = None,
         model_memory_limit: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of a data frame analytics job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/update-dfanalytics.html>`_
 
         :param id: Identifier for the data frame analytics job. This identifier can contain
@@ -2958,85 +2974,90 @@
             file contains an `xpack.ml.max_model_memory_limit` setting, an error occurs
             when you try to create data frame analytics jobs that have `model_memory_limit`
             values greater than that setting.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/_ml/data_frame/analytics/{_quote(id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_lazy_start is not None:
-            __body["allow_lazy_start"] = allow_lazy_start
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if max_num_threads is not None:
-            __body["max_num_threads"] = max_num_threads
-        if model_memory_limit is not None:
-            __body["model_memory_limit"] = model_memory_limit
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if allow_lazy_start is not None:
+                __body["allow_lazy_start"] = allow_lazy_start
+            if description is not None:
+                __body["description"] = description
+            if max_num_threads is not None:
+                __body["max_num_threads"] = max_num_threads
+            if model_memory_limit is not None:
+                __body["model_memory_limit"] = model_memory_limit
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "chunking_config",
+            "delayed_data_check_config",
+            "frequency",
+            "indexes",
+            "indices",
+            "indices_options",
+            "job_id",
+            "max_empty_searches",
+            "query",
+            "query_delay",
+            "runtime_mappings",
+            "script_fields",
+            "scroll_size",
+        ),
     )
     def update_datafeed(
         self,
         *,
         datafeed_id: str,
         aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         allow_no_indices: t.Optional[bool] = None,
         chunking_config: t.Optional[t.Mapping[str, t.Any]] = None,
         delayed_data_check_config: t.Optional[t.Mapping[str, t.Any]] = None,
         error_trace: t.Optional[bool] = None,
         expand_wildcards: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
+                t.Sequence[
+                    t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str]
                 ],
+                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         frequency: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         human: t.Optional[bool] = None,
         ignore_throttled: t.Optional[bool] = None,
         ignore_unavailable: t.Optional[bool] = None,
-        indexes: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
-        indices: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        indexes: t.Optional[t.Sequence[str]] = None,
+        indices: t.Optional[t.Sequence[str]] = None,
         indices_options: t.Optional[t.Mapping[str, t.Any]] = None,
         job_id: t.Optional[str] = None,
         max_empty_searches: t.Optional[int] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         query_delay: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
         runtime_mappings: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         script_fields: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         scroll_size: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of a datafeed.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-update-datafeed.html>`_
 
         :param datafeed_id: A numerical character string that uniquely identifies the
@@ -3118,152 +3139,164 @@
         :param scroll_size: The size parameter that is used in Elasticsearch searches
             when the datafeed does not use aggregations. The maximum value is the value
             of `index.max_result_window`.
         """
         if datafeed_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'datafeed_id'")
         __path = f"/_ml/datafeeds/{_quote(datafeed_id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if aggregations is not None:
-            __body["aggregations"] = aggregations
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if allow_no_indices is not None:
             __query["allow_no_indices"] = allow_no_indices
-        if chunking_config is not None:
-            __body["chunking_config"] = chunking_config
-        if delayed_data_check_config is not None:
-            __body["delayed_data_check_config"] = delayed_data_check_config
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if expand_wildcards is not None:
             __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if frequency is not None:
-            __body["frequency"] = frequency
         if human is not None:
             __query["human"] = human
         if ignore_throttled is not None:
             __query["ignore_throttled"] = ignore_throttled
         if ignore_unavailable is not None:
             __query["ignore_unavailable"] = ignore_unavailable
-        if indexes is not None:
-            __body["indexes"] = indexes
-        if indices is not None:
-            __body["indices"] = indices
-        if indices_options is not None:
-            __body["indices_options"] = indices_options
-        if job_id is not None:
-            __body["job_id"] = job_id
-        if max_empty_searches is not None:
-            __body["max_empty_searches"] = max_empty_searches
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if query_delay is not None:
-            __body["query_delay"] = query_delay
-        if runtime_mappings is not None:
-            __body["runtime_mappings"] = runtime_mappings
-        if script_fields is not None:
-            __body["script_fields"] = script_fields
-        if scroll_size is not None:
-            __body["scroll_size"] = scroll_size
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if chunking_config is not None:
+                __body["chunking_config"] = chunking_config
+            if delayed_data_check_config is not None:
+                __body["delayed_data_check_config"] = delayed_data_check_config
+            if frequency is not None:
+                __body["frequency"] = frequency
+            if indexes is not None:
+                __body["indexes"] = indexes
+            if indices is not None:
+                __body["indices"] = indices
+            if indices_options is not None:
+                __body["indices_options"] = indices_options
+            if job_id is not None:
+                __body["job_id"] = job_id
+            if max_empty_searches is not None:
+                __body["max_empty_searches"] = max_empty_searches
+            if query is not None:
+                __body["query"] = query
+            if query_delay is not None:
+                __body["query_delay"] = query_delay
+            if runtime_mappings is not None:
+                __body["runtime_mappings"] = runtime_mappings
+            if script_fields is not None:
+                __body["script_fields"] = script_fields
+            if scroll_size is not None:
+                __body["scroll_size"] = scroll_size
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("add_items", "description", "remove_items"),
     )
     def update_filter(
         self,
         *,
         filter_id: str,
-        add_items: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        add_items: t.Optional[t.Sequence[str]] = None,
         description: t.Optional[str] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
-        remove_items: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        remove_items: t.Optional[t.Sequence[str]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates the description of a filter, adds items, or removes items.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-update-filter.html>`_
 
         :param filter_id: A string that uniquely identifies a filter.
         :param add_items: The items to add to the filter.
         :param description: A description for the filter.
         :param remove_items: The items to remove from the filter.
         """
         if filter_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'filter_id'")
         __path = f"/_ml/filters/{_quote(filter_id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if add_items is not None:
-            __body["add_items"] = add_items
-        if description is not None:
-            __body["description"] = description
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if remove_items is not None:
-            __body["remove_items"] = remove_items
+        if not __body:
+            if add_items is not None:
+                __body["add_items"] = add_items
+            if description is not None:
+                __body["description"] = description
+            if remove_items is not None:
+                __body["remove_items"] = remove_items
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "allow_lazy_open",
+            "analysis_limits",
+            "background_persist_interval",
+            "categorization_filters",
+            "custom_settings",
+            "daily_model_snapshot_retention_after_days",
+            "description",
+            "detectors",
+            "groups",
+            "model_plot_config",
+            "model_prune_window",
+            "model_snapshot_retention_days",
+            "per_partition_categorization",
+            "renormalization_window_days",
+            "results_retention_days",
+        ),
     )
     def update_job(
         self,
         *,
         job_id: str,
         allow_lazy_open: t.Optional[bool] = None,
         analysis_limits: t.Optional[t.Mapping[str, t.Any]] = None,
         background_persist_interval: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
-        categorization_filters: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
+        categorization_filters: t.Optional[t.Sequence[str]] = None,
         custom_settings: t.Optional[t.Mapping[str, t.Any]] = None,
         daily_model_snapshot_retention_after_days: t.Optional[int] = None,
         description: t.Optional[str] = None,
-        detectors: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        detectors: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
-        groups: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        groups: t.Optional[t.Sequence[str]] = None,
         human: t.Optional[bool] = None,
         model_plot_config: t.Optional[t.Mapping[str, t.Any]] = None,
         model_prune_window: t.Optional[
             t.Union["t.Literal[-1]", "t.Literal[0]", str]
         ] = None,
         model_snapshot_retention_days: t.Optional[int] = None,
         per_partition_categorization: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         renormalization_window_days: t.Optional[int] = None,
         results_retention_days: t.Optional[int] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates certain properties of an anomaly detection job.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/ml-update-job.html>`_
 
         :param job_id: Identifier for the job.
@@ -3314,53 +3347,54 @@
             per day at 00:30 (server time), results that are the specified number of
             days older than the latest bucket result are deleted from Elasticsearch.
             The default value is null, which means all results are retained.
         """
         if job_id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'job_id'")
         __path = f"/_ml/anomaly_detectors/{_quote(job_id)}/_update"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if allow_lazy_open is not None:
-            __body["allow_lazy_open"] = allow_lazy_open
-        if analysis_limits is not None:
-            __body["analysis_limits"] = analysis_limits
-        if background_persist_interval is not None:
-            __body["background_persist_interval"] = background_persist_interval
-        if categorization_filters is not None:
-            __body["categorization_filters"] = categorization_filters
-        if custom_settings is not None:
-            __body["custom_settings"] = custom_settings
-        if daily_model_snapshot_retention_after_days is not None:
-            __body[
-                "daily_model_snapshot_retention_after_days"
-            ] = daily_model_snapshot_retention_after_days
-        if description is not None:
-            __body["description"] = description
-        if detectors is not None:
-            __body["detectors"] = detectors
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if groups is not None:
-            __body["groups"] = groups
-        if human is not None:
-            __query["human"] = human
-        if model_plot_config is not None:
-            __body["model_plot_config"] = model_plot_config
-        if model_prune_window is not None:
-            __body["model_prune_window"] = model_prune_window
-        if model_snapshot_retention_days is not None:
-            __body["model_snapshot_retention_days"] = model_snapshot_retention_days
-        if per_partition_categorization is not None:
-            __body["per_partition_categorization"] = per_partition_categorization
-        if pretty is not None:
-            __query["pretty"] = pretty
-        if renormalization_window_days is not None:
-            __body["renormalization_window_days"] = renormalization_window_days
-        if results_retention_days is not None:
-            __body["results_retention_days"] = results_retention_days
+        if human is not None:
+            __query["human"] = human
+        if pretty is not None:
+            __query["pretty"] = pretty
+        if not __body:
+            if allow_lazy_open is not None:
+                __body["allow_lazy_open"] = allow_lazy_open
+            if analysis_limits is not None:
+                __body["analysis_limits"] = analysis_limits
+            if background_persist_interval is not None:
+                __body["background_persist_interval"] = background_persist_interval
+            if categorization_filters is not None:
+                __body["categorization_filters"] = categorization_filters
+            if custom_settings is not None:
+                __body["custom_settings"] = custom_settings
+            if daily_model_snapshot_retention_after_days is not None:
+                __body["daily_model_snapshot_retention_after_days"] = (
+                    daily_model_snapshot_retention_after_days
+                )
+            if description is not None:
+                __body["description"] = description
+            if detectors is not None:
+                __body["detectors"] = detectors
+            if groups is not None:
+                __body["groups"] = groups
+            if model_plot_config is not None:
+                __body["model_plot_config"] = model_plot_config
+            if model_prune_window is not None:
+                __body["model_prune_window"] = model_prune_window
+            if model_snapshot_retention_days is not None:
+                __body["model_snapshot_retention_days"] = model_snapshot_retention_days
+            if per_partition_categorization is not None:
+                __body["per_partition_categorization"] = per_partition_categorization
+            if renormalization_window_days is not None:
+                __body["renormalization_window_days"] = renormalization_window_days
+            if results_retention_days is not None:
+                __body["results_retention_days"] = results_retention_days
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/searchable_snapshots.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_async/client/inference.py`

 * *Files 24% similar despite different names*

```diff
@@ -19,247 +19,227 @@
 
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
-class SearchableSnapshotsClient(NamespacedClient):
+class InferenceClient(NamespacedClient):
+
     @_rewrite_parameters()
-    def cache_stats(
+    async def delete_model(
         self,
         *,
-        node_id: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        inference_id: str,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieve node-level cache statistics about searchable snapshots.
+        Delete model in the Inference API
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-apis.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-inference-api.html>`_
 
-        :param node_id: A comma-separated list of node IDs or names to limit the returned
-            information; use `_local` to return information from the node you're connecting
-            to, leave empty to get information from all nodes
-        :param master_timeout:
+        :param inference_id: The inference Id
+        :param task_type: The task type
         """
-        if node_id not in SKIP_IN_PATH:
-            __path = f"/_searchable_snapshots/{_quote(node_id)}/cache/stats"
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
         else:
-            __path = "/_searchable_snapshots/cache/stats"
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        return await self.perform_request(  # type: ignore[return-value]
+            "DELETE", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters()
-    def clear_cache(
+    async def get_model(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        allow_no_indices: t.Optional[bool] = None,
-        error_trace: t.Optional[bool] = None,
-        expand_wildcards: t.Optional[
+        inference_id: str,
+        task_type: t.Optional[
             t.Union[
-                t.Union["t.Literal['all', 'closed', 'hidden', 'none', 'open']", str],
-                t.Union[
-                    t.List[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ]
-                    ],
-                    t.Tuple[
-                        t.Union[
-                            "t.Literal['all', 'closed', 'hidden', 'none', 'open']", str
-                        ],
-                        ...,
-                    ],
-                ],
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
             ]
         ] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ignore_unavailable: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Clear the cache of searchable snapshots.
+        Get a model in the Inference API
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-apis.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/get-inference-api.html>`_
 
-        :param index: A comma-separated list of index names
-        :param allow_no_indices: Whether to ignore if a wildcard indices expression resolves
-            into no concrete indices. (This includes `_all` string or when no indices
-            have been specified)
-        :param expand_wildcards: Whether to expand wildcard expression to concrete indices
-            that are open, closed or both.
-        :param ignore_unavailable: Whether specified concrete indices should be ignored
-            when unavailable (missing or closed)
+        :param inference_id: The inference Id
+        :param task_type: The task type
         """
-        if index not in SKIP_IN_PATH:
-            __path = f"/{_quote(index)}/_searchable_snapshots/cache/clear"
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
         else:
-            __path = "/_searchable_snapshots/cache/clear"
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
-        if allow_no_indices is not None:
-            __query["allow_no_indices"] = allow_no_indices
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if expand_wildcards is not None:
-            __query["expand_wildcards"] = expand_wildcards
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ignore_unavailable is not None:
-            __query["ignore_unavailable"] = ignore_unavailable
         if pretty is not None:
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
-            "POST", __path, params=__query, headers=__headers
+        return await self.perform_request(  # type: ignore[return-value]
+            "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("input", "query", "task_settings"),
     )
-    def mount(
+    async def inference(
         self,
         *,
-        repository: str,
-        snapshot: str,
-        index: str,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        inference_id: str,
+        input: t.Optional[t.Union[str, t.Sequence[str]]] = None,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        ignore_index_settings: t.Optional[
-            t.Union[t.List[str], t.Tuple[str, ...]]
-        ] = None,
-        index_settings: t.Optional[t.Mapping[str, t.Any]] = None,
-        master_timeout: t.Optional[
-            t.Union["t.Literal[-1]", "t.Literal[0]", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
-        renamed_index: t.Optional[str] = None,
-        storage: t.Optional[str] = None,
-        wait_for_completion: t.Optional[bool] = None,
+        query: t.Optional[str] = None,
+        task_settings: t.Optional[t.Any] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Mount a snapshot as a searchable index.
+        Perform inference on a model
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-api-mount-snapshot.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/post-inference-api.html>`_
 
-        :param repository: The name of the repository containing the snapshot of the
-            index to mount
-        :param snapshot: The name of the snapshot of the index to mount
-        :param index:
-        :param ignore_index_settings:
-        :param index_settings:
-        :param master_timeout: Explicit operation timeout for connection to master node
-        :param renamed_index:
-        :param storage: Selects the kind of local storage used to accelerate searches.
-            Experimental, and defaults to `full_copy`
-        :param wait_for_completion: Should this request wait until the operation has
-            completed before returning
-        """
-        if repository in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'repository'")
-        if snapshot in SKIP_IN_PATH:
-            raise ValueError("Empty value passed for parameter 'snapshot'")
-        if index is None:
-            raise ValueError("Empty value passed for parameter 'index'")
-        __path = f"/_snapshot/{_quote(repository)}/{_quote(snapshot)}/_mount"
-        __body: t.Dict[str, t.Any] = {}
+        :param inference_id: The inference Id
+        :param input: Text input to the model. Either a string or an array of strings.
+        :param task_type: The task type
+        :param query: Query input, required for rerank task. Not required for other tasks.
+        :param task_settings: Optional task settings
+        """
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if input is None and body is None:
+            raise ValueError("Empty value passed for parameter 'input'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
+        else:
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
-        if index is not None:
-            __body["index"] = index
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if ignore_index_settings is not None:
-            __body["ignore_index_settings"] = ignore_index_settings
-        if index_settings is not None:
-            __body["index_settings"] = index_settings
-        if master_timeout is not None:
-            __query["master_timeout"] = master_timeout
         if pretty is not None:
             __query["pretty"] = pretty
-        if renamed_index is not None:
-            __body["renamed_index"] = renamed_index
-        if storage is not None:
-            __query["storage"] = storage
-        if wait_for_completion is not None:
-            __query["wait_for_completion"] = wait_for_completion
-        __headers = {"accept": "application/json", "content-type": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
+        if not __body:
+            if input is not None:
+                __body["input"] = input
+            if query is not None:
+                __body["query"] = query
+            if task_settings is not None:
+                __body["task_settings"] = task_settings
+        if not __body:
+            __body = None  # type: ignore[assignment]
+        __headers = {"accept": "application/json"}
+        if __body is not None:
+            __headers["content-type"] = "application/json"
+        return await self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
-    @_rewrite_parameters()
-    def stats(
+    @_rewrite_parameters(
+        body_name="model_config",
+    )
+    async def put_model(
         self,
         *,
-        index: t.Optional[t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]] = None,
-        error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
+        inference_id: str,
+        model_config: t.Optional[t.Mapping[str, t.Any]] = None,
+        body: t.Optional[t.Mapping[str, t.Any]] = None,
+        task_type: t.Optional[
+            t.Union[
+                "t.Literal['completion', 'rerank', 'sparse_embedding', 'text_embedding']",
+                str,
+            ]
         ] = None,
+        error_trace: t.Optional[bool] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        level: t.Optional[
-            t.Union["t.Literal['cluster', 'indices', 'shards']", str]
-        ] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
-        Retrieve shard-level statistics about searchable snapshots.
+        Configure a model for use in the Inference API
 
-        `<https://www.elastic.co/guide/en/elasticsearch/reference/generated/searchable-snapshots-apis.html>`_
+        `<https://www.elastic.co/guide/en/elasticsearch/reference/master/put-inference-api.html>`_
 
-        :param index: A comma-separated list of index names
-        :param level: Return stats aggregated at cluster, index or shard level
-        """
-        if index not in SKIP_IN_PATH:
-            __path = f"/{_quote(index)}/_searchable_snapshots/stats"
+        :param inference_id: The inference Id
+        :param model_config:
+        :param task_type: The task type
+        """
+        if inference_id in SKIP_IN_PATH:
+            raise ValueError("Empty value passed for parameter 'inference_id'")
+        if model_config is None and body is None:
+            raise ValueError(
+                "Empty value passed for parameters 'model_config' and 'body', one of them should be set."
+            )
+        elif model_config is not None and body is not None:
+            raise ValueError("Cannot set both 'model_config' and 'body'")
+        if task_type not in SKIP_IN_PATH and inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(task_type)}/{_quote(inference_id)}"
+        elif inference_id not in SKIP_IN_PATH:
+            __path = f"/_inference/{_quote(inference_id)}"
         else:
-            __path = "/_searchable_snapshots/stats"
+            raise ValueError("Couldn't find a path for the given parameters")
         __query: t.Dict[str, t.Any] = {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if level is not None:
-            __query["level"] = level
         if pretty is not None:
             __query["pretty"] = pretty
-        __headers = {"accept": "application/json"}
-        return self.perform_request(  # type: ignore[return-value]
-            "GET", __path, params=__query, headers=__headers
+        __body = model_config if model_config is not None else body
+        __headers = {"accept": "application/json", "content-type": "application/json"}
+        return await self.perform_request(  # type: ignore[return-value]
+            "PUT", __path, params=__query, headers=__headers, body=__body
         )
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/security.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/security.py`

 * *Files 16% similar despite different names*

```diff
@@ -20,22 +20,21 @@
 from elastic_transport import ObjectApiResponse
 
 from ._base import NamespacedClient
 from .utils import SKIP_IN_PATH, _quote, _rewrite_parameters
 
 
 class SecurityClient(NamespacedClient):
+
     @_rewrite_parameters()
     def authenticate(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Enables authentication as a user and retrieve information about the authenticated
         user.
 
@@ -53,32 +52,31 @@
             __query["pretty"] = pretty
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("expiration", "metadata", "name", "role_descriptors"),
     )
     def create_api_key(
         self,
         *,
         error_trace: t.Optional[bool] = None,
         expiration: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         metadata: t.Optional[t.Mapping[str, t.Any]] = None,
         name: t.Optional[str] = None,
         pretty: t.Optional[bool] = None,
         refresh: t.Optional[
             t.Union["t.Literal['false', 'true', 'wait_for']", bool, str]
         ] = None,
         role_descriptors: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Creates an API key for access without requiring basic authentication.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-create-api-key.html>`_
 
         :param expiration: Expiration time for the API key. By default, API keys never
@@ -97,60 +95,66 @@
             be an intersection of API keys permissions and authenticated user’s permissions
             thereby limiting the access scope for API keys. The structure of role descriptor
             is the same as the request for create role API. For more details, see create
             or update roles API.
         """
         __path = "/_security/api_key"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
-        if expiration is not None:
-            __body["expiration"] = expiration
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if metadata is not None:
-            __body["metadata"] = metadata
-        if name is not None:
-            __body["name"] = name
         if pretty is not None:
             __query["pretty"] = pretty
         if refresh is not None:
             __query["refresh"] = refresh
-        if role_descriptors is not None:
-            __body["role_descriptors"] = role_descriptors
+        if not __body:
+            if expiration is not None:
+                __body["expiration"] = expiration
+            if metadata is not None:
+                __body["metadata"] = metadata
+            if name is not None:
+                __body["name"] = name
+            if role_descriptors is not None:
+                __body["role_descriptors"] = role_descriptors
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters()
     def get_api_key(
         self,
         *,
+        active_only: t.Optional[bool] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         id: t.Optional[str] = None,
         name: t.Optional[str] = None,
         owner: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         realm_name: t.Optional[str] = None,
         username: t.Optional[str] = None,
         with_limited_by: t.Optional[bool] = None,
+        with_profile_uid: t.Optional[bool] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves information for one or more API keys.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-get-api-key.html>`_
 
+        :param active_only: A boolean flag that can be used to query API keys that are
+            currently active. An API key is considered active if it is neither invalidated,
+            nor expired at query time. You can specify this together with other parameters
+            such as `owner` or `name`. If `active_only` is false, the response will include
+            both active and inactive (expired or invalidated) keys.
         :param id: An API key id. This parameter cannot be used with any of `name`, `realm_name`
             or `username`.
         :param name: An API key name. This parameter cannot be used with any of `id`,
             `realm_name` or `username`. It supports prefix search with wildcard.
         :param owner: A boolean flag that can be used to query API keys owned by the
             currently authenticated user. The `realm_name` or `username` parameters cannot
             be specified when this parameter is set to `true` as they are assumed to
@@ -158,17 +162,21 @@
         :param realm_name: The name of an authentication realm. This parameter cannot
             be used with either `id` or `name` or when `owner` flag is set to `true`.
         :param username: The username of a user. This parameter cannot be used with either
             `id` or `name` or when `owner` flag is set to `true`.
         :param with_limited_by: Return the snapshot of the owner user's role descriptors
             associated with the API key. An API key's actual permission is the intersection
             of its assigned role descriptors and the owner user's role descriptors.
+        :param with_profile_uid: Determines whether to also retrieve the profile uid,
+            for the API key owner principal, if it exists.
         """
         __path = "/_security/api_key"
         __query: t.Dict[str, t.Any] = {}
+        if active_only is not None:
+            __query["active_only"] = active_only
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
         if id is not None:
@@ -181,55 +189,43 @@
             __query["pretty"] = pretty
         if realm_name is not None:
             __query["realm_name"] = realm_name
         if username is not None:
             __query["username"] = username
         if with_limited_by is not None:
             __query["with_limited_by"] = with_limited_by
+        if with_profile_uid is not None:
+            __query["with_profile_uid"] = with_profile_uid
         __headers = {"accept": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "GET", __path, params=__query, headers=__headers
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("application", "cluster", "index"),
     )
     def has_privileges(
         self,
         *,
         user: t.Optional[str] = None,
-        application: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        application: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         cluster: t.Optional[
-            t.Union[
-                t.List[
-                    t.Union[
-                        "t.Literal['all', 'cancel_task', 'create_snapshot', 'grant_api_key', 'manage', 'manage_api_key', 'manage_ccr', 'manage_enrich', 'manage_ilm', 'manage_index_templates', 'manage_ingest_pipelines', 'manage_logstash_pipelines', 'manage_ml', 'manage_oidc', 'manage_own_api_key', 'manage_pipeline', 'manage_rollup', 'manage_saml', 'manage_security', 'manage_service_account', 'manage_slm', 'manage_token', 'manage_transform', 'manage_user_profile', 'manage_watcher', 'monitor', 'monitor_ml', 'monitor_rollup', 'monitor_snapshot', 'monitor_text_structure', 'monitor_transform', 'monitor_watcher', 'read_ccr', 'read_ilm', 'read_pipeline', 'read_slm', 'transport_client']",
-                        str,
-                    ]
-                ],
-                t.Tuple[
-                    t.Union[
-                        "t.Literal['all', 'cancel_task', 'create_snapshot', 'grant_api_key', 'manage', 'manage_api_key', 'manage_ccr', 'manage_enrich', 'manage_ilm', 'manage_index_templates', 'manage_ingest_pipelines', 'manage_logstash_pipelines', 'manage_ml', 'manage_oidc', 'manage_own_api_key', 'manage_pipeline', 'manage_rollup', 'manage_saml', 'manage_security', 'manage_service_account', 'manage_slm', 'manage_token', 'manage_transform', 'manage_user_profile', 'manage_watcher', 'monitor', 'monitor_ml', 'monitor_rollup', 'monitor_snapshot', 'monitor_text_structure', 'monitor_transform', 'monitor_watcher', 'read_ccr', 'read_ilm', 'read_pipeline', 'read_slm', 'transport_client']",
-                        str,
-                    ],
-                    ...,
-                ],
+            t.Sequence[
+                t.Union[
+                    "t.Literal['all', 'cancel_task', 'create_snapshot', 'grant_api_key', 'manage', 'manage_api_key', 'manage_ccr', 'manage_enrich', 'manage_ilm', 'manage_index_templates', 'manage_ingest_pipelines', 'manage_logstash_pipelines', 'manage_ml', 'manage_oidc', 'manage_own_api_key', 'manage_pipeline', 'manage_rollup', 'manage_saml', 'manage_security', 'manage_service_account', 'manage_slm', 'manage_token', 'manage_transform', 'manage_user_profile', 'manage_watcher', 'monitor', 'monitor_ml', 'monitor_rollup', 'monitor_snapshot', 'monitor_text_structure', 'monitor_transform', 'monitor_watcher', 'read_ccr', 'read_ilm', 'read_pipeline', 'read_slm', 'transport_client']",
+                    str,
+                ]
             ]
         ] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
-        index: t.Optional[
-            t.Union[t.List[t.Mapping[str, t.Any]], t.Tuple[t.Mapping[str, t.Any], ...]]
-        ] = None,
+        index: t.Optional[t.Sequence[t.Mapping[str, t.Any]]] = None,
         pretty: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Determines whether the specified user has a specified list of privileges.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-has-privileges.html>`_
 
         :param user: Username
@@ -237,53 +233,53 @@
         :param cluster: A list of the cluster privileges that you want to check.
         :param index:
         """
         if user not in SKIP_IN_PATH:
             __path = f"/_security/user/{_quote(user)}/_has_privileges"
         else:
             __path = "/_security/user/_has_privileges"
-        __body: t.Dict[str, t.Any] = {}
         __query: t.Dict[str, t.Any] = {}
-        if application is not None:
-            __body["application"] = application
-        if cluster is not None:
-            __body["cluster"] = cluster
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if index is not None:
-            __body["index"] = index
         if pretty is not None:
             __query["pretty"] = pretty
+        if not __body:
+            if application is not None:
+                __body["application"] = application
+            if cluster is not None:
+                __body["cluster"] = cluster
+            if index is not None:
+                __body["index"] = index
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("id", "ids", "name", "owner", "realm_name", "username"),
     )
     def invalidate_api_key(
         self,
         *,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         id: t.Optional[str] = None,
-        ids: t.Optional[t.Union[t.List[str], t.Tuple[str, ...]]] = None,
+        ids: t.Optional[t.Sequence[str]] = None,
         name: t.Optional[str] = None,
         owner: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         realm_name: t.Optional[str] = None,
         username: t.Optional[str] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Invalidates one or more API keys.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-invalidate-api-key.html>`_
 
         :param id:
@@ -298,99 +294,124 @@
         :param realm_name: The name of an authentication realm. This parameter cannot
             be used with either `ids` or `name`, or when `owner` flag is set to `true`.
         :param username: The username of a user. This parameter cannot be used with either
             `ids` or `name`, or when `owner` flag is set to `true`.
         """
         __path = "/_security/api_key"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if id is not None:
-            __body["id"] = id
-        if ids is not None:
-            __body["ids"] = ids
-        if name is not None:
-            __body["name"] = name
-        if owner is not None:
-            __body["owner"] = owner
         if pretty is not None:
             __query["pretty"] = pretty
-        if realm_name is not None:
-            __body["realm_name"] = realm_name
-        if username is not None:
-            __body["username"] = username
+        if not __body:
+            if id is not None:
+                __body["id"] = id
+            if ids is not None:
+                __body["ids"] = ids
+            if name is not None:
+                __body["name"] = name
+            if owner is not None:
+                __body["owner"] = owner
+            if realm_name is not None:
+                __body["realm_name"] = realm_name
+            if username is not None:
+                __body["username"] = username
         __headers = {"accept": "application/json", "content-type": "application/json"}
         return self.perform_request(  # type: ignore[return-value]
             "DELETE", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=(
+            "aggregations",
+            "aggs",
+            "from_",
+            "query",
+            "search_after",
+            "size",
+            "sort",
+        ),
         parameter_aliases={"from": "from_"},
     )
     def query_api_keys(
         self,
         *,
+        aggregations: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        aggs: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         from_: t.Optional[int] = None,
         human: t.Optional[bool] = None,
         pretty: t.Optional[bool] = None,
         query: t.Optional[t.Mapping[str, t.Any]] = None,
         search_after: t.Optional[
-            t.Union[
-                t.List[t.Union[None, bool, float, int, str, t.Any]],
-                t.Tuple[t.Union[None, bool, float, int, str, t.Any], ...],
-            ]
+            t.Sequence[t.Union[None, bool, float, int, str, t.Any]]
         ] = None,
         size: t.Optional[int] = None,
         sort: t.Optional[
             t.Union[
+                t.Sequence[t.Union[str, t.Mapping[str, t.Any]]],
                 t.Union[str, t.Mapping[str, t.Any]],
-                t.Union[
-                    t.List[t.Union[str, t.Mapping[str, t.Any]]],
-                    t.Tuple[t.Union[str, t.Mapping[str, t.Any]], ...],
-                ],
             ]
         ] = None,
+        typed_keys: t.Optional[bool] = None,
         with_limited_by: t.Optional[bool] = None,
+        with_profile_uid: t.Optional[bool] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Retrieves information for API keys using a subset of query DSL
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-query-api-key.html>`_
 
+        :param aggregations: Any aggregations to run over the corpus of returned API
+            keys. Aggregations and queries work together. Aggregations are computed only
+            on the API keys that match the query. This supports only a subset of aggregation
+            types, namely: `terms`, `range`, `date_range`, `missing`, `cardinality`,
+            `value_count`, `composite`, `filter`, and `filters`. Additionally, aggregations
+            only run over the same subset of fields that query works with.
+        :param aggs: Any aggregations to run over the corpus of returned API keys. Aggregations
+            and queries work together. Aggregations are computed only on the API keys
+            that match the query. This supports only a subset of aggregation types, namely:
+            `terms`, `range`, `date_range`, `missing`, `cardinality`, `value_count`,
+            `composite`, `filter`, and `filters`. Additionally, aggregations only run
+            over the same subset of fields that query works with.
         :param from_: Starting document offset. By default, you cannot page through more
             than 10,000 hits using the from and size parameters. To page through more
             hits, use the `search_after` parameter.
-        :param query: A query to filter which API keys to return. The query supports
-            a subset of query types, including `match_all`, `bool`, `term`, `terms`,
-            `ids`, `prefix`, `wildcard`, and `range`. You can query all public information
-            associated with an API key.
+        :param query: A query to filter which API keys to return. If the query parameter
+            is missing, it is equivalent to a `match_all` query. The query supports a
+            subset of query types, including `match_all`, `bool`, `term`, `terms`, `match`,
+            `ids`, `prefix`, `wildcard`, `exists`, `range`, and `simple_query_string`.
+            You can query the following public information associated with an API key:
+            `id`, `type`, `name`, `creation`, `expiration`, `invalidated`, `invalidation`,
+            `username`, `realm`, and `metadata`.
         :param search_after: Search after definition
         :param size: The number of hits to return. By default, you cannot page through
             more than 10,000 hits using the `from` and `size` parameters. To page through
             more hits, use the `search_after` parameter.
         :param sort: Other than `id`, all public fields of an API key are eligible for
             sorting. In addition, sort can also be applied to the `_doc` field to sort
             by index order.
+        :param typed_keys: Determines whether aggregation names are prefixed by their
+            respective types in the response.
         :param with_limited_by: Return the snapshot of the owner user's role descriptors
             associated with the API key. An API key's actual permission is the intersection
             of its assigned role descriptors and the owner user's role descriptors.
+        :param with_profile_uid: Determines whether to also retrieve the profile uid,
+            for the API key owner principal, if it exists.
         """
         __path = "/_security/_query/api_key"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         # The 'sort' parameter with a colon can't be encoded to the body.
         if sort is not None and (
             (isinstance(sort, str) and ":" in sort)
             or (
                 isinstance(sort, (list, tuple))
                 and all(isinstance(_x, str) for _x in sort)
                 and any(":" in _x for _x in sort)
@@ -398,61 +419,71 @@
         ):
             __query["sort"] = sort
             sort = None
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
-        if from_ is not None:
-            __body["from"] = from_
         if human is not None:
             __query["human"] = human
         if pretty is not None:
             __query["pretty"] = pretty
-        if query is not None:
-            __body["query"] = query
-        if search_after is not None:
-            __body["search_after"] = search_after
-        if size is not None:
-            __body["size"] = size
-        if sort is not None:
-            __body["sort"] = sort
+        if typed_keys is not None:
+            __query["typed_keys"] = typed_keys
         if with_limited_by is not None:
             __query["with_limited_by"] = with_limited_by
+        if with_profile_uid is not None:
+            __query["with_profile_uid"] = with_profile_uid
+        if not __body:
+            if aggregations is not None:
+                __body["aggregations"] = aggregations
+            if aggs is not None:
+                __body["aggs"] = aggs
+            if from_ is not None:
+                __body["from"] = from_
+            if query is not None:
+                __body["query"] = query
+            if search_after is not None:
+                __body["search_after"] = search_after
+            if size is not None:
+                __body["size"] = size
+            if sort is not None:
+                __body["sort"] = sort
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "POST", __path, params=__query, headers=__headers, body=__body
         )
 
     @_rewrite_parameters(
-        body_fields=True,
+        body_fields=("expiration", "metadata", "role_descriptors"),
     )
     def update_api_key(
         self,
         *,
         id: str,
         error_trace: t.Optional[bool] = None,
-        filter_path: t.Optional[
-            t.Union[str, t.Union[t.List[str], t.Tuple[str, ...]]]
-        ] = None,
+        expiration: t.Optional[t.Union["t.Literal[-1]", "t.Literal[0]", str]] = None,
+        filter_path: t.Optional[t.Union[str, t.Sequence[str]]] = None,
         human: t.Optional[bool] = None,
         metadata: t.Optional[t.Mapping[str, t.Any]] = None,
         pretty: t.Optional[bool] = None,
         role_descriptors: t.Optional[t.Mapping[str, t.Mapping[str, t.Any]]] = None,
+        body: t.Optional[t.Dict[str, t.Any]] = None,
     ) -> ObjectApiResponse[t.Any]:
         """
         Updates attributes of an existing API key.
 
         `<https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-update-api-key.html>`_
 
         :param id: The ID of the API key to update.
+        :param expiration: Expiration time for the API key.
         :param metadata: Arbitrary metadata that you want to associate with the API key.
             It supports nested data structure. Within the metadata object, keys beginning
             with _ are reserved for system usage.
         :param role_descriptors: An array of role descriptors for this API key. This
             parameter is optional. When it is not specified or is an empty array, then
             the API key will have a point in time snapshot of permissions of the authenticated
             user. If you supply role descriptors then the resultant permissions would
@@ -461,27 +492,30 @@
             is the same as the request for create role API. For more details, see create
             or update roles API.
         """
         if id in SKIP_IN_PATH:
             raise ValueError("Empty value passed for parameter 'id'")
         __path = f"/_security/api_key/{_quote(id)}"
         __query: t.Dict[str, t.Any] = {}
-        __body: t.Dict[str, t.Any] = {}
+        __body: t.Dict[str, t.Any] = body if body is not None else {}
         if error_trace is not None:
             __query["error_trace"] = error_trace
         if filter_path is not None:
             __query["filter_path"] = filter_path
         if human is not None:
             __query["human"] = human
-        if metadata is not None:
-            __body["metadata"] = metadata
         if pretty is not None:
             __query["pretty"] = pretty
-        if role_descriptors is not None:
-            __body["role_descriptors"] = role_descriptors
+        if not __body:
+            if expiration is not None:
+                __body["expiration"] = expiration
+            if metadata is not None:
+                __body["metadata"] = metadata
+            if role_descriptors is not None:
+                __body["role_descriptors"] = role_descriptors
         if not __body:
             __body = None  # type: ignore[assignment]
         __headers = {"accept": "application/json"}
         if __body is not None:
             __headers["content-type"] = "application/json"
         return self.perform_request(  # type: ignore[return-value]
             "PUT", __path, params=__query, headers=__headers, body=__body
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/_sync/client/utils.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/_sync/client/utils.py`

 * *Files 8% similar despite different names*

```diff
@@ -56,16 +56,19 @@
 SKIP_IN_PATH: Collection[Any] = (None, "", b"", [], ())
 
 # To be passed to 'client_meta_service' on the Transport
 CLIENT_META_SERVICE = ("esv", client_meta_version(__versionstr__))
 
 # Default User-Agent used by the client
 USER_AGENT = create_user_agent("elasticsearch-py", __versionstr__)
+ELASTIC_API_VERSION = "2023-10-31"
 
-_TYPE_HOST = Union[str, Mapping, NodeConfig]
+_TYPE_HOST = Union[str, Mapping[str, Union[str, int]], NodeConfig]
+
+_TYPE_BODY = Union[bytes, str, Dict[str, Any]]
 
 _TRANSPORT_OPTIONS = {
     "api_key",
     "http_auth",
     "request_timeout",
     "opaque_id",
     "headers",
@@ -93,14 +96,16 @@
 
     # Remove all values which are 'DEFAULT' to avoid overwriting actual defaults.
     node_options = {k: v for k, v in kwargs.items() if v is not DEFAULT}
 
     # Set the 'User-Agent' default header.
     headers = HttpHeaders(node_options.pop("headers", ()))
     headers.setdefault("user-agent", USER_AGENT)
+    headers.setdefault("elastic-api-version", ELASTIC_API_VERSION)
+
     node_options["headers"] = headers
 
     # If a custom Requests AuthBase is passed we set that via '_extras'.
     if requests_session_auth is not None:
         node_options.setdefault("_extras", {})[
             "requests.session.auth"
         ] = requests_session_auth
@@ -108,14 +113,16 @@
     headers = node_config.headers.copy()  # type: ignore[attr-defined]
 
     headers_to_add = node_options.pop("headers", ())
     if headers_to_add:
         headers.update(headers_to_add)
 
     headers.setdefault("user-agent", USER_AGENT)
+    headers.setdefault("elastic-api-version", ELASTIC_API_VERSION)
+
     headers.freeze()
     node_options["headers"] = headers
 
     return node_config.replace(**node_options)
 
 
 def host_to_node_config(host: _TYPE_HOST) -> NodeConfig:
@@ -250,22 +257,51 @@
 
 
 def _merge_kwargs_no_duplicates(kwargs: Dict[str, Any], values: Dict[str, Any]) -> None:
     for key, val in values.items():
         if key in kwargs:
             raise ValueError(
                 f"Received multiple values for '{key}', specify parameters "
-                "directly instead of using 'body' or 'params'"
+                "directly instead of using 'params'"
             )
         kwargs[key] = val
 
 
+def _merge_body_fields_no_duplicates(
+    body: _TYPE_BODY, kwargs: Dict[str, Any], body_fields: Tuple[str, ...]
+) -> bool:
+    mixed_body_and_params = False
+    for key in list(kwargs.keys()):
+        if key in body_fields:
+            if isinstance(body, (str, bytes)):
+                raise ValueError(
+                    "Couldn't merge 'body' with other parameters as it wasn't a mapping."
+                )
+
+            if key in body:
+                raise ValueError(
+                    f"Received multiple values for '{key}', specify parameters "
+                    "using either body or parameters, not both."
+                )
+
+            warnings.warn(
+                f"Received '{key}' via a specific parameter in the presence of a "
+                "'body' parameter, which is deprecated and will be removed in a future "
+                "version. Instead, use only 'body' or only specific parameters.",
+                category=DeprecationWarning,
+                stacklevel=warn_stacklevel(),
+            )
+            body[key] = kwargs.pop(key)
+            mixed_body_and_params = True
+    return mixed_body_and_params
+
+
 def _rewrite_parameters(
     body_name: Optional[str] = None,
-    body_fields: bool = False,
+    body_fields: Optional[Tuple[str, ...]] = None,
     parameter_aliases: Optional[Dict[str, str]] = None,
     ignore_deprecated_options: Optional[Set[str]] = None,
 ) -> Callable[[F], F]:
     def wrapper(api: F) -> F:
         @wraps(api)
         def wrapped(*args: Any, **kwargs: Any) -> Any:
             nonlocal api, body_name, body_fields
@@ -333,48 +369,46 @@
                     if namespaced_client is not None:
                         client = namespaced_client(client)
                     args = (client,) + args[1:]
 
             if "body" in kwargs and (
                 not ignore_deprecated_options or "body" not in ignore_deprecated_options
             ):
-                body = kwargs.pop("body")
+                body: Optional[_TYPE_BODY] = kwargs.pop("body")
+                mixed_body_and_params = False
                 if body is not None:
                     if body_name:
                         if body_name in kwargs:
                             raise TypeError(
                                 f"Can't use '{body_name}' and 'body' parameters together because '{body_name}' "
                                 "is an alias for 'body'. Instead you should only use the "
                                 f"'{body_name}' parameter. See https://github.com/elastic/elasticsearch-py/"
                                 "issues/1698 for more information"
                             )
-
-                        warnings.warn(
-                            "The 'body' parameter is deprecated and will be removed "
-                            f"in a future version. Instead use the '{body_name}' parameter. "
-                            "See https://github.com/elastic/elasticsearch-py/issues/1698 "
-                            "for more information",
-                            category=DeprecationWarning,
-                            stacklevel=warn_stacklevel(),
-                        )
                         kwargs[body_name] = body
-
-                    elif body_fields:
-                        if not hasattr(body, "items"):
-                            raise ValueError(
-                                "Couldn't merge 'body' with other parameters as it wasn't a mapping. "
-                                "Instead of using 'body' use individual API parameters"
-                            )
-                        warnings.warn(
-                            "The 'body' parameter is deprecated and will be removed "
-                            "in a future version. Instead use individual parameters.",
-                            category=DeprecationWarning,
-                            stacklevel=warn_stacklevel(),
+                    elif body_fields is not None:
+                        mixed_body_and_params = _merge_body_fields_no_duplicates(
+                            body, kwargs, body_fields
                         )
-                        _merge_kwargs_no_duplicates(kwargs, body)
+                        kwargs["body"] = body
+
+                    if parameter_aliases and not isinstance(body, (str, bytes)):
+                        for alias, rename_to in parameter_aliases.items():
+                            if rename_to in body:
+                                body[alias] = body.pop(rename_to)
+                                # If body and params are mixed, the alias may come from a param,
+                                # in which case the warning below will not make sense.
+                                if not mixed_body_and_params:
+                                    warnings.warn(
+                                        f"Using '{rename_to}' alias in 'body' is deprecated and will be removed "
+                                        f"in a future version of elasticsearch-py. Use '{alias}' directly instead. "
+                                        "See https://github.com/elastic/elasticsearch-py/issues/1698 for more information",
+                                        category=DeprecationWarning,
+                                        stacklevel=2,
+                                    )
 
             if parameter_aliases:
                 for alias, rename_to in parameter_aliases.items():
                     try:
                         kwargs[rename_to] = kwargs.pop(alias)
                     except KeyError:
                         pass
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/helpers/__init__.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/helpers/__init__.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/helpers/actions.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/helpers/actions.py`

 * *Files 2% similar despite different names*

```diff
@@ -258,15 +258,15 @@
     ):
         status_code = item.get("status", 500)
 
         ok = 200 <= status_code < 300
         if not ok and raise_on_error and status_code not in ignore_status:
             # include original document source
             if len(data) > 1:
-                item["data"] = data[1]  # type: ignore[misc]
+                item["data"] = data[1]
             errors.append({op_type: item})
 
         if ok or not errors:
             # if we are not just recording all errors to be able to raise
             # them all at once, yield items individually
             yield ok, {op_type: item}
 
@@ -295,15 +295,15 @@
     exc_errors = []
 
     for data in bulk_data:
         # collect all the information about failed actions
         op_type, action = data[0].copy().popitem()
         info = {"error": err_message, "status": error.status_code, "exception": error}
         if op_type != "delete" and len(data) > 1:
-            info["data"] = data[1]  # type: ignore[misc]
+            info["data"] = data[1]
         info.update(action)
         exc_errors.append({op_type: info})
 
     # emulate standard behavior for failed actions
     if raise_on_error and error.status_code not in ignore_status:
         raise BulkIndexError(
             f"{len(exc_errors)} document(s) failed to index.", exc_errors
@@ -703,15 +703,15 @@
         resp = client.search(**search_kwargs)
 
     # Try the old deprecated way if we fail immediately on parameters.
     except TypeError:
         search_kwargs = kwargs.copy()
         search_kwargs["scroll"] = scroll
         search_kwargs["size"] = size
-        resp = client.search(body=query, **search_kwargs)  # type: ignore[call-arg]
+        resp = client.search(body=query, **search_kwargs)
 
     scroll_id = resp.get("_scroll_id")
     scroll_transport_kwargs = pop_transport_kwargs(scroll_kwargs)
     if scroll_transport_kwargs:
         scroll_client = client.options(**scroll_transport_kwargs)
     else:
         scroll_client = client
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/elasticsearch_serverless/helpers/errors.py` & `elasticsearch_serverless-0.2.0.20231031/elasticsearch_serverless/helpers/errors.py`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/.gitignore` & `elasticsearch_serverless-0.2.0.20231031/.gitignore`

 * *Files 4% similar despite different names*

```diff
@@ -141,7 +141,10 @@
 .idea
 
 # elasticsearch files
 test_elasticsearch/cover
 test_elasticsearch/local.py
 .ci/output
 junit/
+
+# sample code for GitHub issues
+issues
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/LICENSE` & `elasticsearch_serverless-0.2.0.20231031/LICENSE`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/README.rst` & `elasticsearch_serverless-0.2.0.20231031/README.rst`

 * *Files identical despite different names*

### Comparing `elasticsearch_serverless-0.1.0.20231031/pyproject.toml` & `elasticsearch_serverless-0.2.0.20231031/pyproject.toml`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 [build-system]
 requires = ["hatchling"]
 build-backend = "hatchling.build"
 
 [project]
 name = "elasticsearch-serverless"
-version = "0.1.0.20231031"
+version = "0.2.0.20231031"
 description = "Python client for Elasticsearch Serverless"
 readme = "README.rst"
 license = "Apache-2.0"
 requires-python = ">=3.7, <4"
 authors = [
     { name = "Elastic Client Library Maintainers", email = "client-libs@elastic.co" },
 ]
@@ -37,15 +37,15 @@
     "mapping",
     "REST",
     "search",
     "client",
     "index",
 ]
 dependencies = [
-    "elastic-transport>=8,<9",
+    "elastic-transport>=8.4.1,<9",
 ]
 
 [project.optional-dependencies]
 async = [
     "aiohttp>=3,<4",
 ]
 requests = [
@@ -91,14 +91,17 @@
     "/LICENSE",
     "/NOTICE",
     "/README.rst",
     "/setup.cfg",
     "/docs/sphinx",
 ]
 
+[tool.hatch.build.targets.wheel]
+packages = ["elasticsearch_serverless"]
+
 [tool.pytest]
 junit_family = "legacy"
 addopts = "-vvv -p no:logging --cov-report=term-missing --cov=elasticsearch_serverless --cov-config=.pyproject.toml"
 
 [tool.isort]
 profile = "black"
```

### Comparing `elasticsearch_serverless-0.1.0.20231031/PKG-INFO` & `elasticsearch_serverless-0.2.0.20231031/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-Metadata-Version: 2.1
+Metadata-Version: 2.3
 Name: elasticsearch-serverless
-Version: 0.1.0.20231031
+Version: 0.2.0.20231031
 Summary: Python client for Elasticsearch Serverless
 Project-URL: Documentation, https://elasticsearch-serverless-python.readthedocs.io
 Project-URL: Homepage, https://github.com/elastic/elasticsearch-serverless-python
 Project-URL: Issue Tracker, https://github.com/elastic/elasticsearch-serverless-python/issues
 Project-URL: Source Code, https://github.com/elastic/elasticsearch-serverless-python
 Author-email: Elastic Client Library Maintainers <client-libs@elastic.co>
 Maintainer-email: Elastic Client Library Maintainers <client-libs@elastic.co>
@@ -22,15 +22,15 @@
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 Requires-Python: <4,>=3.7
-Requires-Dist: elastic-transport<9,>=8
+Requires-Dist: elastic-transport<9,>=8.4.1
 Provides-Extra: async
 Requires-Dist: aiohttp<4,>=3; extra == 'async'
 Provides-Extra: dev
 Requires-Dist: aiohttp; extra == 'dev'
 Requires-Dist: black; extra == 'dev'
 Requires-Dist: build; extra == 'dev'
 Requires-Dist: coverage; extra == 'dev'
```

